{"version":3,"file":"static/js/5392.2b4d4d69.chunk.js","mappings":"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","sources":["plugins/DocumentHandler/documentSearch/DocumentSearchModel.js","plugins/DocumentHandler/documentSearch/MatchSearch.js","plugins/DocumentHandler/utils/helpers.js","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/regex.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/validate.js","../node_modules/uuid/dist/esm-browser/v4.js"],"sourcesContent":["import MatchSearch from \"./MatchSearch\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { splitAndTrimOnCommas } from \"../utils/helpers\";\nimport { decodeCommas } from \"../../../utils/StringCommaCoder\";\n\nexport default class DocumentSearchModel {\n  constructor(settings) {\n    this.globalSearchModel = settings.globalSearchModel;\n    this.documentCollections = this.createDocumentCollectionsToSearch(\n      settings.allDocuments\n    );\n    this.localObserver = settings.localObserver;\n    this.app = settings.app;\n    this.bindListenForSearchResultClick();\n  }\n\n  bindListenForSearchResultClick = () => {\n    // The event published from the search component will be prepended\n    // with \"search.featureClicked\", therefore we have to subscribe\n    // to search.featureClicked.onClickName to catch the event.\n    this.app.globalObserver.subscribe(\n      \"search.featureClicked.documentHandlerSearchResultClicked\",\n      (searchResultClick) => {\n        this.localObserver.publish(\"document-link-clicked\", {\n          documentName: searchResultClick.properties.documentFileName,\n          headerIdentifier: searchResultClick.properties.headerIdentifier,\n        });\n      }\n    );\n  };\n\n  createDocumentCollectionsToSearch = (allDocuments) => {\n    return allDocuments.reduce((documentCollection, document) => {\n      return [\n        ...documentCollection,\n        {\n          documentFileName: document.documentFileName,\n          documentTitle: document.documentTitle,\n          features: [\n            ...this.getFeatures(document.chapters, document),\n            this.getSpecialTitleFeature(\n              document\n            ) /*We need to add a special feature that is not working the same way \n            when autocomplete is initiated and when a search is initiated.*/,\n          ],\n        },\n      ];\n    }, []);\n  };\n\n  getFeatures = (chapters, document) => {\n    return chapters.reduce((features, chapter) => {\n      if (chapter.chapters) {\n        features = [\n          ...features,\n          ...this.getFeatures(chapter.chapters, document),\n        ];\n      }\n      features = [\n        ...features,\n        this.createFeatureFromChapter(chapter, document),\n      ];\n      return features;\n    }, []);\n  };\n\n  /*We add a special feature to with only document.title as searchfield.\n  this feature is used when user is getting an autocomplete. \n  See method handleSpecialCaseWithTitleHit for more information.\n  */\n\n  getSpecialTitleFeature = (document) => {\n    let properties = {\n      header: document.documentTitle,\n      geoids: [],\n      headerIdentifier: document.documentTitle,\n      documentTitle: document.documentTitle,\n      documentFileName: document.documentFileName,\n    };\n\n    const id = `${document.documentTitle}${Math.floor(Math.random() * 1000)}`;\n\n    return {\n      type: \"Feature\",\n      isTitleFeature: true,\n      geometry: null,\n      searchValues: [document.title],\n      id: id,\n      onClickName: \"documentHandlerSearchResultClicked\",\n      properties: properties,\n      get: (p) => properties[p],\n      getGeometry: () => null,\n      getId: () => id,\n      setStyle: () => null,\n    };\n  };\n\n  createFeatureFromChapter = (chapter, document) => {\n    let searchValues = [];\n\n    if (chapter.header) {\n      searchValues.push(chapter.header);\n    }\n    if (chapter.keywords && chapter.keywords.length > 0) {\n      searchValues = [...searchValues, ...chapter.keywords];\n    }\n\n    const properties = {\n      header: chapter.header,\n      geoids: chapter.geoids,\n      headerIdentifier: chapter.headerIdentifier,\n      documentTitle: document.documentTitle,\n      documentFileName: document.documentFileName,\n    };\n\n    const id = `${chapter.headerIdentifier}${Math.floor(Math.random() * 1000)}`;\n\n    return {\n      type: \"Feature\",\n      geometry: null,\n      isTitleFeature: false,\n      searchValues: searchValues,\n      id: id,\n      onClickName: \"documentHandlerSearchResultClicked\",\n      properties: properties,\n      get: (p) => properties[p],\n      getGeometry: () => null,\n      getId: () => id,\n      setStyle: () => null,\n    };\n  };\n\n  implementSearchInterface = () => {\n    return {\n      getResults: this.getResults,\n      getFunctionality: this.getFunctionality,\n    };\n  };\n\n  // getFunctionality is called by searchComponent in core (Part of searchInterface)\n  // The search-component demands this method, and if it is not present in the interface,\n  // the plugin will not be used in the search-component at all.\n  // The getFunctionality-method is supposed to return an object as follows:\n  // return {\n  //   name: \"TOOL DISPLAY NAME\",\n  //   icon: TOOL ICON,\n  //   type: \"EXTERNAL_PLUGIN\",\n  //   searchFunctionalityClickName: \"GLOBAL OBSERVER EVENT NAME\",\n  // };\n  // If we want to make use of the plugin in the search-component regardless (without the functionality)\n  // we can just let the method return null.\n  getFunctionality = () => {\n    return null;\n  };\n\n  //Method called by searchComponent in core (Part of searchInterface)\n  getResults = (searchString, searchOptions) => {\n    this.matchSearch = new MatchSearch(searchOptions);\n    this.searchOptions = searchOptions;\n    return this.getDocumentHandlerResults(searchString);\n  };\n\n  getDocumentHandlerResults = (searchString) => {\n    return new Promise((resolve, reject) => {\n      if (searchString === \"\") {\n        resolve({ featureCollections: [], errors: [] });\n      }\n      let possibleSearchCombinations = this.searchOptions\n        .getPossibleCombinations\n        ? this.globalSearchModel.getPossibleSearchCombinations(searchString)\n        : [splitAndTrimOnCommas(searchString)];\n\n      // The searchString will be encoded if the search has been initiated\n      // by selecting an alternative in the autocomplete.\n      possibleSearchCombinations =\n        this.decodePotentialSpecialCharsFromFeatureProps(\n          possibleSearchCombinations\n        );\n\n      resolve({\n        featureCollections: this.getFeatureCollectionsForMatchingDocuments(\n          possibleSearchCombinations\n        ),\n        errors: [],\n      });\n    });\n  };\n\n  decodePotentialSpecialCharsFromFeatureProps = (searchCombinations) => {\n    return searchCombinations.map((combination) => {\n      return combination.map((word) => {\n        return decodeCommas(word);\n      });\n    });\n  };\n\n  getSearchFields = (matchedFeatures) => {\n    return matchedFeatures.reduce((searchFields, feature) => {\n      if (feature.matchedSearchValues.length > 0) {\n        searchFields = [\n          ...searchFields,\n          ...this.getMockedSearchFieldForChapter(feature),\n        ];\n      }\n      return searchFields;\n    }, []);\n  };\n\n  /*When a search is initiated for autocomplete we search for the title of the document\n  only in the special features created in getSpecialTitleFeature. When the user then\n  clicks this feature in the searchresultlist, we add the documenttitle as a searchfield\n  for all chapters/features in that document because we want to show the user all\n  the chapters in that document*/\n\n  getMatchedFeatures = (docFeatureCollection, possibleSearchCombinations) => {\n    const { initiator } = this.searchOptions;\n    return docFeatureCollection.features.reduce((matchedFeatures, feature) => {\n      if (initiator === \"search\") {\n        if (feature.isTitleFeature) {\n          //If feature is a special titleFeature and we are making a search, it is not supposed to be in the resultlist\n          return matchedFeatures;\n        }\n        feature.searchValues.push(docFeatureCollection.documentTitle);\n      }\n\n      if (initiator === \"autocomplete\" && !feature.isTitleFeature) {\n        feature.searchValues = feature.searchValues.filter((searchValue) => {\n          return searchValue !== docFeatureCollection.documentTitle;\n        });\n      }\n\n      feature.matchedSearchValues = this.getMatchedSearchValues(\n        possibleSearchCombinations,\n        feature.searchValues\n      );\n\n      return feature.matchedSearchValues.length > 0\n        ? [...matchedFeatures, feature]\n        : matchedFeatures;\n    }, []);\n  };\n\n  createFeatureCollection = (\n    matchedFeatures,\n    searchFields,\n    docFeatureCollection\n  ) => {\n    return {\n      value: {\n        status: \"fulfilled\",\n        type: \"FeatureCollection\",\n        crs: { type: null, properties: { name: null } },\n        features: matchedFeatures,\n        numberMatched: matchedFeatures.length,\n        numberReturned: matchedFeatures.length,\n        timeStamp: new Date().toISOString(),\n        totalFeatures: matchedFeatures.length,\n      },\n      source: {\n        id:\n          docFeatureCollection.documentTitle ||\n          docFeatureCollection.documentFileName,\n        caption:\n          docFeatureCollection.documentTitle ||\n          docFeatureCollection.documentFileName,\n        displayFields: [\"header\"],\n        searchFields: [...searchFields],\n      },\n      origin: \"DOCUMENT\",\n    };\n  };\n\n  getFeatureCollectionsForMatchingDocuments = (possibleSearchCombinations) => {\n    return this.documentCollections.reduce(\n      (featureCollections, documentCollection) => {\n        const matchedFeatures = this.getMatchedFeatures(\n          documentCollection,\n          possibleSearchCombinations\n        );\n        const searchFields = this.getSearchFields(matchedFeatures);\n        const featureCollection = this.createFeatureCollection(\n          matchedFeatures,\n          searchFields,\n          documentCollection\n        );\n\n        return featureCollection\n          ? [...featureCollections, featureCollection]\n          : featureCollections;\n      },\n      []\n    );\n  };\n\n  getMockedSearchFieldForChapter = (feature) => {\n    return feature.matchedSearchValues.reduce((searchFields, searchValue) => {\n      const searchField = uuidv4();\n      feature.properties[searchField] = searchValue;\n      return [...searchFields, searchField];\n    }, []);\n  };\n\n  getAllMatchedSearchValues = (word, searchValues) => {\n    const allMatched = new Set();\n    const matchedSearchValues = this.getMatched(word, searchValues);\n\n    matchedSearchValues.forEach((matched) => {\n      allMatched.add(matched);\n    });\n\n    return allMatched;\n  };\n\n  /**\n   * TODO - Try to refactor, difficult though\n   * If any (some-function) of the searchcombinations is hit, that is a match\n   * a searchCombination can be a hit if the documentTitle is present in the combination, results in adding all as matched\n   * a searchCombination can be hit if every combination has a searchhit\n   */\n  getMatchedSearchValues = (searchCombinations, searchValues) => {\n    let allMatched = new Set();\n    let match = searchCombinations.some((searchCombination) => {\n      return searchCombination.every((word) => {\n        let matchedSet = this.getAllMatchedSearchValues(word, searchValues);\n        allMatched = new Set([...allMatched, ...matchedSet]);\n        return matchedSet.size > 0;\n      });\n    });\n    return match ? Array.from(allMatched) : [];\n  };\n\n  getMatched = (searchString, searchFields) => {\n    return searchFields.reduce((matchedSearchFields, searchField) => {\n      if (this.matchSearch.compare(searchString, searchField)) {\n        return [...matchedSearchFields, searchField];\n      }\n      return matchedSearchFields;\n    }, []);\n  };\n}\n","export default class MatchSearch {\n  constructor(searchOptions) {\n    this.searchOptions = searchOptions;\n  }\n\n  getMatchRegexp = (searchString) => {\n    const { wildcardAtEnd, wildcardAtStart, matchCase } = this.searchOptions;\n\n    let regexpOptions = matchCase ? \"g\" : \"gi\";\n    if (wildcardAtStart && !wildcardAtEnd) {\n      return new RegExp(`.*${searchString}$`, regexpOptions);\n    }\n\n    if (!wildcardAtStart && wildcardAtEnd) {\n      return new RegExp(`^${searchString}.*`, regexpOptions);\n    }\n\n    if (wildcardAtStart && wildcardAtEnd) {\n      return new RegExp(`${searchString}`, regexpOptions);\n    }\n    return new RegExp(`^${searchString}$`, regexpOptions);\n  };\n\n  escapeSpecialChars = (string) => {\n    return string.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n  };\n\n  compare = (searchString, searchword) => {\n    const toSearchIn = this.escapeSpecialChars(searchString);\n    const match = this.getMatchRegexp(toSearchIn).test(searchword);\n\n    return match;\n  };\n}\n","export const splitAndTrimOnCommas = (searchString) => {\n  return searchString.split(\",\").map((string) => {\n    return string.trim();\n  });\n};\n\nexport const getStringArray = (searchString) => {\n  let tempStringArray = splitAndTrimOnCommas(searchString);\n  return tempStringArray.join(\" \").split(\" \");\n};\n\nexport const hasSubMenu = (item) => {\n  return item.menu && item.menu.length > 0;\n};\n\nexport const flattenChaptersTree = (chapters) => {\n  return chapters.reduce((acc, chapter) => {\n    if (chapter.header) {\n      let chapterStrippedFromSubChapters = { ...chapter };\n      chapterStrippedFromSubChapters.chapters = [];\n      acc = [...acc, chapterStrippedFromSubChapters];\n    }\n    if (chapter.chapters && chapter.chapters.length > 0) {\n      return [...acc, ...flattenChaptersTree(chapter.chapters)];\n    }\n    return acc;\n  }, []);\n};\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;"],"names":["DocumentSearchModel","constructor","settings","bindListenForSearchResultClick","this","app","globalObserver","subscribe","searchResultClick","localObserver","publish","documentName","properties","documentFileName","headerIdentifier","createDocumentCollectionsToSearch","allDocuments","reduce","documentCollection","document","documentTitle","features","getFeatures","chapters","getSpecialTitleFeature","chapter","createFeatureFromChapter","header","geoids","id","Math","floor","random","type","isTitleFeature","geometry","searchValues","title","onClickName","get","p","getGeometry","getId","setStyle","push","keywords","length","implementSearchInterface","getResults","getFunctionality","searchString","searchOptions","matchSearch","MatchSearch","getDocumentHandlerResults","Promise","resolve","reject","featureCollections","errors","possibleSearchCombinations","getPossibleCombinations","globalSearchModel","getPossibleSearchCombinations","splitAndTrimOnCommas","decodePotentialSpecialCharsFromFeatureProps","getFeatureCollectionsForMatchingDocuments","searchCombinations","map","combination","word","decodeCommas","getSearchFields","matchedFeatures","searchFields","feature","matchedSearchValues","getMockedSearchFieldForChapter","getMatchedFeatures","docFeatureCollection","initiator","filter","searchValue","getMatchedSearchValues","createFeatureCollection","value","status","crs","name","numberMatched","numberReturned","timeStamp","Date","toISOString","totalFeatures","source","caption","displayFields","origin","documentCollections","featureCollection","searchField","uuidv4","getAllMatchedSearchValues","allMatched","Set","getMatched","forEach","matched","add","some","searchCombination","every","matchedSet","size","Array","from","matchedSearchFields","compare","getMatchRegexp","wildcardAtEnd","wildcardAtStart","matchCase","regexpOptions","RegExp","escapeSpecialChars","string","replace","searchword","toSearchIn","test","split","trim","getStringArray","join","hasSubMenu","item","menu","flattenChaptersTree","acc","chapterStrippedFromSubChapters","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","msCrypto","Error","uuid","REGEX","byteToHex","i","toString","substr","arr","offset","arguments","undefined","toLowerCase","validate","TypeError","options","buf","rnds","stringify"],"sourceRoot":""}