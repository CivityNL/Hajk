{"version":3,"file":"static/js/9716.0ae2de34.chunk.js","mappings":"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","sources":["plugins/Location/LocationModel.js","../node_modules/ol/Geolocation.js"],"sourcesContent":["import Geolocation from \"ol/Geolocation.js\";\nimport Feature from \"ol/Feature.js\";\nimport Point from \"ol/geom/Point.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { easeOut } from \"ol/easing\";\nimport { getVectorContext } from \"ol/render\";\nimport { unByKey } from \"ol/Observable\";\nimport { Circle as CircleStyle, Fill, Stroke, Style } from \"ol/style.js\";\n\nclass LocationModel {\n  constructor(props) {\n    this.map = props.map;\n    this.localObserver = props.localObserver;\n    this.zoomToLocation = true;\n\n    // Create source and layer and add to map. Later on we'll draw features to this layer.\n    this.source = new VectorSource({ wrapX: false });\n    this.layer = new VectorLayer({\n      source: this.source,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginLocation\",\n      caption: \"Location layer\",\n    });\n    this.map.addLayer(this.layer);\n\n    // Create two features: one for position (point) and\n    // another one for position accuracy (outer ring)\n    this.accuracyFeature = new Feature();\n    this.positionFeature = new Feature();\n    this.positionFeature.setStyle(\n      new Style({\n        image: new CircleStyle({\n          radius: 6,\n          fill: new Fill({\n            color: \"#3399CC\",\n          }),\n          stroke: new Stroke({\n            color: \"#fff\",\n            width: 2,\n          }),\n        }),\n      })\n    );\n\n    // Init geolocation layer where the point will be drawn to\n    this.geolocation = new Geolocation({\n      trackingOptions: {\n        enableHighAccuracy: true,\n      },\n      projection: this.map.getView().getProjection(),\n    });\n\n    // Set up some event handlers for our Geolocation object\n    this.geolocation.on(\"change\", this.handleGeolocationChange);\n    this.geolocation.on(\"error\", this.handleGeolocationError);\n    this.geolocation.on(\n      \"change:accuracyGeometry\",\n      this.handleGeolocationChangeAccuracy\n    );\n    this.geolocation.on(\n      \"change:position\",\n      this.handleGeolocationChangePosition\n    );\n  }\n\n  handleGeolocationChange = (e) => {\n    this.localObserver.publish(\"geolocationChange\", {\n      accuracy: e.target.getAccuracy(),\n      altitude: e.target.getAltitude(),\n      altitudeAccuracy: e.target.getAltitudeAccuracy(),\n      heading: e.target.getHeading(),\n      speed: e.target.getSpeed(),\n    });\n  };\n\n  handleGeolocationError = (error) => {\n    this.localObserver.publish(\"locationStatus\", \"error\");\n    // Yeah, it's clumsy but we want to send another event\n    // with the error object, so the first event is not enough.\n    this.localObserver.publish(\"geolocationError\", error);\n  };\n\n  handleGeolocationChangeAccuracy = (e) => {\n    this.accuracyFeature.setGeometry(e.target.getAccuracyGeometry());\n  };\n\n  handleGeolocationChangePosition = (e) => {\n    const coordinates = e.target.getPosition();\n    this.positionFeature.setGeometry(\n      coordinates ? new Point(coordinates) : null\n    );\n\n    // If we've got new coordinates, make sure to hide the loading indicator\n    this.localObserver.publish(\"locationStatus\", \"on\");\n\n    if (this.zoomToLocation) {\n      const maxZoom = this.map.getView().getMaxZoom();\n      const minZoom = this.map.getView().getMinZoom();\n      const zoom = Math.ceil((maxZoom - minZoom) * 0.5); // Let's end up in the middle zoom\n      this.map.getView().animate({ duration: 2500, center: coordinates, zoom });\n      this.zoomToLocation = false;\n    }\n  };\n\n  toggleTracking = (active) => {\n    // Inform the View components that we're loading\n    this.localObserver.publish(\"locationStatus\", active ? \"loading\" : \"off\");\n\n    this.geolocation.setTracking(active);\n\n    // If deactivating, cleanup\n    if (active === false) {\n      // Remove features from map if tracking has been switched off\n      this.layer.getSource().clear();\n      // Make sure that we zoom to location next time tracking is activated\n      this.zoomToLocation = true;\n    }\n    // If activating, add two features to map:\n    // one for accuracy (the outer ring) and one for position (inner point)\n    else {\n      this.layer.getSource().addFeature(this.accuracyFeature);\n      this.layer.getSource().addFeature(this.positionFeature);\n\n      // Finally, start flashing the position feature\n      setInterval(() => {\n        this.flash(this.positionFeature);\n      }, 3000);\n    }\n  };\n\n  // Flash handler: sets up the animation and creats a handler for the postrender\n  flash = (feature) => {\n    // Helper: takes care of the actual animation.\n    const animate = (event) => {\n      // Event is the postrender event that happens - surprise - after render,\n      // because we actually tell the map to render (see at the end of this function)\n      const frameState = event.frameState;\n      const elapsed = frameState.time - start;\n      if (elapsed >= duration) {\n        // Remove the listener when time has elapsed\n        unByKey(listenerKey);\n        return;\n      }\n\n      // Grab the context that will hold our animated feature\n      const vectorContext = getVectorContext(event);\n      const elapsedRatio = elapsed / duration;\n\n      // Radius will be 5 at start and 30 at end\n      const radius = easeOut(elapsedRatio) * 25 + 5;\n      const opacity = easeOut(1 - elapsedRatio);\n\n      const style = new Style({\n        image: new CircleStyle({\n          radius: radius,\n          stroke: new Stroke({\n            color: \"rgba(255, 0, 0, \" + opacity + \")\",\n            width: 0.25 + opacity,\n          }),\n        }),\n      });\n\n      vectorContext.setStyle(style);\n      vectorContext.drawGeometry(flashGeom);\n\n      // This ensure that the listener for postrender will be triggered\n      this.map.render();\n    };\n\n    // Setup the animation\n    const duration = 3000;\n    const start = Date.now();\n    // Prepare the feature that will get animated\n    const flashGeom = feature.getGeometry().clone();\n    // Save the listener key so we can unsubscribe when animation is done\n    const listenerKey = this.layer.on(\"postrender\", animate);\n  };\n\n  enable() {\n    this.toggleTracking(true);\n  }\n\n  disable() {\n    this.toggleTracking(false);\n  }\n}\n\nexport default LocationModel;\n","/**\n * @module ol/Geolocation\n */\nimport BaseEvent from './events/Event.js';\nimport BaseObject from './Object.js';\nimport {circular as circularPolygon} from './geom/Polygon.js';\nimport {\n  get as getProjection,\n  getTransformFromProjections,\n  identityTransform,\n} from './proj.js';\nimport {toRadians} from './math.js';\n\n/**\n * @enum {string}\n */\nconst Property = {\n  ACCURACY: 'accuracy',\n  ACCURACY_GEOMETRY: 'accuracyGeometry',\n  ALTITUDE: 'altitude',\n  ALTITUDE_ACCURACY: 'altitudeAccuracy',\n  HEADING: 'heading',\n  POSITION: 'position',\n  PROJECTION: 'projection',\n  SPEED: 'speed',\n  TRACKING: 'tracking',\n  TRACKING_OPTIONS: 'trackingOptions',\n};\n\n/**\n * @enum string\n */\nconst GeolocationErrorType = {\n  /**\n   * Triggered when a `GeolocationPositionError` occurs.\n   * @event module:ol/Geolocation.GeolocationError#error\n   * @api\n   */\n  ERROR: 'error',\n};\n\n/**\n * @classdesc\n * Events emitted on [GeolocationPositionError](https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError).\n */\nexport class GeolocationError extends BaseEvent {\n  /**\n   * @param {GeolocationPositionError} error error object.\n   */\n  constructor(error) {\n    super(GeolocationErrorType.ERROR);\n\n    /**\n     * Code of the underlying `GeolocationPositionError`.\n     * @type {number}\n     * @api\n     */\n    this.code = error.code;\n\n    /**\n     * Message of the underlying `GeolocationPositionError`.\n     * @type {string}\n     * @api\n     */\n    this.message = error.message;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [tracking=false] Start Tracking right after\n * instantiation.\n * @property {PositionOptions} [trackingOptions] Tracking options.\n * See https://www.w3.org/TR/geolocation-API/#position_options_interface.\n * @property {import(\"./proj.js\").ProjectionLike} [projection] The projection the position\n * is reported in.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|\n *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|\n *    'change:trackingOptions'} GeolocationObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<GeolocationObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").OnSignature<'error', GeolocationError, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|GeolocationObjectEventTypes, Return> &\n *   import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return>} GeolocationOnSignature\n */\n\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)\n * is used to locate a user's position.\n *\n * To get notified of position changes and errors, register listeners for the generic\n * `change` event and the `error` event on your instance of {@link module:ol/Geolocation~Geolocation}.\n *\n * Example:\n *\n *     const geolocation = new Geolocation({\n *       // take the projection to use from the map's view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on('change', function(evt) {\n *       console.log(geolocation.getPosition());\n *     });\n *     // listen to error\n *     geolocation.on('error', function(evt) {\n *       window.console.log(evt.message);\n *     });\n *\n * @fires GeolocationError\n * @api\n */\nclass Geolocation extends BaseObject {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GeolocationOnSignature<void>}\n     */\n    this.un;\n\n    options = options || {};\n\n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {?import(\"./coordinate.js\").Coordinate}\n     */\n    this.position_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./proj.js\").TransformFunction}\n     */\n    this.transform_ = identityTransform;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.watchId_ = undefined;\n\n    this.addChangeListener(Property.PROJECTION, this.handleProjectionChanged_);\n    this.addChangeListener(Property.TRACKING, this.handleTrackingChanged_);\n\n    if (options.projection !== undefined) {\n      this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== undefined) {\n      this.setTrackingOptions(options.trackingOptions);\n    }\n\n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.setTracking(false);\n    super.disposeInternal();\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    const projection = this.getProjection();\n    if (projection) {\n      this.transform_ = getTransformFromProjections(\n        getProjection('EPSG:4326'),\n        projection\n      );\n      if (this.position_) {\n        this.set(Property.POSITION, this.transform_(this.position_));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleTrackingChanged_() {\n    if ('geolocation' in navigator) {\n      const tracking = this.getTracking();\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(\n          this.positionChange_.bind(this),\n          this.positionError_.bind(this),\n          this.getTrackingOptions()\n        );\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPosition} position position event.\n   */\n  positionChange_(position) {\n    const coords = position.coords;\n    this.set(Property.ACCURACY, coords.accuracy);\n    this.set(\n      Property.ALTITUDE,\n      coords.altitude === null ? undefined : coords.altitude\n    );\n    this.set(\n      Property.ALTITUDE_ACCURACY,\n      coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy\n    );\n    this.set(\n      Property.HEADING,\n      coords.heading === null ? undefined : toRadians(coords.heading)\n    );\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    const projectedPosition = this.transform_(this.position_);\n    this.set(Property.POSITION, projectedPosition.slice());\n    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);\n    const geometry = circularPolygon(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPositionError} error error object.\n   */\n  positionError_(error) {\n    this.dispatchEvent(new GeolocationError(error));\n  }\n\n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAccuracy() {\n    return /** @type {number|undefined} */ (this.get(Property.ACCURACY));\n  }\n\n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?import(\"./geom/Polygon.js\").default} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n  getAccuracyGeometry() {\n    return /** @type {?import(\"./geom/Polygon.js\").default} */ (\n      this.get(Property.ACCURACY_GEOMETRY) || null\n    );\n  }\n\n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n  getAltitude() {\n    return /** @type {number|undefined} */ (this.get(Property.ALTITUDE));\n  }\n\n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAltitudeAccuracy() {\n    return /** @type {number|undefined} */ (\n      this.get(Property.ALTITUDE_ACCURACY)\n    );\n  }\n\n  /**\n   * Get the heading as radians clockwise from North.\n   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`\n   * is set to `true` in the tracking options.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n  getHeading() {\n    return /** @type {number|undefined} */ (this.get(Property.HEADING));\n  }\n\n  /**\n   * Get the position of the device.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the projection associated with the position.\n   * @return {import(\"./proj/Projection.js\").default|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return /** @type {import(\"./proj/Projection.js\").default|undefined} */ (\n      this.get(Property.PROJECTION)\n    );\n  }\n\n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n  getSpeed() {\n    return /** @type {number|undefined} */ (this.get(Property.SPEED));\n  }\n\n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n  getTracking() {\n    return /** @type {boolean} */ (this.get(Property.TRACKING));\n  }\n\n  /**\n   * Get the tracking options.\n   * See https://www.w3.org/TR/geolocation-API/#position-options.\n   * @return {PositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  getTrackingOptions() {\n    return /** @type {PositionOptions|undefined} */ (\n      this.get(Property.TRACKING_OPTIONS)\n    );\n  }\n\n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {import(\"./proj.js\").ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(Property.PROJECTION, getProjection(projection));\n  }\n\n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n  setTracking(tracking) {\n    this.set(Property.TRACKING, tracking);\n  }\n\n  /**\n   * Set the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @param {PositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  setTrackingOptions(options) {\n    this.set(Property.TRACKING_OPTIONS, options);\n  }\n}\n\nexport default Geolocation;\n"],"names":["constructor","props","handleGeolocationChange","e","this","localObserver","publish","accuracy","target","getAccuracy","altitude","getAltitude","altitudeAccuracy","getAltitudeAccuracy","heading","getHeading","speed","getSpeed","handleGeolocationError","error","handleGeolocationChangeAccuracy","accuracyFeature","setGeometry","getAccuracyGeometry","handleGeolocationChangePosition","coordinates","getPosition","positionFeature","Point","zoomToLocation","maxZoom","map","getView","getMaxZoom","minZoom","getMinZoom","zoom","Math","ceil","animate","duration","center","toggleTracking","active","geolocation","setTracking","layer","getSource","clear","addFeature","setInterval","flash","feature","start","Date","now","flashGeom","getGeometry","clone","listenerKey","on","event","elapsed","frameState","time","unByKey","vectorContext","getVectorContext","elapsedRatio","radius","easeOut","opacity","style","Style","image","CircleStyle","stroke","Stroke","color","width","setStyle","drawGeometry","render","source","VectorSource","wrapX","VectorLayer","layerType","zIndex","name","caption","addLayer","Feature","fill","Fill","Geolocation","trackingOptions","enableHighAccuracy","projection","getProjection","enable","disable","Property","GeolocationErrorType","GeolocationError","BaseEvent","super","code","message","BaseObject","options","once","un","position_","transform_","identityTransform","watchId_","undefined","addChangeListener","handleProjectionChanged_","handleTrackingChanged_","setProjection","setTrackingOptions","tracking","disposeInternal","getTransformFromProjections","set","navigator","getTracking","watchPosition","positionChange_","bind","positionError_","getTrackingOptions","clearWatch","position","coords","toRadians","longitude","latitude","projectedPosition","slice","geometry","circularPolygon","applyTransform","changed","dispatchEvent","get"],"sourceRoot":""}