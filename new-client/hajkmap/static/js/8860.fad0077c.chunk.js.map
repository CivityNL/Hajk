{"version":3,"file":"static/js/8860.fad0077c.chunk.js","mappings":"mUAiBIA,EAAQ,SAAUC,GACpB,MAAI,KAAKC,KAAKD,GAAaA,EAEzB,IACAA,EACGE,MAAM,gBACNC,OAAO,EAAG,GACVC,KAAKC,IACJ,IAAIC,EAAIC,SAASF,EAAG,IAAIG,SAAS,IAIjC,OAHID,SAASF,GAAK,KAChBC,EAAI,IAAMA,GAELA,CAAP,IAEDG,KAAK,GAEX,EAohBD,UA9gBA,MACEC,YAAYC,GACVC,KAAKR,IAAMO,EAASP,IACpBQ,KAAKC,IAAMF,EAASE,IACpBD,KAAKE,cAAgBH,EAASG,cAC9BF,KAAKG,UAAYJ,EAASK,QAAQD,UAClCH,KAAKK,OAASL,KAAKM,eAAeP,EAASK,QAAQC,QACnDL,KAAKO,UAAY,uCACjBP,KAAKQ,WAAY,EACjBR,KAAKS,YAAc,GACnBT,KAAKU,iBACN,CAEDJ,eAAeK,GACb,MAAgB,iBAALA,GAAiB,kBAAkBtB,KAAKsB,GAC1CA,EAAEC,MAAM,KAAKpB,KAAKmB,GAAME,OAAOF,KAE/B,CAAC,IAAK,IAAK,IAAM,KAAM,IAAM,IAAO,KAAO,IAAO,IAAQ,KAEpE,CAEDD,kBACEV,KAAKc,aAAe,IAAIC,EAAAA,EAAO,CAC7BC,OAAQ,IAAIC,EAAAA,EACZC,UAAW,SACXC,OAAQ,IACRC,KAAM,eACNC,QAAS,gBACTC,MAAO,IAAIC,EAAAA,GAAM,CACfC,OAAQ,IAAIC,EAAAA,EAAO,CACjBC,MAAO,qBACPC,MAAO,IAETC,KAAM,IAAIC,EAAAA,EAAK,CACbH,MAAO,gCAIb1B,KAAKR,IAAIsC,SAAS9B,KAAKc,aACxB,CAEDiB,gBACE/B,KAAKgC,oBAAiBC,EACtBjC,KAAKc,aAAaoB,YAAYC,QAC9BnC,KAAKR,IAAI4C,kBAAkBpC,KAAKqC,UACjC,CAEDC,oBACE,OAAOtC,KAAKgC,cACb,CAEDO,mBACE,IAAIC,EAASxC,KAAKsC,oBAAoBG,cAAcC,YACpD,OAAOC,EAAAA,EAAAA,WAAUH,EAClB,CAEDI,WAAWC,EAAOC,EAAOC,GACvB,IAAIC,EAAM,KAAO,IAGfC,EAAOH,EAAMnB,MAAQqB,EAFf,MAE4BH,EAAS,EADtC,EAELK,EAAOJ,EAAMK,OAASH,EAHhB,MAG6BH,EAAS,EAFvC,EAGLO,EAAS,CACP,CACE,CAACL,EAAO,GAAKE,EAAGF,EAAO,GAAKG,GAC5B,CAACH,EAAO,GAAKE,EAAGF,EAAO,GAAKG,GAC5B,CAACH,EAAO,GAAKE,EAAGF,EAAO,GAAKG,GAC5B,CAACH,EAAO,GAAKE,EAAGF,EAAO,GAAKG,GAC5B,CAACH,EAAO,GAAKE,EAAGF,EAAO,GAAKG,KAGhCG,EAAU,IAAIC,EAAAA,EAAQ,CACpBC,SAAU,IAAIC,EAAAA,GAAQJ,KAG1BpD,KAAK+B,gBACL/B,KAAKgC,eAAiBqB,EACtBrD,KAAKc,aAAaoB,YAAYuB,WAAWJ,GACzCrD,KAAKqC,UAAY,IAAIqB,EAAAA,EAAU,CAC7BC,SAAU,IAAIC,EAAAA,EAAW,CAACP,MAE5BrD,KAAKR,IAAIqE,eAAe7D,KAAKqC,UAC9B,CAEDyB,UAWE,OAAO9D,KAAKR,IACTuE,YACAC,WACAC,QATiBC,IACjBA,aAAiBC,EAAAA,GAAQD,aAAiBE,EAAAA,KAC1CF,EAAMhC,sBAAuBmC,EAAAA,GAC5BH,EAAMhC,sBAAuBoC,EAAAA,IAC/BJ,EAAMK,eAML/E,KAAI,CAAC0E,EAAOzE,KAEX,MAAM+E,EAC4C,kBAAzCN,EAAMhC,YAAYuC,YAAYC,OACjCR,EAAMhC,YAAYuC,YAAYC,OAAO9D,MAAM,KAC3CsD,EAAMhC,YAAYuC,YAAYC,OACpC,MAAO,CACLC,IAAKT,EAAMhC,YAAY0C,IAAI,OAC3BJ,OAAQA,EACRrD,OAAQ1B,EACRoF,gBAAiB,KACjBC,mBAAoB9E,KAAKR,IACtBuF,UACAC,gBACAC,UACArE,MAAM,KAAK,GAThB,GAYL,CAEDsE,aACE,SAASC,EAAeC,GACtB,IAAIC,EAAMD,EAAExF,SAAS,IACrB,OAAsB,IAAfyF,EAAIC,OAAe,IAAMD,EAAMA,CACvC,CAED,SAASE,EAASC,GAChB,MAAMC,EAAU,4CAA4CC,KAC1DF,GAEF,GAAgB,OAAZC,EAAkB,CACpB,IAAIE,EAAIhG,SAAS8F,EAAQ,IACrBG,EAAIjG,SAAS8F,EAAQ,IACrBI,EAAIlG,SAAS8F,EAAQ,IAEzB,OADQ9F,SAAS8F,EAAQ,IAErB,KACA,IAAMN,EAAeQ,GAAKR,EAAeS,GAAKT,EAAeU,EAClE,CACC,OAAO,IAEV,CAED,SAASC,EAASxE,GAChB,SAASyE,EAAaC,GACpB,IAAIC,EAAcD,EAAQnG,KAAK,MAE/B,OADU0F,EAAS,QAAD,OAASU,EAAT,KAEnB,CAED,IAAK3E,EAAO,OAAO,KAEf4E,MAAMC,QAAQ7E,KACK,IAAjBA,EAAMgE,SACRhE,EAAQA,EAAM,IAEK,IAAjBA,EAAMgE,SACRhE,EAAQA,EAAM,KAIlB,IApKoBlC,EAoKhBgH,EAAY,UACdC,EAAc,GACdC,EAAc,UAEdC,EAAc,EACdC,EAAgB,QAChBC,EAAkB,QAClBC,EAAc,GACdC,EAAiB,UACjBC,EAAW,GAIXC,EAAW,KACXC,EAAY,UACZC,EAAgB,UAuFlB,OApFEzF,EAAM0F,SACN1F,EAAM0F,WACN1F,EAAM0F,UAAUC,SAChB3F,EAAM0F,UAAUC,YAEhBJ,EAAWvF,EAAM0F,UAAUC,UAAU3H,MAAM,OAAO,IAIlDgC,EAAM0F,SACN1F,EAAM0F,WACN1F,EAAM0F,UAAUE,SAChB5F,EAAM0F,UAAUE,YAEoC,kBAAzC5F,EAAM0F,UAAUE,UAAUC,WACnCL,EAAYxF,EAAM0F,UAAUE,UAAUC,WAC7BjB,MAAMC,QAAQ7E,EAAM0F,UAAUE,UAAUC,cACjDL,EAAYf,EAAazE,EAAM0F,UAAUE,UAAUC,cAKrD7F,EAAM0F,SACN1F,EAAM0F,WACN1F,EAAM0F,UAAUI,WAChB9F,EAAM0F,UAAUI,cAEoC,kBAAzC9F,EAAM0F,UAAUE,UAAUC,WACnCJ,EAAgBzF,EAAM0F,UAAUI,YAAYD,WACnCjB,MAAMC,QAAQ7E,EAAM0F,UAAUI,YAAYD,cACnDJ,EAAgBhB,EAAazE,EAAM0F,UAAUI,YAAYD,cAIzDL,GAAa,OAAOzH,KAAKyH,KAC3BA,EAAYvB,EAASuB,IAGnBC,IAEAA,EADE,SAAS1H,KAAK0H,GACAxB,EAASwB,GAET,MAIhBzF,EAAM4F,SAAW5F,EAAM4F,WAAa5F,EAAM4F,UAAUC,aAClDhI,EAAMmC,EAAM4F,UAAUC,aACxBf,EAAYjH,EAAMmC,EAAM4F,UAAUC,YAtOlB/H,EAuOQkC,EAAM4F,UAAUC,WAAxCd,EAtODgB,WAAWjI,EAAIE,MAAM,gBAAgBC,OAAO,EAAG,GAAG,KAuOxC2G,MAAMC,QAAQ7E,EAAM4F,UAAUC,cACvCf,EAAYL,EAAazE,EAAM4F,UAAUC,YACzCd,EAAc/E,EAAM4F,UAAUC,WAC5B7F,EAAM4F,UAAUC,WAAW7B,OAAS,KAKtChE,EAAM4F,SAAW5F,EAAM8F,cACrBjI,EAAMmC,EAAM8F,YAAYD,YAC1Bb,EAAcnH,EAAMmC,EAAM8F,YAAYD,YAC7BjB,MAAMC,QAAQ7E,EAAM8F,YAAYD,cACzCb,EAAcP,EAAazE,EAAM8F,YAAYD,aAG/CZ,EAAcjF,EAAM8F,YAAYE,YAAc,EAC9Cd,EAAgBlF,EAAM8F,YAAYG,cAAgB,QAClDd,EAAkBnF,EAAM8F,YAAYI,cACO,KAAvClG,EAAM8F,YAAYI,cAAc,GAC9B,OACA,MACF,SAGFlG,EAAMmG,UAAYnG,EAAMmG,aACtBnG,EAAMmG,qBAAsBC,EAAAA,IAC9Bd,EAAWtF,EAAMmG,WAAWE,UAE1BrG,EAAMmG,qBAAsBG,EAAAA,IAC9BlB,EAAcpF,EAAMmG,WAAWI,YAC/BlB,EAAiBxH,EAAMmC,EAAMmG,WAAWP,UAAUC,cAI/C,CACLf,UAAWA,EACXC,YAAaA,EACbC,YAAaA,EACbwB,cAvGgB,EAwGhBvB,YAAaA,EACbC,cAAeA,EACfC,gBAAiBA,EACjBC,YAAaA,EACbC,eAAgBA,EAChBC,SAAUA,EACVmB,WAvGa,KAwGbC,kBAvGoB,QAwGpBC,kBAvGoB,EAwGpBpB,SAAUA,EACVC,UAAWA,EACXC,cAAeA,EAElB,CAED,SAASmB,EAAUC,EAAaC,GAC9B,OAAQA,GACN,IAAK,QACH,MAAO,CAACD,GACV,IAAK,aACH,OAAOA,EACT,IAAK,UACH,OAAOA,EAAY,GACrB,IAAK,eACH,OAAOA,EAAY,GAAG,GACxB,IAAK,SACH,MAAO,CAACA,EAAY,GAAIA,EAAY,IAIzC,CA8ED,IAGE3F,EAASxC,KAAKc,aACXoB,YACAmG,cAAc,GACd5F,cACAC,YAgBL,OAdS1C,KAAKR,IAAIuE,YAAYC,WAERC,QACnBC,GACCA,aAAiBnD,EAAAA,GACjBmD,EAAMK,cACgB,iBAAtBL,EAAMU,IAAI,UAIXpF,KAAK0E,GA/FR,SAAyBP,EAAUO,GACjC,SAAS8C,EAAQ3D,GACf,IAAIiF,EAAO,GAEX,OACEjF,EAAQkF,iBACyB,SAAjClF,EAAQkF,gBAAgBH,KAGtBE,EADEjF,EAAQkF,gBAAgBC,YACnBnF,EAAQkF,gBAAgBC,YACtBnF,EAAQkF,gBAAgBnH,KAC1BiC,EAAQkF,gBAAgBnH,KAExB,IAMTiC,EAAQoF,UACRvC,MAAMC,QAAQ9C,EAAQoF,aACtBpF,EAAQoF,WAAW,IACnBpF,EAAQoF,WAAW,GAAGzB,WACtB3D,EAAQoF,WAAW,GAAGzB,UAAUA,YAEhCsB,EAAOjF,EAAQoF,WAAW,GAAGzB,UAAUA,WAIvC3D,EAAQoF,UACRpF,EAAQoF,YACRpF,EAAQoF,WAAWzB,SACnB3D,EAAQoF,WAAWzB,YAEnBsB,EAAOjF,EAAQoF,WAAWzB,UAAUA,WAG/BsB,EACR,CAED,MAAO,CACL3E,SAAUA,EAASnE,KAAK6D,IACtB,IAGED,EAHEgF,EAAO/E,EAAQZ,cAAciG,UAC/BC,EAAOtF,EAAQZ,cACfmG,EAAQ,KAGV,IAAKvF,EAAQoF,YAAcvE,EAAO,CAChC,IAAI2E,EAAa3E,EAAMuE,UAANvE,CAAiBb,GAAS,GAC3CA,EAAQyF,SAASD,EAClB,CAaD,OAXAzF,EACW,WAATgF,EACIF,EAAU,CAACS,EAAKhG,YAAa,CAACgG,EAAKd,YAAa,IAAK,UACrDK,EAAUS,EAAKI,iBAAkBX,GAE1B,iBAATA,IACFQ,EAAQD,EACLI,iBAAiB,GACjBC,MAAM,EAAGL,EAAKI,iBAAiB,GAAGzD,SAGhC,CACL8C,KAAMA,EACNa,WAAY,CACVX,KAAMtB,EAAQ3D,GACd/B,MAAOwE,EAASzC,EAAQoF,aAE1BN,YAAa/E,EACbwF,MAAOA,EAPT,IAWL,CAsBGM,CAAgBhF,EAAMhC,YAAYiH,oBAAoB3G,GAAS0B,KAEhED,QAAQC,GAAUA,EAAMP,SAAS2B,OAAS,GAE9C,CAED8D,WAEE,OADapJ,KAAKR,IAAIuE,YAAYC,WAE/BC,QACEC,GAAUA,EAAMhC,sBAAuBmH,EAAAA,GAAQnF,EAAMK,eAEvD/E,KAAK0E,IACJ,IAAIvD,EAAIuD,EAAMhC,YACd,MAAO,CACLyC,IAAKuB,MAAMC,QAAQxF,EAAE2I,WAAa3I,EAAE2I,UAAU,GAAK3I,EAAEiE,IAAI,OACzD2E,SAAU,UAFZ,GAKL,CAEDC,aAoCE,OAAOxJ,KAAKR,IACTuE,YACAC,WACAC,QAPH,SAA4BC,GAC1B,OAAOA,EAAMhC,sBAAuBuH,EAAAA,GAAkBvF,EAAMK,YAC7D,IAME/E,KAvCH,SAAgC0E,GAC9B,IAAIS,EAAMT,EAAMhC,YAAY0C,IAAI,OAC9BpC,EAAS0B,EAAMU,IAAI,WAAa,GAChCJ,EAAS,GACTkF,EAAaxF,EAAMU,IAAI,cAczB,MAZ+D,kBAApDV,EAAMhC,YAAYuC,UAAU,UAA5B,SACTD,EAASN,EACNhC,YACAuC,UAAU,UACVC,OAAOiF,QAAQ,QAAS,IACxB/I,MAAM,MAGe,kBAAf8I,IACTA,EAAaA,EAAWC,QAAQ,QAAS,KAGpC,CACLhF,IAAKA,EACLH,OAAQA,EACRoF,iBAAkBF,EAClBlH,OAAQ,CACNqH,KAAMrH,EAAO,GACbsH,OAAQtH,EAAO,GACfuH,MAAOvH,EAAO,GACdwH,IAAKxH,EAAO,IAGjB,GAWF,CAEDyH,UAAU7J,EAAS8J,GACjB,IAAI1H,EAASxC,KAAKc,aACboB,YACAmG,cAAc,GACd5F,cACAC,YACHmH,EAAOrH,EAAO,GACduH,EAAQvH,EAAO,GACfsH,EAAStH,EAAO,GAChBwH,EAAMxH,EAAO,GACbmC,EAAM3E,KAAKG,UACXgK,EAAO,CACLC,UAAW,GACXC,aAAc,GACdC,KAAM,KACNC,WAAYnK,EAAQmK,WACpBC,KAAM,MAGVL,EAAKE,aAAerK,KAAKkF,cAAgB,GACzCiF,EAAKC,UAAYpK,KAAK8D,WAAa,GACnCqG,EAAKM,WAAazK,KAAKoJ,YAAc,GACrCe,EAAKO,aAAe1K,KAAKwJ,cAAgB,GAEzCW,EAAKG,KAAO,CACV3K,SAASS,EAAQkK,KAAK3I,MAAQvB,EAAQmK,YACtC5K,SAASS,EAAQkK,KAAKnH,OAAS/C,EAAQmK,aAGzCJ,EAAKK,KAAO,CAACX,EAAME,EAAOD,EAAQE,GAClCG,EAAKQ,YAAcvK,EAAQuK,YAC3BR,EAAKS,OAASxK,EAAQwK,OACtBT,EAAKtH,MAAQzC,EAAQyC,OAErBgI,EAAAA,EAAAA,QAAOlG,EAAK,CACVmG,OAAQ,OACRC,YAAa,cACbC,QAAS,CACP,eAAgB,oBAElBC,KAAMC,KAAKC,UAAU,CACnBhB,KAAMe,KAAKC,UAAUhB,OAGtBiB,MAAMC,IACLA,EAAS/C,OAAO8C,MAAME,IAChBpB,GACFA,EAASoB,EACV,GAHH,IAMDC,OAAOC,IACNC,MAAM,uCAAyCD,GAC/CE,QAAQF,MAAMA,EAAd,GAEL,CAEDG,kBAAkB3I,EAAKuH,GAErB,OAAOA,EAAavH,EADC,KAEtB,CAED4I,SACE,OAAO5L,KAAKR,GACb,E","sources":["plugins/Export/ExportModel.js"],"sourcesContent":["import Vector from \"ol/layer/Vector.js\";\nimport VectorSource from \"ol/source/Vector.js\";\nimport { Style, Stroke, Fill, Icon, Circle } from \"ol/style.js\";\nimport { getCenter } from \"ol/extent.js\";\nimport Polygon from \"ol/geom/Polygon\";\nimport Feature from \"ol/Feature.js\";\nimport Tile from \"ol/layer/Tile\";\nimport Image from \"ol/layer/Image\";\nimport TileWMS from \"ol/source/TileWMS\";\nimport ImageWMS from \"ol/source/ImageWMS\";\n//import ImageVector from \"ol/source/ImageVector\";\nimport { Translate } from \"ol/interaction.js\";\nimport WMTS from \"ol/source/WMTS\";\nimport TileArcGISRest from \"ol/source/TileArcGISRest\";\nimport Collection from \"ol/Collection\";\nimport { hfetch } from \"utils/FetchWrapper\";\n\nvar toHex = function (str) {\n  if (/^#/.test(str)) return str;\n  var hex =\n    \"#\" +\n    str\n      .match(/\\d+(\\.\\d+)?/g)\n      .splice(0, 3)\n      .map((i) => {\n        var v = parseInt(i, 10).toString(16);\n        if (parseInt(i) < 16) {\n          v = \"0\" + v;\n        }\n        return v;\n      })\n      .join(\"\");\n  return hex;\n};\n\nvar toOpacity = function (str) {\n  return parseFloat(str.match(/\\d+(\\.\\d+)?/g).splice(3, 1)[0]);\n};\n\nclass ExportModel {\n  constructor(settings) {\n    this.map = settings.map;\n    this.app = settings.app;\n    this.localObserver = settings.localObserver;\n    this.exportUrl = settings.options.exportUrl;\n    this.scales = this.validateScales(settings.options.scales);\n    this.copyright = \"© Lantmäteriverket i2009/00858\";\n    this.autoScale = false;\n    this.instruction = \"\";\n    this.addPreviewLayer();\n  }\n\n  validateScales(s) {\n    if (typeof s == \"string\" && /(\\d+)(,\\s*\\d+)*/.test(s)) {\n      return s.split(\",\").map((s) => Number(s));\n    } else {\n      return [250, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000];\n    }\n  }\n\n  addPreviewLayer() {\n    this.previewLayer = new Vector({\n      source: new VectorSource(),\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginExport\",\n      caption: \"Export plugin\",\n      style: new Style({\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.7)\",\n          width: 2,\n        }),\n        fill: new Fill({\n          color: \"rgba(255, 145, 20, 0.4)\",\n        }),\n      }),\n    });\n    this.map.addLayer(this.previewLayer);\n  }\n\n  removePreview() {\n    this.previewFeature = undefined;\n    this.previewLayer.getSource().clear();\n    this.map.removeInteraction(this.translate);\n  }\n\n  getPreviewFeature() {\n    return this.previewFeature;\n  }\n\n  getPreviewCenter() {\n    var extent = this.getPreviewFeature().getGeometry().getExtent();\n    return getCenter(extent);\n  }\n\n  addPreview(scale, paper, center) {\n    var dpi = 25.4 / 0.28,\n      ipu = 39.37,\n      sf = 1,\n      w = (((paper.width / dpi / ipu) * scale) / 2) * sf,\n      y = (((paper.height / dpi / ipu) * scale) / 2) * sf,\n      coords = [\n        [\n          [center[0] - w, center[1] - y],\n          [center[0] - w, center[1] + y],\n          [center[0] + w, center[1] + y],\n          [center[0] + w, center[1] - y],\n          [center[0] - w, center[1] - y],\n        ],\n      ],\n      feature = new Feature({\n        geometry: new Polygon(coords),\n      });\n\n    this.removePreview();\n    this.previewFeature = feature;\n    this.previewLayer.getSource().addFeature(feature);\n    this.translate = new Translate({\n      features: new Collection([feature]),\n    });\n    this.map.addInteraction(this.translate);\n  }\n\n  findWMS() {\n    /**\n     * @summary Only allow export of layers according to some specific conditions.\n     * @param {object} layer\n     */\n    const exportable = (layer) =>\n      (layer instanceof Tile || layer instanceof Image) &&\n      (layer.getSource() instanceof TileWMS ||\n        layer.getSource() instanceof ImageWMS) &&\n      layer.getVisible();\n\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter(exportable)\n      .map((layer, i) => {\n        // Depending on type of LAYERS, either split the String or use Array directly.\n        const layers =\n          typeof layer.getSource().getParams().LAYERS === \"string\"\n            ? layer.getSource().getParams().LAYERS.split(\",\")\n            : layer.getSource().getParams().LAYERS;\n        return {\n          url: layer.getSource().get(\"url\"),\n          layers: layers,\n          zIndex: i,\n          workspacePrefix: null,\n          coordinateSystemId: this.map\n            .getView()\n            .getProjection()\n            .getCode()\n            .split(\":\")[1],\n        };\n      });\n  }\n\n  findVector() {\n    function componentToHex(c) {\n      var hex = c.toString(16);\n      return hex.length === 1 ? \"0\" + hex : hex;\n    }\n\n    function rgbToHex(rgbString) {\n      const matches = /rgb(a)?\\((\\d+), (\\d+), (\\d+)(, [\\d.]+)?\\)/.exec(\n        rgbString\n      );\n      if (matches !== null) {\n        let r = parseInt(matches[2]);\n        let g = parseInt(matches[3]);\n        let b = parseInt(matches[4]);\n        let a = parseInt(matches[5]);\n        return a\n          ? null\n          : \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n      } else {\n        return null;\n      }\n    }\n\n    function asObject(style) {\n      function olColorToHex(olColor) {\n        var colorString = olColor.join(\", \");\n        var hex = rgbToHex(`rgba(${colorString})`);\n        return hex;\n      }\n\n      if (!style) return null;\n\n      if (Array.isArray(style)) {\n        if (style.length === 2) {\n          style = style[1];\n        }\n        if (style.length === 1) {\n          style = style[0];\n        }\n      }\n\n      var fillColor = \"#FC345C\",\n        fillOpacity = 0.5,\n        strokeColor = \"#FC345C\",\n        strokeOpacity = 1,\n        strokeWidth = 3,\n        strokeLinecap = \"round\",\n        strokeDashstyle = \"solid\",\n        pointRadius = 10,\n        pointFillColor = \"#FC345C\",\n        pointSrc = \"\",\n        labelAlign = \"cm\",\n        labelOutlineColor = \"white\",\n        labelOutlineWidth = 3,\n        fontSize = \"16\",\n        fontColor = \"#FFFFFF\",\n        fontBackColor = \"#000000\";\n\n      if (\n        style.getText &&\n        style.getText() &&\n        style.getText().getFont &&\n        style.getText().getFont()\n      ) {\n        fontSize = style.getText().getFont().match(/\\d+/)[0];\n      }\n\n      if (\n        style.getText &&\n        style.getText() &&\n        style.getText().getFill &&\n        style.getText().getFill()\n      ) {\n        if (typeof style.getText().getFill().getColor() === \"string\") {\n          fontColor = style.getText().getFill().getColor();\n        } else if (Array.isArray(style.getText().getFill().getColor())) {\n          fontColor = olColorToHex(style.getText().getFill().getColor());\n        }\n      }\n\n      if (\n        style.getText &&\n        style.getText() &&\n        style.getText().getStroke &&\n        style.getText().getStroke()\n      ) {\n        if (typeof style.getText().getFill().getColor() === \"string\") {\n          fontBackColor = style.getText().getStroke().getColor();\n        } else if (Array.isArray(style.getText().getStroke().getColor())) {\n          fontBackColor = olColorToHex(style.getText().getStroke().getColor());\n        }\n      }\n\n      if (fontColor && /^rgb/.test(fontColor)) {\n        fontColor = rgbToHex(fontColor);\n      }\n\n      if (fontBackColor) {\n        if (/^rgb\\(/.test(fontBackColor)) {\n          fontBackColor = rgbToHex(fontBackColor);\n        } else {\n          fontBackColor = null;\n        }\n      }\n\n      if (style.getFill && style.getFill() && style.getFill().getColor()) {\n        if (toHex(style.getFill().getColor())) {\n          fillColor = toHex(style.getFill().getColor());\n          fillOpacity = toOpacity(style.getFill().getColor());\n        } else if (Array.isArray(style.getFill().getColor())) {\n          fillColor = olColorToHex(style.getFill().getColor());\n          fillOpacity = style.getFill().getColor()[\n            style.getFill().getColor().length - 1\n          ];\n        }\n      }\n\n      if (style.getFill && style.getStroke()) {\n        if (toHex(style.getStroke().getColor())) {\n          strokeColor = toHex(style.getStroke().getColor());\n        } else if (Array.isArray(style.getStroke().getColor())) {\n          strokeColor = olColorToHex(style.getStroke().getColor());\n        }\n\n        strokeWidth = style.getStroke().getWidth() || 3;\n        strokeLinecap = style.getStroke().getLineCap() || \"round\";\n        strokeDashstyle = style.getStroke().getLineDash()\n          ? style.getStroke().getLineDash()[0] === 12\n            ? \"dash\"\n            : \"dot\"\n          : \"solid\";\n      }\n\n      if (style.getImage && style.getImage()) {\n        if (style.getImage() instanceof Icon) {\n          pointSrc = style.getImage().getSrc();\n        }\n        if (style.getImage() instanceof Circle) {\n          pointRadius = style.getImage().getRadius();\n          pointFillColor = toHex(style.getImage().getFill().getColor());\n        }\n      }\n\n      return {\n        fillColor: fillColor,\n        fillOpacity: fillOpacity,\n        strokeColor: strokeColor,\n        strokeOpacity: strokeOpacity,\n        strokeWidth: strokeWidth,\n        strokeLinecap: strokeLinecap,\n        strokeDashstyle: strokeDashstyle,\n        pointRadius: pointRadius,\n        pointFillColor: pointFillColor,\n        pointSrc: pointSrc,\n        labelAlign: labelAlign,\n        labelOutlineColor: labelOutlineColor,\n        labelOutlineWidth: labelOutlineWidth,\n        fontSize: fontSize,\n        fontColor: fontColor,\n        fontBackColor: fontBackColor,\n      };\n    }\n\n    function as2DPairs(coordinates, type) {\n      switch (type) {\n        case \"Point\":\n          return [coordinates];\n        case \"LineString\":\n          return coordinates;\n        case \"Polygon\":\n          return coordinates[0];\n        case \"MultiPolygon\":\n          return coordinates[0][0];\n        case \"Circle\":\n          return [coordinates[0], coordinates[1]];\n        default:\n          break;\n      }\n    }\n\n    function translateVector(features, layer) {\n      function getText(feature) {\n        var text = \"\";\n\n        if (\n          feature.getProperties() &&\n          feature.getProperties().type === \"Text\"\n        ) {\n          if (feature.getProperties().description) {\n            text = feature.getProperties().description;\n          } else if (feature.getProperties().name) {\n            text = feature.getProperties().name;\n          } else {\n            text = \"\";\n          }\n          return text;\n        }\n\n        if (\n          feature.getStyle &&\n          Array.isArray(feature.getStyle()) &&\n          feature.getStyle()[1] &&\n          feature.getStyle()[1].getText() &&\n          feature.getStyle()[1].getText().getText()\n        ) {\n          text = feature.getStyle()[1].getText().getText();\n        }\n\n        if (\n          feature.getStyle &&\n          feature.getStyle() &&\n          feature.getStyle().getText &&\n          feature.getStyle().getText()\n        ) {\n          text = feature.getStyle().getText().getText();\n        }\n\n        return text;\n      }\n\n      return {\n        features: features.map((feature) => {\n          var type = feature.getGeometry().getType(),\n            geom = feature.getGeometry(),\n            holes = null,\n            coords;\n\n          if (!feature.getStyle() && layer) {\n            let layerStyle = layer.getStyle()(feature)[0];\n            feature.setStyle(layerStyle);\n          }\n\n          coords =\n            type === \"Circle\"\n              ? as2DPairs([geom.getCenter(), [geom.getRadius(), 0]], \"Circle\")\n              : as2DPairs(geom.getCoordinates(), type);\n\n          if (type === \"MultiPolygon\") {\n            holes = geom\n              .getCoordinates()[0]\n              .slice(1, geom.getCoordinates()[0].length);\n          }\n\n          return {\n            type: type,\n            attributes: {\n              text: getText(feature),\n              style: asObject(feature.getStyle()),\n            },\n            coordinates: coords,\n            holes: holes,\n          };\n        }),\n      };\n    }\n\n    var layers,\n      vectorLayers,\n      //imageVectorLayers,\n      extent = this.previewLayer\n        .getSource()\n        .getFeatures()[0]\n        .getGeometry()\n        .getExtent();\n\n    layers = this.map.getLayers().getArray();\n\n    vectorLayers = layers.filter(\n      (layer) =>\n        layer instanceof Vector &&\n        layer.getVisible() &&\n        layer.get(\"name\") !== \"pluginExport\"\n    );\n\n    vectorLayers = vectorLayers\n      .map((layer) =>\n        translateVector(layer.getSource().getFeaturesInExtent(extent), layer)\n      )\n      .filter((layer) => layer.features.length > 0);\n    return vectorLayers;\n  }\n\n  findWMTS() {\n    var layers = this.map.getLayers().getArray();\n    return layers\n      .filter(\n        (layer) => layer.getSource() instanceof WMTS && layer.getVisible()\n      )\n      .map((layer) => {\n        var s = layer.getSource();\n        return {\n          url: Array.isArray(s.getUrls()) ? s.getUrls()[0] : s.get(\"url\"),\n          axisMode: \"natural\",\n        };\n      });\n  }\n\n  findArcGIS() {\n    function getArcGISLayerContract(layer) {\n      var url = layer.getSource().get(\"url\"),\n        extent = layer.get(\"extent\") || [],\n        layers = [],\n        projection = layer.get(\"projection\");\n\n      if (typeof layer.getSource().getParams(\"params\")[\"LAYERS\"] === \"string\") {\n        layers = layer\n          .getSource()\n          .getParams(\"params\")\n          .LAYERS.replace(\"show:\", \"\")\n          .split(\",\");\n      }\n\n      if (typeof projection === \"string\") {\n        projection = projection.replace(\"EPSG:\", \"\");\n      }\n\n      return {\n        url: url,\n        layers: layers,\n        spatialReference: projection,\n        extent: {\n          left: extent[0],\n          bottom: extent[1],\n          right: extent[2],\n          top: extent[3],\n        },\n      };\n    }\n\n    function visibleArcGISLayer(layer) {\n      return layer.getSource() instanceof TileArcGISRest && layer.getVisible();\n    }\n\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter(visibleArcGISLayer)\n      .map(getArcGISLayerContract);\n  }\n\n  exportPDF(options, callback) {\n    var extent = this.previewLayer\n        .getSource()\n        .getFeatures()[0]\n        .getGeometry()\n        .getExtent(),\n      left = extent[0],\n      right = extent[2],\n      bottom = extent[1],\n      top = extent[3],\n      url = this.exportUrl,\n      data = {\n        wmsLayers: [],\n        vectorLayers: [],\n        size: null,\n        resolution: options.resolution,\n        bbox: null,\n      };\n\n    data.vectorLayers = this.findVector() || [];\n    data.wmsLayers = this.findWMS() || [];\n    data.wmtsLayers = this.findWMTS() || [];\n    data.arcgisLayers = this.findArcGIS() || [];\n\n    data.size = [\n      parseInt(options.size.width * options.resolution),\n      parseInt(options.size.height * options.resolution),\n    ];\n\n    data.bbox = [left, right, bottom, top];\n    data.orientation = options.orientation;\n    data.format = options.format;\n    data.scale = options.scale;\n\n    hfetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        data: JSON.stringify(data),\n      }),\n    })\n      .then((response) => {\n        response.text().then((fileUrl) => {\n          if (callback) {\n            callback(fileUrl);\n          }\n        });\n      })\n      .catch((error) => {\n        alert(\"Det gick inte att exportera kartan. \" + error);\n        console.error(error);\n      });\n  }\n\n  resolutionToScale(dpi, resolution) {\n    var inchesPerMeter = 39.37;\n    return resolution * dpi * inchesPerMeter;\n  }\n\n  getMap() {\n    return this.map;\n  }\n}\n\nexport default ExportModel;\n"],"names":["toHex","str","test","match","splice","map","i","v","parseInt","toString","join","constructor","settings","this","app","localObserver","exportUrl","options","scales","validateScales","copyright","autoScale","instruction","addPreviewLayer","s","split","Number","previewLayer","Vector","source","VectorSource","layerType","zIndex","name","caption","style","Style","stroke","Stroke","color","width","fill","Fill","addLayer","removePreview","previewFeature","undefined","getSource","clear","removeInteraction","translate","getPreviewFeature","getPreviewCenter","extent","getGeometry","getExtent","getCenter","addPreview","scale","paper","center","dpi","w","y","height","coords","feature","Feature","geometry","Polygon","addFeature","Translate","features","Collection","addInteraction","findWMS","getLayers","getArray","filter","layer","Tile","Image","TileWMS","ImageWMS","getVisible","layers","getParams","LAYERS","url","get","workspacePrefix","coordinateSystemId","getView","getProjection","getCode","findVector","componentToHex","c","hex","length","rgbToHex","rgbString","matches","exec","r","g","b","asObject","olColorToHex","olColor","colorString","Array","isArray","fillColor","fillOpacity","strokeColor","strokeWidth","strokeLinecap","strokeDashstyle","pointRadius","pointFillColor","pointSrc","fontSize","fontColor","fontBackColor","getText","getFont","getFill","getColor","getStroke","parseFloat","getWidth","getLineCap","getLineDash","getImage","Icon","getSrc","Circle","getRadius","strokeOpacity","labelAlign","labelOutlineColor","labelOutlineWidth","as2DPairs","coordinates","type","getFeatures","text","getProperties","description","getStyle","getType","geom","holes","layerStyle","setStyle","getCoordinates","slice","attributes","translateVector","getFeaturesInExtent","findWMTS","WMTS","getUrls","axisMode","findArcGIS","TileArcGISRest","projection","replace","spatialReference","left","bottom","right","top","exportPDF","callback","data","wmsLayers","vectorLayers","size","resolution","bbox","wmtsLayers","arcgisLayers","orientation","format","hfetch","method","credentials","headers","body","JSON","stringify","then","response","fileUrl","catch","error","alert","console","resolutionToScale","getMap"],"sourceRoot":""}