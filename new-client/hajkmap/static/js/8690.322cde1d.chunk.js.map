{"version":3,"file":"static/js/8690.322cde1d.chunk.js","mappings":"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","sources":["../node_modules/ol/interaction/Modify.js","../node_modules/ol/interaction/Select.js","../node_modules/ol/interaction/Translate.js"],"sourcesContent":["/**\n * @module ol/interaction/Modify\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  altKeyOnly,\n  always,\n  primaryAction,\n  singleClick,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  buffer as bufferExtent,\n  createOrUpdateFromCoordinate as createExtent,\n} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  equals as coordinatesEqual,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {equals} from '../array.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\n\n/**\n * The segment index assigned to a circle's center when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CENTER_INDEX = 0;\n\n/**\n * The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\nconst tempExtent = [0, 0, 0, 0];\nconst tempSegment = [];\n\n/**\n * @enum {string}\n */\nconst ModifyEventType = {\n  /**\n   * Triggered upon feature modification start\n   * @event ModifyEvent#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ModifyEvent#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend',\n};\n\n/**\n * @typedef {Object} SegmentData\n * @property {Array<number>} [depth] Depth.\n * @property {Feature} feature Feature.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} [index] Index.\n * @property {Array<Array<number>>} segment Segment.\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event will be considered to add or move a\n * vertex to the sketch. Default is\n * {@link module:ol/events/condition.primaryAction}.\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. By default,\n * {@link module:ol/events/condition.singleClick} with\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\n * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether a new vertex should be added to the sketch\n * features. Default is {@link module:ol/events/condition.always}.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style used for the modification point or vertex. For linestrings and polygons, this will\n * be the affected vertex, for circles a point along the circle, and for points the actual\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\n * When using a style function, the point feature passed to the function will have a `features`\n * property - an array whose entries are the features that are being modified, and a `geometries`\n * property - an array whose entries are the geometries that are being modified. Both arrays are\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\n * the geometry will be the particular geometry from the collection that is being modified.\n * @property {VectorSource} [source] The vector source with\n * features to modify.  If a vector source is not provided, a feature collection\n * must be provided with the `features` option.\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\n * features will be considered for modification based on their visual appearance, instead of being within\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\n * provided, only the rendered representation of the features on that layer will be considered.\n * @property {Collection<Feature>} [features]\n * The features the interaction works on.  If a feature collection is not\n * provided, a vector source must be provided with the `source` option.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\n * pointer coordinate when clicked within the `pixelTolerance`.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\n * instances of this type.\n */\nexport class ModifyEvent extends Event {\n  /**\n   * @param {ModifyEventType} type Type.\n   * @param {Collection<Feature>} features\n   * The features modified.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, features, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being modified.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * Cartesian distance from the pointer is used to determine the features that\n * will be modified. This means that geometries will only be considered for\n * modification when they are within the configured `pixelTolerance`. For point\n * geometries, the `hitDetection` option can be used to match their visual\n * appearance.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n * @fires ModifyEvent\n * @api\n */\nclass Modify extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ModifyOnSignature<void>}\n     */\n    this.un;\n\n    /** @private */\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : primaryAction;\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n    };\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.deleteCondition_ = options.deleteCondition\n      ? options.deleteCondition\n      : this.defaultDeleteCondition_;\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.insertVertexCondition_ = options.insertVertexCondition\n      ? options.insertVertexCondition\n      : always;\n\n    /**\n     * Editing vertex.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    /**\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.vertexSegments_ = null;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.lastPixel_ = [0, 0];\n\n    /**\n     * Tracks if the next `singleclick` event should be ignored to prevent\n     * accidental deletion right after vertex creation.\n     * @type {boolean}\n     * @private\n     */\n    this.ignoreNextSingleClick_ = false;\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.featuresBeingModified_ = null;\n\n    /**\n     * Segment RTree for each layer\n     * @type {RBush<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Indicate whether the interaction is currently changing a feature's\n     * coordinates.\n     * @type {boolean}\n     * @private\n     */\n    this.changingFeature_ = false;\n\n    /**\n     * @type {Array}\n     * @private\n     */\n    this.dragSegments_ = [];\n\n    /**\n     * Draw overlay where sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * @const\n     * @private\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_.bind(this),\n      'LineString': this.writeLineStringGeometry_.bind(this),\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\n      'Polygon': this.writePolygonGeometry_.bind(this),\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\n      'Circle': this.writeCircleGeometry_.bind(this),\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\n    };\n\n    /**\n     * @type {VectorSource}\n     * @private\n     */\n    this.source_ = null;\n\n    /**\n     * @type {boolean|import(\"../layer/BaseVector\").default}\n     */\n    this.hitDetection_ = null;\n\n    /** @type {Collection<Feature>} */\n    let features;\n    if (options.features) {\n      features = options.features;\n    } else if (options.source) {\n      this.source_ = options.source;\n      features = new Collection(this.source_.getFeatures());\n      this.source_.addEventListener(\n        VectorEventType.ADDFEATURE,\n        this.handleSourceAdd_.bind(this)\n      );\n      this.source_.addEventListener(\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceRemove_.bind(this)\n      );\n    }\n    if (!features) {\n      throw new Error(\n        'The modify interaction requires features, a source or a layer'\n      );\n    }\n    if (options.hitDetection) {\n      this.hitDetection_ = options.hitDetection;\n    }\n\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.features_ = features;\n\n    this.features_.forEach(this.addFeature_.bind(this));\n    this.features_.addEventListener(\n      CollectionEventType.ADD,\n      this.handleFeatureAdd_.bind(this)\n    );\n    this.features_.addEventListener(\n      CollectionEventType.REMOVE,\n      this.handleFeatureRemove_.bind(this)\n    );\n\n    /**\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @private\n     */\n    this.lastPointerEvent_ = null;\n\n    /**\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\n     * @type {Array<number>}\n     */\n    this.delta_ = [0, 0];\n\n    /**\n     * @private\n     */\n    this.snapToPointer_ =\n      options.snapToPointer === undefined\n        ? !this.hitDetection_\n        : options.snapToPointer;\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  addFeature_(feature) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (writer) {\n        writer(feature, geometry);\n      }\n    }\n    const map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.\n   * @private\n   */\n  willModifyFeatures_(evt, segments) {\n    if (!this.featuresBeingModified_) {\n      this.featuresBeingModified_ = new Collection();\n      const features = this.featuresBeingModified_.getArray();\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\n        const segment = segments[i];\n        for (let s = 0, ss = segment.length; s < ss; ++s) {\n          const feature = segment[s].feature;\n          if (feature && !features.includes(feature)) {\n            this.featuresBeingModified_.push(feature);\n          }\n        }\n      }\n      if (this.featuresBeingModified_.getLength() === 0) {\n        this.featuresBeingModified_ = null;\n      } else {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYSTART,\n            this.featuresBeingModified_,\n            evt\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeature_(feature) {\n    this.removeFeatureSegmentData_(feature);\n    // Remove the vertex feature if the collection of candidate features is empty.\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    feature.removeEventListener(\n      EventType.CHANGE,\n      this.boundHandleFeatureChange_\n    );\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureSegmentData_(feature) {\n    const rBush = this.rBush_;\n    /** @type {Array<SegmentData>} */\n    const nodesToRemove = [];\n    rBush.forEach(\n      /**\n       * @param {SegmentData} node RTree node.\n       */\n      function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      }\n    );\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n      const nodeToRemove = nodesToRemove[i];\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\n        if (this.dragSegments_[j][0] === nodeToRemove) {\n          this.dragSegments_.splice(j, 1);\n        }\n      }\n      rBush.remove(nodeToRemove);\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.overlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceAdd_(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceRemove_(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    this.addFeature_(evt.element);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    if (!this.changingFeature_) {\n      const feature = /** @type {Feature} */ (evt.target);\n      this.removeFeature_(feature);\n      this.addFeature_(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    this.removeFeature_(evt.element);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {Point} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n\n    /** @type {SegmentData} */\n    const segmentData = {\n      feature: feature,\n      geometry: geometry,\n      segment: [coordinates, coordinates],\n    };\n\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        depth: [i],\n        index: i,\n        segment: [coordinates, coordinates],\n      };\n\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        index: i,\n        segment: segment,\n      };\n\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n\n          /** @type {SegmentData} */\n          const segmentData = {\n            feature: feature,\n            geometry: geometry,\n            depth: [j, k],\n            index: i,\n            segment: segment,\n          };\n\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * We convert a circle into two segments.  The segment at index\n   * {@link CIRCLE_CENTER_INDEX} is the\n   * circle's center (a point).  The segment at index\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\n   * the circumference, and is not a line segment.\n   *\n   * @param {Feature} feature Feature.\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const coordinates = geometry.getCenter();\n\n    /** @type {SegmentData} */\n    const centerSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CENTER_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    /** @type {SegmentData} */\n    const circumferenceSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = featureSegments;\n    circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection && this.getMap()) {\n      const projection = this.getMap().getView().getProjection();\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n      circleGeometry = fromCircle(\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n      ).transform(projection, userProjection);\n    }\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i];\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      writer(feature, geometry);\n    }\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {Array<Feature>} features The features being modified.\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\n   * @return {Feature} Vertex feature.\n   * @private\n   */\n  createOrUpdateVertexFeature_(coordinates, features, geometries) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(coordinates));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(coordinates);\n    }\n    vertexFeature.set('features', features);\n    vertexFeature.set('geometries', geometries);\n    return vertexFeature;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n\n    let handled;\n    if (\n      !mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\n        !this.ignoreNextSingleClick_\n      ) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n\n    return super.handleEvent(mapBrowserEvent) && !handled;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   */\n  handleDragEvent(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(evt, this.dragSegments_);\n\n    const vertex = [\n      evt.coordinate[0] + this.delta_[0],\n      evt.coordinate[1] + this.delta_[1],\n    ];\n    const features = [];\n    const geometries = [];\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n      const dragSegment = this.dragSegments_[i];\n      const segmentData = dragSegment[0];\n      const feature = segmentData.feature;\n      if (!features.includes(feature)) {\n        features.push(feature);\n      }\n      const geometry = segmentData.geometry;\n      if (!geometries.includes(geometry)) {\n        geometries.push(geometry);\n      }\n      const depth = segmentData.depth;\n      let coordinates;\n      const segment = segmentData.segment;\n      const index = dragSegment[1];\n\n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index][vertex.length]);\n      }\n\n      switch (geometry.getType()) {\n        case 'Point':\n          coordinates = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'MultiPoint':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index] = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'LineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiLineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Polygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiPolygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Circle':\n          segment[0] = vertex;\n          segment[1] = vertex;\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            geometry.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else {\n            // We're dragging the circle's circumference:\n            this.changingFeature_ = true;\n            const projection = evt.map.getView().getProjection();\n            let radius = coordinateDistance(\n              fromUserCoordinate(geometry.getCenter(), projection),\n              fromUserCoordinate(vertex, projection)\n            );\n            const userProjection = getUserProjection();\n            if (userProjection) {\n              const circleGeometry = geometry\n                .clone()\n                .transform(userProjection, projection);\n              circleGeometry.setRadius(radius);\n              radius = circleGeometry\n                .transform(projection, userProjection)\n                .getRadius();\n            }\n            geometry.setRadius(radius);\n            this.changingFeature_ = false;\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (coordinates) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    const pixelCoordinate = evt.coordinate;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\n    this.dragSegments_.length = 0;\n    this.featuresBeingModified_ = null;\n    const vertexFeature = this.vertexFeature_;\n    if (vertexFeature) {\n      const projection = evt.map.getView().getProjection();\n      const insertVertices = [];\n      const vertex = vertexFeature.getGeometry().getCoordinates();\n      const vertexExtent = boundingExtent([vertex]);\n      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n      const componentSegments = {};\n      segmentDataMatches.sort(compareIndexes);\n      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n        const segmentDataMatch = segmentDataMatches[i];\n        const segment = segmentDataMatch.segment;\n        let uid = getUid(segmentDataMatch.geometry);\n        const depth = segmentDataMatch.depth;\n        if (depth) {\n          uid += '-' + depth.join('-'); // separate feature components\n        }\n        if (!componentSegments[uid]) {\n          componentSegments[uid] = new Array(2);\n        }\n\n        if (\n          segmentDataMatch.geometry.getType() === 'Circle' &&\n          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          const closestVertex = closestOnSegmentData(\n            pixelCoordinate,\n            segmentDataMatch,\n            projection\n          );\n          if (\n            coordinatesEqual(closestVertex, vertex) &&\n            !componentSegments[uid][0]\n          ) {\n            this.dragSegments_.push([segmentDataMatch, 0]);\n            componentSegments[uid][0] = segmentDataMatch;\n          }\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[0], vertex) &&\n          !componentSegments[uid][0]\n        ) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[1], vertex) &&\n          !componentSegments[uid][1]\n        ) {\n          if (\n            componentSegments[uid][0] &&\n            componentSegments[uid][0].index === 0\n          ) {\n            let coordinates = segmentDataMatch.geometry.getCoordinates();\n            switch (segmentDataMatch.geometry.getType()) {\n              // prevent dragging closed linestrings by the connecting node\n              case 'LineString':\n              case 'MultiLineString':\n                continue;\n              // if dragging the first vertex of a polygon, ensure the other segment\n              // belongs to the closing vertex of the linear ring\n              case 'MultiPolygon':\n                coordinates = coordinates[depth[1]];\n              /* falls through */\n              case 'Polygon':\n                if (\n                  segmentDataMatch.index !==\n                  coordinates[depth[0]].length - 2\n                ) {\n                  continue;\n                }\n                break;\n              default:\n              // pass\n            }\n          }\n\n          this.dragSegments_.push([segmentDataMatch, 1]);\n          componentSegments[uid][1] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          getUid(segment) in this.vertexSegments_ &&\n          !componentSegments[uid][0] &&\n          !componentSegments[uid][1] &&\n          this.insertVertexCondition_(evt)\n        ) {\n          insertVertices.push(segmentDataMatch);\n        }\n      }\n\n      if (insertVertices.length) {\n        this.willModifyFeatures_(evt, [insertVertices]);\n      }\n\n      for (let j = insertVertices.length - 1; j >= 0; --j) {\n        this.insertVertex_(insertVertices[j], vertex);\n      }\n    }\n    return !!this.vertexFeature_;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n      const segmentData = this.dragSegments_[i][0];\n      const geometry = segmentData.geometry;\n      if (geometry.getType() === 'Circle') {\n        // Update a circle object in the R* bush:\n        const coordinates = geometry.getCenter();\n        const centerSegmentData = segmentData.featureSegments[0];\n        const circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = coordinates;\n        centerSegmentData.segment[1] = coordinates;\n        circumferenceSegmentData.segment[0] = coordinates;\n        circumferenceSegmentData.segment[1] = coordinates;\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\n        let circleGeometry = geometry;\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          const projection = evt.map.getView().getProjection();\n          circleGeometry = circleGeometry\n            .clone()\n            .transform(userProjection, projection);\n          circleGeometry = fromCircle(circleGeometry).transform(\n            projection,\n            userProjection\n          );\n        }\n        this.rBush_.update(\n          circleGeometry.getExtent(),\n          circumferenceSegmentData\n        );\n      } else {\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n      }\n    }\n    if (this.featuresBeingModified_) {\n      this.dispatchEvent(\n        new ModifyEvent(\n          ModifyEventType.MODIFYEND,\n          this.featuresBeingModified_,\n          evt\n        )\n      );\n      this.featuresBeingModified_ = null;\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @private\n   */\n  handlePointerMove_(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../Map.js\").default} map Map.\n   * @param {import(\"../coordinate.js\").Coordinate} [coordinate] The pixel Coordinate.\n   * @private\n   */\n  handlePointerAtPixel_(pixel, map, coordinate) {\n    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);\n    const projection = map.getView().getProjection();\n    const sortByDistance = function (a, b) {\n      return (\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\n      );\n    };\n\n    /** @type {Array<SegmentData>|undefined} */\n    let nodes;\n    /** @type {Point|undefined} */\n    let hitPointGeometry;\n    if (this.hitDetection_) {\n      const layerFilter =\n        typeof this.hitDetection_ === 'object'\n          ? (layer) => layer === this.hitDetection_\n          : undefined;\n      map.forEachFeatureAtPixel(\n        pixel,\n        (feature, layer, geometry) => {\n          const geom = geometry || feature.getGeometry();\n          if (\n            geom.getType() === 'Point' &&\n            feature instanceof Feature &&\n            this.features_.getArray().includes(feature)\n          ) {\n            hitPointGeometry = /** @type {Point} */ (geom);\n            const coordinate = hitPointGeometry\n              .getFlatCoordinates()\n              .slice(0, 2);\n            nodes = [\n              {\n                feature,\n                geometry: hitPointGeometry,\n                segment: [coordinate, coordinate],\n              },\n            ];\n          }\n          return true;\n        },\n        {layerFilter}\n      );\n    }\n    if (!nodes) {\n      const viewExtent = fromUserExtent(\n        createExtent(pixelCoordinate, tempExtent),\n        projection\n      );\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\n      const box = toUserExtent(\n        bufferExtent(viewExtent, buffer, tempExtent),\n        projection\n      );\n      nodes = this.rBush_.getInExtent(box);\n    }\n\n    if (nodes && nodes.length > 0) {\n      const node = nodes.sort(sortByDistance)[0];\n      const closestSegment = node.segment;\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\n      let dist = coordinateDistance(pixel, vertexPixel);\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\n        /** @type {Object<string, boolean>} */\n        const vertexSegments = {};\n        vertexSegments[getUid(closestSegment)] = true;\n\n        if (!this.snapToPointer_) {\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\n        }\n        if (\n          node.geometry.getType() === 'Circle' &&\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry]\n          );\n        } else {\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          if (this.snappedToVertex_) {\n            vertex =\n              squaredDist1 > squaredDist2\n                ? closestSegment[1]\n                : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry]\n          );\n          const geometries = {};\n          geometries[getUid(node.geometry)] = true;\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\n            const segment = nodes[i].segment;\n            if (\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\n                coordinatesEqual(closestSegment[1], segment[1])) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n                coordinatesEqual(closestSegment[1], segment[0]))\n            ) {\n              const geometryUid = getUid(nodes[i].geometry);\n              if (!(geometryUid in geometries)) {\n                geometries[geometryUid] = true;\n                vertexSegments[getUid(segment)] = true;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  }\n\n  /**\n   * @param {SegmentData} segmentData Segment data.\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n   * @private\n   */\n  insertVertex_(segmentData, vertex) {\n    const segment = segmentData.segment;\n    const feature = segmentData.feature;\n    const geometry = segmentData.geometry;\n    const depth = segmentData.depth;\n    const index = segmentData.index;\n    let coordinates;\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n\n    switch (geometry.getType()) {\n      case 'MultiLineString':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'Polygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'MultiPolygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'LineString':\n        coordinates = geometry.getCoordinates();\n        coordinates.splice(index + 1, 0, vertex);\n        break;\n      default:\n        return;\n    }\n\n    this.setGeometryCoordinates_(geometry, coordinates);\n    const rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index, depth, 1);\n\n    /** @type {SegmentData} */\n    const newSegmentData = {\n      segment: [segment[0], vertex],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n\n    /** @type {SegmentData} */\n    const newSegmentData2 = {\n      segment: [vertex, segment[1]],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index + 1,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    this.ignoreNextSingleClick_ = true;\n  }\n\n  /**\n   * Removes the vertex currently being pointed.\n   * @return {boolean} True when a vertex was removed.\n   * @api\n   */\n  removePoint() {\n    if (\n      this.lastPointerEvent_ &&\n      this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG\n    ) {\n      const evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(evt, this.dragSegments_);\n      const removed = this.removeVertex_();\n      if (this.featuresBeingModified_) {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYEND,\n            this.featuresBeingModified_,\n            evt\n          )\n        );\n      }\n\n      this.featuresBeingModified_ = null;\n      return removed;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a vertex from all matching features.\n   * @return {boolean} True when a vertex was removed.\n   * @private\n   */\n  removeVertex_() {\n    const dragSegments = this.dragSegments_;\n    const segmentsByFeature = {};\n    let deleted = false;\n    let component, coordinates, dragSegment, geometry, i, index, left;\n    let newIndex, right, segmentData, uid;\n    for (i = dragSegments.length - 1; i >= 0; --i) {\n      dragSegment = dragSegments[i];\n      segmentData = dragSegment[0];\n      uid = getUid(segmentData.feature);\n      if (segmentData.depth) {\n        // separate feature components\n        uid += '-' + segmentData.depth.join('-');\n      }\n      if (!(uid in segmentsByFeature)) {\n        segmentsByFeature[uid] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid].right = segmentData;\n        segmentsByFeature[uid].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid].left = segmentData;\n        segmentsByFeature[uid].index = segmentData.index + 1;\n      }\n    }\n    for (uid in segmentsByFeature) {\n      right = segmentsByFeature[uid].right;\n      left = segmentsByFeature[uid].left;\n      index = segmentsByFeature[uid].index;\n      newIndex = index - 1;\n      if (left !== undefined) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates = geometry.getCoordinates();\n      component = coordinates;\n      deleted = false;\n      switch (geometry.getType()) {\n        case 'MultiLineString':\n          if (coordinates[segmentData.depth[0]].length > 2) {\n            coordinates[segmentData.depth[0]].splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'LineString':\n          if (coordinates.length > 2) {\n            coordinates.splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'MultiPolygon':\n          component = component[segmentData.depth[1]];\n        /* falls through */\n        case 'Polygon':\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index == component.length - 1) {\n              index = 0;\n            }\n            component.splice(index, 1);\n            deleted = true;\n            if (index === 0) {\n              // close the ring again\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n        const segments = [];\n        if (left !== undefined) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== undefined) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== undefined && right !== undefined) {\n          /** @type {SegmentData} */\n          const newSegmentData = {\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments,\n          };\n\n          this.rBush_.insert(\n            boundingExtent(newSegmentData.segment),\n            newSegmentData\n          );\n        }\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n    }\n    return deleted;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {Array} coordinates Coordinates.\n   * @private\n   */\n  setGeometryCoordinates_(geometry, coordinates) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates);\n    this.changingFeature_ = false;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {number} index Index.\n   * @param {Array<number>|undefined} depth Depth.\n   * @param {number} delta Delta (1 or -1).\n   * @private\n   */\n  updateSegmentIndices_(geometry, index, depth, delta) {\n    this.rBush_.forEachInExtent(\n      geometry.getExtent(),\n      function (segmentDataMatch) {\n        if (\n          segmentDataMatch.geometry === geometry &&\n          (depth === undefined ||\n            segmentDataMatch.depth === undefined ||\n            equals(segmentDataMatch.depth, depth)) &&\n          segmentDataMatch.index > index\n        ) {\n          segmentDataMatch.index += delta;\n        }\n      }\n    );\n  }\n}\n\n/**\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {SegmentData} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction projectedDistanceToSegmentDataSquared(\n  pointCoordinates,\n  segmentData,\n  projection\n) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === 'Circle') {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n          circleGeometry.clone().transform(userProjection, projection)\n        );\n      }\n      const distanceToCenterSquared = squaredCoordinateDistance(\n        circleGeometry.getCenter(),\n        fromUserCoordinate(pointCoordinates, projection)\n      );\n      const distanceToCircumference =\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return squaredDistanceToSegment(coordinate, tempSegment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {SegmentData} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\n  const geometry = segmentData.geometry;\n\n  if (\n    geometry.getType() === 'Circle' &&\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\n  ) {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    return toUserCoordinate(\n      circleGeometry.getClosestPoint(\n        fromUserCoordinate(pointCoordinates, projection)\n      ),\n      projection\n    );\n  }\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return toUserCoordinate(\n    closestOnSegment(coordinate, tempSegment),\n    projection\n  );\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\nexport default Modify;\n","/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent\n        )\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport {TRUE} from '../functions.js';\nimport {always} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(Feature, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<Feature>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.lastFeature_ = null;\n\n    this.addChangeListener(\n      InteractionProperty.ACTIVE,\n      this.handleActiveChanged_\n    );\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATESTART,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATEEND,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n\n      this.lastCoordinate_ = newCoordinate;\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATING,\n          features,\n          newCoordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {Feature} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(\n      pixel,\n      (feature, layer) => {\n        if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n          return undefined;\n        }\n        if (this.features_ && !this.features_.getArray().includes(feature)) {\n          return undefined;\n        }\n        return feature;\n      },\n      {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_,\n      }\n    );\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\n\nexport default Translate;\n"],"names":["tempExtent","tempSegment","ModifyEventType","ModifyEvent","Event","constructor","type","features","mapBrowserEvent","super","this","Modify","PointerInteraction","options","on","once","un","boundHandleFeatureChange_","handleFeatureChange_","bind","condition_","condition","primaryAction","defaultDeleteCondition_","altKeyOnly","singleClick","deleteCondition_","deleteCondition","insertVertexCondition_","insertVertexCondition","always","vertexFeature_","vertexSegments_","lastPixel_","ignoreNextSingleClick_","featuresBeingModified_","rBush_","RBush","pixelTolerance_","undefined","pixelTolerance","snappedToVertex_","changingFeature_","dragSegments_","overlay_","VectorLayer","source","VectorSource","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileAnimating","updateWhileInteracting","SEGMENT_WRITERS_","writePointGeometry_","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeCircleGeometry_","writeGeometryCollectionGeometry_","source_","hitDetection_","Collection","getFeatures","addEventListener","VectorEventType","handleSourceAdd_","handleSourceRemove_","Error","hitDetection","features_","forEach","addFeature_","CollectionEventType","handleFeatureAdd_","handleFeatureRemove_","lastPointerEvent_","delta_","snapToPointer_","snapToPointer","feature","geometry","getGeometry","writer","getType","map","getMap","isRendered","getActive","handlePointerAtPixel_","EventType","willModifyFeatures_","evt","segments","getArray","i","ii","length","segment","s","ss","includes","push","getLength","dispatchEvent","removeFeature_","removeFeatureSegmentData_","getSource","removeFeature","removeEventListener","rBush","nodesToRemove","node","nodeToRemove","j","splice","remove","setActive","active","setMap","getOverlay","event","element","target","coordinates","getCoordinates","segmentData","insert","getExtent","points","depth","index","slice","boundingExtent","lines","jj","rings","polygons","k","kk","getCenter","centerSegmentData","circumferenceSegmentData","featureSegments","createExtent","circleGeometry","userProjection","getUserProjection","projection","getView","getProjection","clone","transform","fromCircle","geometries","getGeometriesArray","createOrUpdateVertexFeature_","vertexFeature","setCoordinates","Feature","Point","addFeature","set","handleEvent","originalEvent","handled","getInteracting","MapBrowserEventType","handlingDownUpSequence","handlePointerMove_","removePoint","handleDragEvent","vertex","coordinate","dragSegment","getStride","setCenter","radius","coordinateDistance","fromUserCoordinate","setRadius","getRadius","setGeometryCoordinates_","handleDownEvent","pixelCoordinate","pixel","insertVertices","vertexExtent","segmentDataMatches","getInExtent","componentSegments","sort","compareIndexes","segmentDataMatch","uid","getUid","join","Array","coordinatesEqual","closestVertex","closestOnSegmentData","insertVertex_","handleUpEvent","update","getCoordinateFromPixel","sortByDistance","a","b","projectedDistanceToSegmentDataSquared","nodes","hitPointGeometry","layerFilter","layer","forEachFeatureAtPixel","geom","getFlatCoordinates","viewExtent","fromUserExtent","buffer","getResolution","box","toUserExtent","bufferExtent","closestSegment","vertexPixel","getPixelFromCoordinate","dist","vertexSegments","pixel1","pixel2","squaredDist1","squaredCoordinateDistance","squaredDist2","Math","sqrt","min","geometryUid","rTree","updateSegmentIndices_","newSegmentData","newSegmentData2","removed","removeVertex_","dragSegments","segmentsByFeature","component","left","newIndex","right","deleted","pop","delta","forEachInExtent","equals","pointCoordinates","distanceToCenterSquared","distanceToCircumference","squaredDistanceToSegment","toUserCoordinate","getClosestPoint","closestOnSegment","createEditingStyle","resolution","SelectEventType","SelectEvent","selected","deselected","originalFeatureStyles","Select","Interaction","boundAddFeature_","boundRemoveFeature_","addCondition_","addCondition","never","removeCondition_","removeCondition","toggleCondition_","toggleCondition","shiftKeyOnly","multi_","multi","filter_","filter","TRUE","hitTolerance_","hitTolerance","style_","styles","extend","layers","layerFilter_","featureLayerAssociation_","addFeatureLayerAssociation_","getHitTolerance","getLayer","setHitTolerance","restorePreviousStyle_","applySelectedStyle_","getAllLayers","find","hasFeature","getStyle","key","setStyle","interactions","getInteractions","interaction","lastIndexOf","removeFeatureLayerAssociation_","add","toggle","clear","item","indexOf","TranslateEventType","TranslateEvent","startCoordinate","Translate","lastCoordinate_","startCoordinate_","lastFeature_","addChangeListener","InteractionProperty","handleActiveChanged_","featuresAtPixel_","handleMoveEvent","newCoordinate","deltaX","deltaY","translate","setGeometry","elem","getViewport","classList","oldMap","updateState_"],"sourceRoot":""}