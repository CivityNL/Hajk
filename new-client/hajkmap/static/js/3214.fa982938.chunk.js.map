{"version":3,"file":"static/js/3214.fa982938.chunk.js","mappings":"mNAqDA,UA3CkB,IAAgB,IAAD,MAAd,MAAEA,GAAY,EAC/B,MAAMC,EAASD,EAAME,YACfC,EACyB,oBAArBF,EAAOG,YAAd,UACCH,EAAOG,mBADR,aACC,EAAoBC,aACtB,IAEKC,EAAWC,IAAgBC,EAAAA,EAAAA,UAASL,GAQ3C,OACE,iCACE,SAAC,IAAD,CAAYM,QAAQ,YAApB,8BACA,SAAC,IAAD,CACEC,GAAG,YACHC,KAAK,OACLC,WAAS,EACTC,WAAS,EACTC,YAAY,0BACZC,MAAOT,EACPU,SAAWC,GAAMV,EAAaU,EAAEC,OAAOH,OACvCI,cACE,SAAC,IAAD,CAAgBC,SAAS,MAAzB,UACE,SAAC,IAAD,CACEC,oBAAkB,EAClBC,MAAM,sDAFR,UAIE,SAAC,IAAD,CAAYC,KAAK,MAAMC,QAvBd,KACnB,IAAIC,EAASnB,EAAUoB,OACD,IAAlBD,EAAOE,SAAcF,OAASG,GAClC5B,EAAME,YAAY2B,aAAa,CAAExB,WAAYoB,GAA7C,EAoBwDK,KAAK,QAAnD,UACE,SAAC,IAAD,cAlBd,C,sECSF,UAxBA,YAAyE,IAAnD,MAAEC,EAAQ,EAAV,MAAa/B,EAAb,mBAAoBgC,GAAqB,GAAS,EACtE,MAAMC,EAAYC,MAAMC,QAAQnC,EAAMoC,WAClCC,UAAUrC,EAAMoC,UAAUL,IAC1B,KACEO,EAAStC,EAAMuC,IAAI,OACnBC,EAAW,UAAMF,EAAN,uBAA2BL,EAA3B,kBAMjB,OAAOD,EACW,OAAdC,IACE,SAAC,IAAD,CACE,aAAW,WACXT,QARoB,KAC1BiB,SAASC,SAAWF,CAApB,EAQMV,KAAK,QAHP,UAKE,SAAC,IAAD,MAGJ,IACL,C,iQCdD,MAAMa,GAAsBC,EAAAA,EAAAA,IAAO,MAAPA,EAAc,MACxCC,QAAS,OACTC,MAAO,OACPC,OAAQ,cAGJC,GAAYJ,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CAC9CC,MAAO,OACPC,aAAa,GAAD,OAAKF,EAAMG,QAAQ,IAAnB,kBAAiCH,EAAMI,QAAQC,SAF7B,IAK1BC,GAAwBX,EAAAA,EAAAA,KAAQY,IACpC,SAAC,KAAD,CACEC,eAAe,gBACfC,WAAS,EACTC,WAAW,SACXC,KAAK,YACDJ,KANsBZ,EAQ3B,QAAC,MAAEK,GAAH,QAAgB,CACjBC,MAAO,OADN,IAIGW,GAA0BjB,EAAAA,EAAAA,IAAO,MAAPA,EAAc,MAC5CC,QAAS,OACTc,WAAY,aAGRG,GAAuBlB,EAAAA,EAAAA,IAAO,MAAPA,EAAc,MACzCC,QAAS,OACTc,WAAY,SACZT,MAAO,GACPa,OAAQ,GACRhB,OAAQ,cAGJiB,GAAUpB,EAAAA,EAAAA,IAAOqB,EAAAA,EAAPrB,EAAmB,QAAC,MAAEK,GAAH,QAAgB,CACjDF,OAAQ,UACRmB,SAAUjB,EAAMkB,WAAWC,QAAQ,IAFF,IAK7BC,GAAkBzB,EAAAA,EAAAA,IAAO,MAAPA,EAAc,MACpCC,QAAS,OACTc,WAAY,SACZZ,OAAQ,UACRD,MAAO,OACPwB,YAAa,UAGTC,GAAc3B,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CAChDuB,WAAYvB,EAAMG,QAAQ,IAC1BqB,SAAU,QAFsB,IAK5BC,GAAa9B,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CAC/CC,MAAOD,EAAMkB,WAAWC,QAAQ,IAChCL,OAAQd,EAAMkB,WAAWC,QAAQ,IACjCE,YAAa,MAHkB,IAM3BK,GAAoB/B,EAAAA,EAAAA,IAAO,MAAPA,EAAc,MACtCgC,OAAQ,gBAGJC,GAAajC,EAAAA,EAAAA,IAAO,KAAPA,EAAa,MAC9BkC,QAAS,EACTF,OAAQ,EACRG,UAAW,WAGb,MAAMC,UAAuBC,EAAAA,UAU3BC,YAAY1B,GAAQ,IAAD,EACjB2B,MAAM3B,GADW,KAuHnB4B,eAAkBnE,IAEhB,MAAMoE,EAAOC,KAAK9B,MAAM+B,MAAMC,MAAMC,UAAUC,UAExCC,EAASL,KAAK9B,MAAMxD,MAAM4F,gBAE1BC,EAAqBR,EAAOM,EAAOG,SAAWT,GAAQM,EAAOI,QAEnE,IAAIC,GAAY,EAyBhB,OAtByC,IAArCV,KAAKW,4BACFX,KAAKY,MAAMC,SAAYN,GAAkC,WAAX,OAAD5E,QAAC,IAADA,OAAA,EAAAA,EAAGN,QACnDqF,GAAY,GAIXH,IACAP,KAAKY,MAAME,aAAgBd,KAAKY,MAAMC,UAEvCH,GAAY,IAKE,IAAdA,GACFV,KAAKe,gBAIPf,KAAKgB,SAAS,CACZF,YAAaP,IAERA,CAAP,EAxJiB,KA0NnBU,gBAAmBC,GAAavF,IAC9BqE,KAAK9B,MAAMiD,cAAcD,EAAzB,EA3NiB,KAoTnBE,UAAaC,IACX,MAAM,MAAE3G,GAAUsF,KAAK9B,MAEnBmD,EAAEpE,IAAI,UAAYvC,EAAMuC,IAAI,UAE9B+C,KAAK9B,MAAMxD,MAAME,YAAY2B,aAAa,CAGxC+E,OAAQ,GAERvG,WAAY,OAIdL,EAAM6G,YAAW,GAGjBvB,KAAK9B,MAAMsD,cAAcxB,KAAKyB,kBAG9BzB,KAAKgB,SAAS,CACZH,SAAS,EACTa,iBAAkB,KAErB,EA5UgB,KA+UnBH,WAAa,CAACI,EAAIC,KAChB,IAAIP,EACFQ,EAAkB,KAoBpB,GAhBIF,EAAGG,eAAe,UAAYH,EAAGG,eAAe,oBAClDD,EAAkBF,EAAGE,gBACrBR,EAAIM,EAAGjH,QAKPmH,EAAkB7B,KAAK9B,MAAMxD,MAAMoC,UACnCuE,EAAIM,GAQFN,IAAMrB,KAAK9B,MAAMxD,MAAO,CAE1BsF,KAAK9B,MAAMxD,MAAM6G,YAAW,GAI5BvB,KAAK9B,MAAMxD,MAAME,YAAY2B,aAAa,CAExC+E,OAAQO,EAAgBE,OACxBhH,WAAY,KAIZiH,OAAQC,OAAOC,QAAQlC,KAAK9B,MAAMxD,MAAMyH,YACrChG,QAAQiG,IAAyC,IAAnCP,EAAgBQ,QAAQD,EAAE,MACxCE,KAAKjB,GAAMA,EAAE,GAAGkB,QAChBR,KAAK,OAGV,MAAM,MAAErH,GAAUsF,KAAK9B,MAEvB,IAAIsE,EAAgB,IAAIX,GACpBnH,EAAMuC,IAAI,WAAavC,EAAMuC,IAAI,UAAUZ,OAAS,GACtDmG,EAAcC,KAAK/H,EAAMuC,IAAI,UAAU,IAGzC+C,KAAKgB,SAAS,CACZH,SAAS,EACTa,iBAAkBG,GAErB,GAnYgB,KAsZnBa,mBAAsBhI,GAAWiB,IAI/B,IAHiBqE,KAAKY,MAAMC,QAGf,CAEXb,KAAKuB,WAAW7G,GAGhB,MAAMoC,EAAYmF,OAAOU,KAAKjI,EAAM4F,gBAAgBsC,UAAUT,YAGxDpC,EAAOC,KAAK9B,MAAM+B,MAAMC,MAAMC,UAAUC,UACxCC,EAASL,KAAK9B,MAAMxD,MAAM4F,gBAC1BC,EACJR,EAAOM,EAAOG,SAAWT,GAAQM,EAAOI,QAE1C,IAAIC,GAAY,GAKyB,IAArCV,KAAKW,4BACFX,KAAKY,MAAMC,SAAYN,GAAkC,WAAX,OAAD5E,QAAC,IAADA,OAAA,EAAAA,EAAGN,QACnDqF,GAAY,GAMXH,IACAP,KAAKY,MAAME,aAAgBd,KAAKY,MAAMC,UAEvCH,GAAY,IAOE,IAAdA,GACFV,KAAKe,cAAcjE,GAAW,GAIhCkD,KAAKgB,SAAS,CACZF,YAAaP,EACbmB,iBAAkB5E,GAErB,MAECkD,KAAKoB,UAAU1G,EAChB,EA1cgB,KA6cnBmI,mBAAsBjB,GAAcjG,IAClC,IAIEmH,EAJEpB,EAAmB,IAAI1B,KAAKY,MAAMc,kBACpCqB,EAAYrB,EAAiBsB,MAC1BC,GAAoBA,IAAoBrB,IAI7C,MAAM,QAAEf,GAAYb,KAAKY,MACzBkC,EAAkBjC,EAElB,IAAIqC,GAAgB,EAqBpB,GAnBIH,EACFrB,EAAmBA,EAAiBvF,QACjC8G,GAAoBA,IAAoBrB,KAG3CF,EAAiBe,KAAKb,GACtBsB,GAAgB,IAGbrC,GAAWa,EAAiBrF,OAAS,IACxCyG,GAAkB,EAClB9C,KAAKuB,WAAWvB,KAAK9B,MAAMxD,MAAOkH,IAGJ,IAA5BF,EAAiBrF,SACnByG,GAAkB,EAClB9C,KAAKoB,UAAUpB,KAAK9B,MAAMxD,QAGxBgH,EAAiBrF,QAAU,EAAG,CAEhC,IAAI8G,EAAyB,GAC7BzB,EAAiB0B,SAASxB,IACxBuB,EAAuBV,KACrBzC,KAAK9B,MAAMxD,MAAMyH,WAAWP,GAAUW,MADxC,IAKFvC,KAAK9B,MAAMxD,MAAME,YAAY2B,aAAa,CAExC+E,OAAQI,EAAiBK,OAIzBC,OAAQC,OAAOC,QAAQlC,KAAK9B,MAAMxD,MAAMyH,YACrChG,QAAQiG,IAA0C,IAApCV,EAAiBW,QAAQD,EAAE,MACzCE,KAAKjB,GAAMA,EAAE,GAAGkB,QAChBR,KAAK,KACRhH,WAAY,OAEdiF,KAAK9B,MAAMxD,MAAM6G,WAAWuB,GAC5B9C,KAAKgB,SAAS,CACZH,QAASiC,EACTpB,iBAAkBA,IAIpB,MAAM3B,EAAOC,KAAK9B,MAAM+B,MAAMC,MAAMC,UAAUC,UACxCC,EAASL,KAAK9B,MAAMxD,MAAM4F,gBAC1BC,EACJR,EAAOM,EAAOG,SAAWT,GAAQM,EAAOI,QAE1C,IAAIC,GAAY,GAEyB,IAArCV,KAAKW,4BACFX,KAAKY,MAAMC,SAAYN,GAAkC,WAAX,OAAD5E,QAAC,IAADA,OAAA,EAAAA,EAAGN,QACnDqF,GAAY,GAIXH,IACAP,KAAKY,MAAME,aAAgBd,KAAKY,MAAMC,UAEvCH,GAAY,GAIZwC,IAAkB3C,IACpBG,GAAY,IAGI,IAAdA,GACFV,KAAKe,cAAca,GAAU,GAG/B5B,KAAKgB,SAAS,CACZF,YAAaP,GAEhB,MACCP,KAAKoB,UAAUpB,KAAK9B,MAAMxD,MAC3B,EAziBgB,KA6sBnB2I,kBAAoB,KAEfrD,KAAKsD,gBACJ,SAAC9E,EAAD,UACGwB,KAAKY,MAAM2C,aACV,SAAC,IAAD,CAAkBrH,QAAS,IAAM8D,KAAKwD,gBAEtC,SAAC,IAAD,CACEtH,QAAS,IAAM8D,KAAKwD,aACpBjB,MAAO,CACLkB,UAAWzD,KAAKY,MAAM2C,YAClB,iCACA,UACJG,aAAc,YAxtB1B,MAAQhJ,MAAAA,GAAUwD,EACZ0E,EAAY1E,EAAMxD,MAAMuC,IAAI,aAClC+C,KAAKY,MAAQ,CACX+C,QAASf,EAAUe,QACnB9C,QAAS3C,EAAMxD,MAAMuC,IAAI,WAIzByE,iBAAkBxD,EAAMxD,MAAMuC,IAAI,YAC9B,UAAAiB,EAAMxD,MAAMkJ,+BAAZ,eAAqCvH,QAAS,EAC5C6B,EAAMxD,MAAMkJ,wBACZ1F,EAAMxD,MAAMoC,UACd,GACJ+G,UAAU,EACVC,KAAM5F,EAAMxD,MAAMuC,IAAI,QACtB8G,OAAQnB,EAAUmB,OAClBC,OAAQ,KACRT,aAAa,EACbU,UAAWrB,EAAUqB,UACrBC,SAAUtB,EAAUsB,SACpBC,QAASvB,EAAUuB,QACnBC,YAAaxB,EAAUwB,YACvBC,UAAWzB,EAAUyB,UACrBC,cAAc,EACdC,YAAa3B,EAAU2B,YACvBC,MAAM,EACNC,aAAc,EACdC,gBAAgB,EAChBC,uBAAwB,CAAC,GAE3B3E,KAAK2E,uBAAyB3E,KAAK2E,uBAAuBC,KAAK5E,MAC/DA,KAAK6E,eAAiB7E,KAAK6E,eAAeD,KAAK5E,MAE/CA,KAAK8E,iBAAiD,KAAtB,OAATlC,QAAS,IAATA,OAAA,EAAAA,EAAWkC,iBAElC9E,KAAK+E,eAAiB/E,KAAKgF,sBAE3BhF,KAAKW,4BAA8BjG,EAAMuC,IAAI,8BAC9C,CAKDgI,oBAAqB,IAAD,IAClB,MAAM,MAAEhF,GAAUD,KAAK9B,MACvB+B,EAAMiF,eAAeC,UAAU,0BAA2BnF,KAAKoB,WAC/DnB,EAAMiF,eAAeC,UAAU,0BAA2BnF,KAAKuB,YAC/DtB,EAAMmF,SAASD,UAAU,YAAanF,KAAKoB,WAC3CnB,EAAMmF,SAASD,UAAU,YAAanF,KAAKuB,YAC3CtB,EAAMmF,SAASD,UAAU,cAAenF,KAAK0C,oBAG7C,aAAA1C,KAAK9B,MAAMxD,OAAM2K,UAAjB,gBAAsB,kBAAmB1J,IAEvC,MAAMkF,GAAWlF,EAAE2J,SACnBtF,KAAKgB,SAAS,CACZH,YAIFb,KAAKuF,mBAAmB1E,EAAxB,IAIFb,KAAKuF,mBAAmBvF,KAAKY,MAAMC,SAOnCZ,EAAMiF,eAAeC,UAAU,oCAAqCK,IAC5C,cAAtBxF,KAAKY,MAAMoD,QACThE,KAAKY,MAAMkD,OAAS0B,EAAEpK,IACtB4E,KAAKgB,SAAS,CACZgD,OAAQwB,EAAExB,QAHd,GAMH,CAcDgB,sBAAuB,IAAD,IAEpB,MAAM3E,EAASL,KAAK9B,MAAMxD,MAAM4F,gBAG1BmF,EAAI,UAAGpF,EAAOI,eAAV,QAAqB,EACzBiF,EAAI,UAAGrF,EAAOG,eAAV,QAAqB,EAI/B,OAAQiF,EAAO,GAAKA,EAAOE,KAAcD,EAAO,GAAKA,EAAOC,GAC7D,CA8DDJ,mBAAmBK,GACjB,MAAM,MAAE3F,GAAUD,KAAK9B,MAGvB,IAAK8B,KAAK+E,eAAgB,OAG1B,MAAMc,EAAY,eAGdD,IAAY5F,KAAK8F,gBACnB9F,KAAK8F,gBAAkB7F,EAAMiF,eAAeC,UAC1CU,EACA7F,KAAKF,gBAGHE,KAAK8F,kBACP7F,EAAMiF,eAAea,YAAYF,EAAW7F,KAAK8F,iBACjD9F,KAAK8F,gBAAkB,KAG5B,CAODE,eACE,MACwB,cAAtBhG,KAAKY,MAAMoD,SACT,SAAC,IAAD,CACEjI,oBAAkB,EAClBC,MAAM,wDAFR,UAIE,SAACwC,EAAD,WACE,SAAC,IAAD,OAKT,CAEDyH,oBACE,MAAMC,EACJlG,KAAKY,MAAMmD,OAAO,IAAM/D,KAAKY,MAAMmD,OAAO,GAAGoC,IACzCnG,KAAKY,MAAMmD,OAAO,GAAGoC,IACrB,GACN,OAAOD,GAAM,gBAAKtI,MAAM,KAAKwI,IAAI,SAASF,IAAKA,IAAU,IAC1D,CAMDG,aAAajL,EAAIkL,GACf,IAAIC,EAAS,GAiBb,OAhBI3J,MAAMC,QAAQyJ,KAChBC,EAASD,EAASE,QAAO,CAACC,EAAmBvF,KACvCtE,MAAMC,QAAQqE,EAAQwF,UACpBxF,EAAQwF,OAAO1D,MAAM2D,GAAYA,IAAYvL,MAC/CqL,EAAoB,IAAIA,EAAmBvF,IAEzCA,EAAQoF,SAASjK,OAAS,IAC5BoK,EAAoB,IACfA,KACAzG,KAAKqG,aAAajL,EAAI8F,EAAQoF,aAIhCG,IACN,KAEEF,CACR,CAEDK,mBAAmBN,GACjB,GAAIA,GAAYA,EAASjK,OAAS,EAAG,CACnC,MAAMoK,EAAoBzG,KAAKqG,aAC7BrG,KAAK9B,MAAMxD,MAAMuC,IAAI,QACrBqJ,GAEF,OAAIG,EAAkBpK,OAAS,GAE3B,UAACgD,EAAD,YACE,SAAC,IAAD,+GAIA,SAACE,EAAD,UACGkH,EAAkBnE,KAAI,CAACpB,EAAS2F,KAE7B,yBACE,UAAC,IAAD,CACErK,KAAK,QACLN,QAAS8D,KAAKiB,gBAAgBC,GAFhC,UAIGA,EAAQ4F,QACT,SAAC,IAAD,CAAcC,GAAI,CAAE7H,WAAY,EAAGN,SAAU,cANxCiI,UAeZ,IAEV,CACC,OAAO,IAEV,CAEDG,SACEhH,KAAKgB,SAAS,CACZwD,MAAOxE,KAAKY,MAAM4D,MAErB,CAEDhB,aACExD,KAAKgB,SAAS,CACZuC,aAAcvD,KAAKY,MAAM2C,aAE5B,CAEDD,cACE,MAAMmD,EAAoBzG,KAAKqG,aAC7BrG,KAAK9B,MAAMxD,MAAMuC,IAAI,QACrB+C,KAAK9B,MAAMoI,WAEP,YAAEW,EAAF,QAAe9C,EAAf,UAAwBE,EAAxB,SAAmCH,GAAalE,KAAKY,MAC3D,QACEqG,GACA9C,GACAE,GACAH,GACAuC,EAAkBpK,OAAS,EAE9B,CA0PD6K,iBAAiBf,GACf,OAAO,SAAC/G,EAAD,CAAYgH,IAAI,2BAAwBF,IAAKC,GACrD,CAEDtB,eAAenK,EAAOkH,EAAUnF,GAC9B,MAAM,iBAAEiF,GAAqB1B,KAAKY,MAC5BC,EAAUa,EAAiBsB,MAC9BC,GAAoBA,IAAoBrB,IAErC8C,EAAiB1E,KAAK2E,uBAAuBC,KAAK5E,KAAMvD,GACxD0K,EAAazM,EAAMyH,WAAWP,GAAUuF,WAE9C,OACE,UAACzJ,EAAD,YACE,UAACO,EAAD,YACE,UAAC,KAAD,CACEG,WAAS,EACTC,WAAW,SACXC,KAAK,SACLpC,QAAS8D,KAAK6C,mBAAmBjB,GAJnC,WAME,SAAC7C,EAAD,UACI8B,GAGA,SAAC,IAAD,CACEkG,GAAI,CACFK,KAAOzJ,IACJqC,KAAKY,MAAME,aAAed,KAAKY,MAAMC,QAClClD,EAAMI,QAAQsJ,QAAQC,KACtB,OAPV,SAAC,IAAD,MAYHH,GAAcnH,KAAKkH,iBAAiBC,IACrC,SAACzI,EAAD,UAAUhE,EAAMyH,WAAWP,GAAU+B,cAEvC,UAACpF,EAAD,YACE,SAACC,EAAD,WACE,SAAC,UAAD,CACE/B,MAAOA,EACP/B,MAAOsF,KAAK9B,MAAMxD,MAClBgC,mBAAoBsD,KAAK9B,MAAMqJ,UAAUjF,IAAI5F,wBAGjD,SAAC8B,EAAD,UACGwB,KAAKY,MAAM+D,uBAAuBlI,IACjC,SAAC,IAAD,CAAWP,QAAS,IAAMwI,OAE1B,SAAC,IAAD,CAAexI,QAAS,IAAMwI,cAKrC1E,KAAKY,MAAM+D,uBAAuBlI,IACjC,SAAC,KAAD,CAAM+K,MAAI,EAACC,GAAI,GAAf,UACE,SAACxI,EAAD,CACEmH,IAAI,sBACJF,IAAKlG,KAAK9B,MAAMxD,MAAMyH,WAAWP,GAAUmC,WAG7C,OAjDUtH,EAoDnB,CAEDiL,kBACE,MAAM,KAAElD,GAASxE,KAAKY,OAChB,MAAElG,GAAUsF,KAAK9B,MAEvB,OAAIsG,GAEA,SAAC,IAAD,CAAKuC,GAAI,CAAE7H,WAAY,QAAvB,SACGxE,EAAMoC,UAAUwF,KAAI,CAACV,EAAUnF,IAC9BuD,KAAK6E,eAAenK,EAAOkH,EAAUnF,OAKpC,IAEV,CAEDkL,aACE,MAAM,UAAE1D,EAAF,SAAaC,GAAalE,KAAKY,MACrC,OAAIsD,GAEA,UAAC7E,EAAD,YACE,SAAC,IAAD,CAAYuI,QAAQ,YAApB,SAAiC3D,KACjC,SAAC,IAAD,CACE2D,QAAQ,QACRC,wBAAyB,CACvBC,OAAQ5D,QAMT,IAEV,CAED6D,qBACE,MAAM,QAAE5D,EAAF,YAAWC,GAAgBpE,KAAKY,MACtC,OAAIuD,GAEA,SAAC9E,EAAD,WACE,cAAG2I,KAAM7D,EAASvI,OAAO,SAASqM,IAAI,sBAAtC,SACG7D,GAAeD,MAKf,IAEV,CAED+D,cACE,MAAM,UAAE7D,GAAcrE,KAAKY,MAC3B,OAAIyD,GAEA,SAAChF,EAAD,WACE,SAAC,IAAD,CACEuI,QAAQ,QACRC,wBAAyB,CAAEC,OAAQzD,OAKlC,IAEV,CAED8D,gBACE,OAAInI,KAAKY,MAAM2C,aAEX,2BACGvD,KAAK2H,aACL3H,KAAK+H,qBACL/H,KAAKkI,eACN,yBAAMlI,KAAK4G,mBAAmB5G,KAAK9B,MAAMoI,UAAY,SAIlD,IAEV,CAED5B,iBACE1E,KAAKgB,SAAS,CACZ0D,gBAAiB1E,KAAKY,MAAM8D,gBAE/B,CAEDC,uBAAuBlI,GACrB,IAAI2L,EAAWpI,KAAKY,MAAM+D,uBAC1ByD,EAAS3L,IAAU2L,EAAS3L,GAC5BuD,KAAKgB,SAAS,CAAE2D,uBAAwByD,GACzC,CAkCDrH,cAAcsH,EAAUC,GAGtB,GAAItI,KAAKyB,iBAAkB,OAE3B,MAAM,MAAE/G,GAAUsF,KAAK9B,MAGjBiE,GAFkBzH,EAAM4F,gBACIsC,WAAa,CAAC,GACnBT,YAAc,CAAC,EAE5C,IAAIK,EAAgB,IAAIxC,KAAKY,MAAMc,kBAC/BhH,EAAMuC,IAAI,WAAavC,EAAMuC,IAAI,UAAUZ,OAAS,GACtDmG,EAAcC,KAAK/H,EAAMuC,IAAI,UAAU,IAYzC,MAAMsL,EAAuB3G,IAC3B,GAAIA,EAAU,CAAC,IAAD,EACZ,MAAM4G,EAAY,UAAGrG,EAAWP,UAAd,aAAG,EAAsB+B,QAC3C,GAAI6E,EAAc,CAChB,MAAMC,EAAO,kBAAcD,EAAd,iDAEbxI,KAAKyB,iBAAmBzB,KAAK9B,MAAMwK,gBAAgBD,EAAS,CAC1Db,QAAS,UACTe,kBAAkB,EAClBC,QAAS,KACP5I,KAAKyB,iBAAmB,IAAxB,GAGL,CACF,GAIC6G,GAAgB1L,MAAMC,QAAQwL,GAEhCA,EAASjF,SAASxB,IAChB2G,EAAoB3G,EAApB,IAEOyG,EAETE,EAAoBF,GAGpB7F,EAAcY,SAASxB,IACrB2G,EAAoB3G,EAApB,GAGL,CAUDiH,cACE,MAAM,MAAEnO,GAAUsF,KAAK9B,OACjB,QAAE2C,EAAF,iBAAWa,GAAqB1B,KAAKY,MAC3C,OACE,SAAC7B,EAAD,UACI8B,EAEEa,EAAiBrF,SAAW3B,EAAMoC,UAAUT,QAC9C,SAAC,IAAD,CAAc0K,GAAI,CAAEK,KAAM,WAE1B,SAAC,IAAD,KAJA,SAAC,IAAD,KAQP,CAED0B,SACE,MAAM,iBAAEC,EAAF,MAAoBrO,GAAUsF,KAAK9B,OACnC,KAAEsG,EAAF,eAAQE,EAAR,YAAwBnB,GAAgBvD,KAAKY,MAE7CuG,EAAazM,EAAMuC,IAAI,aAAakK,WAC1C,OACE,UAAC,KAAD,CACEJ,GAAI,CACF7H,WAAYc,KAAK8E,gBAAkB,OAAS,QAFhD,WAKE,UAAC,KAAD,CAAM1G,WAAS,EAACC,WAAW,SAASC,KAAK,SAAzC,WAC4B,IAAzB0B,KAAK8E,kBACJ,SAACzH,EAAD,UACGmH,GACC,SAAC,IAAD,CAAuBtI,QAAS,IAAM8D,KAAKgH,YAE3C,SAAC,IAAD,CAAwB9K,QAAS,IAAM8D,KAAKgH,cAIlD,SAACtJ,EAAD,WACE,UAACO,EAAD,YACE,UAAC,KAAD,CACEG,WAAS,EACTC,WAAW,SACXC,KAAK,SACLpC,QAAS8D,KAAK0C,mBAAmBhI,GAJnC,WAME,SAAC,KAAD,CAAM8M,MAAI,EAAV,SAAYxH,KAAK6I,gBAChB1B,GAAcnH,KAAKkH,iBAAiBC,IACrC,SAACzI,EAAD,UAAUhE,EAAMuC,IAAI,iBAEtB,UAACsB,EAAD,WACGyB,KAAKgG,eACLhG,KAAKqD,qBACN,SAAC7E,EAAD,UACGkG,GACC,SAAC,IAAD,CAAWxI,QAAS,IAAM8D,KAAK0E,oBAE/B,SAAC,IAAD,CAAexI,QAAS,IAAM8D,KAAK0E,gCAO9C1E,KAAKmI,gBACLzD,GAAkBnB,IAAgBvD,KAAKsD,eAAgB,kBAAS,MACjE,0BACE,SAAC,UAAD,CACE0F,QAAShJ,KAAK9B,MAAM8K,QACpBtO,MAAOA,EACPqO,iBAAkBA,EAClB3D,SAAUpF,KAAK9B,MAAM+B,MAAMmF,SAC3B6D,QAASvE,EACTwE,aAAa,EACbC,YAAY,MAGfnJ,KAAK0H,oBAGX,EAGH,WAAe0B,EAAAA,EAAAA,IAAa1J,E,0GC59B5B,MAAM2J,GAAoB/L,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CACtD2L,SAAU,SACVC,YAAa,OACbC,aAAc,OACdC,cAAe,OACfC,WAAY,OAL0B,IAQlCC,GAAkBrM,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CACpDJ,QAAS,OACTqM,SAAU,aACVvL,WAAY,SAHwB,IAMhCwL,GAAoBvM,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CACtDmM,KAAM,WACNC,SAAU,OAF4B,IAKlCC,GAAgB1M,EAAAA,EAAAA,IAAO,MAAPA,EAAc,QAAC,MAAEK,GAAH,QAAgB,CAClD6B,QAAS,SACTsK,KAAM,WACN,WAAY,CACVG,IAAK,OAJ2B,IAQpC,MAAMC,UAAsBC,EAAAA,cAC1BvK,YAAY1B,GAAQ,IAAD,EACjB2B,MAAM3B,GADW,KAiBnBkM,cAAiBzO,IACf,MAAM8I,EAAe9I,EAAEC,OAAOyO,aAC9BrK,KAAKgB,SAAS,CACZyD,gBADF,EAnBiB,KA4DnB6F,qBAAuB,CAACC,EAAO9F,KAC7BzE,KAAK9B,MAAMxD,MAAM8P,WAAW/F,EAA5B,EA7DiB,KAgEnBuC,OAAUrL,IACRqE,KAAKgB,SAAS,CACZiI,SAAUjJ,KAAKY,MAAMqI,SADvB,EA9DA,MAAM,MAAEvO,GAAUwD,EACZ0E,EAAYlI,EAAMuC,IAAI,aAE5B+C,KAAKY,MAAQ,CACX6D,aAAc/J,EAAMuC,IAAI,WACxB8G,OAAQnB,EAAUmB,QAIpB,UAAArJ,EAAM2K,UAAN,cAAA3K,EAAW,iBAAkBsF,KAAKoK,cACnC,CAWDK,sBACE,MAAMhG,EAAezE,KAAKY,MAAM6D,aAChC,OACE,UAACkF,EAAD,YACE,SAACE,EAAD,WACE,SAAC,IAAD,CAAYjC,QAAQ,YAApB,0BAEF,SAACoC,EAAD,WACE,SAAC,KAAD,CACExN,KAAK,QACLf,MAAOgJ,EACPiG,IAAK,EACLC,IAAK,EACLC,KAAM,IACNlP,SAAUsE,KAAKsK,0BAGnB,SAACT,EAAD,WACE,UAAC,IAAD,CAAYjC,QAAQ,YAApB,UACGiD,KAAKC,MAAM,IAAMrG,EAAasG,QAAQ,IADzC,YAMP,CAsBDC,iBAAkB,IAAD,EACf,OACE,0BACE,UAAC3B,EAAD,YACoD,KAAjD,UAAArJ,KAAK9B,MAAM8K,eAAX,eAAoBiC,2BACrBjL,KAAK9B,MAAMgL,YACPlJ,KAAKyK,sBACL,KACHzK,KAAK9B,MAAMiL,WAAanJ,KAAKiG,oBAAsB,KACnDjG,KAAK9B,MAAMxD,MAAM4F,gBAAgB4K,YAChC,SAAC,UAAD,CAAcxQ,MAAOsF,KAAK9B,MAAMxD,QAC9B,KACHsF,KAAK9B,MAAM6K,mBACV,SAAC,UAAD,CAAWrO,MAAOsF,KAAK9B,MAAMxD,YAKtC,CAEDuL,oBAAqB,IAAD,MAClB,MAAMxJ,EAAQuD,KAAK9B,MAAMzB,MAAQuD,KAAK9B,MAAMzB,MAAQ,EAC9CyJ,EAAG,oBAAGlG,KAAKY,MAAMmD,cAAd,iBAAG,EAAoBtH,UAAvB,aAAG,EAA4B0J,WAA/B,QAAsC,GAE/C,OAAOD,GACL,0BACE,gBAAK,YAAU,QAAQE,IAAI,sBAAmBF,IAAKA,MAEnD,IACL,CAED4C,SACE,OACE,0BACE,yBAAM9I,KAAK9B,MAAM+K,QAAUjJ,KAAKgL,iBAAmB,QAGxD,EAGH,W,+JCrIA,MAAMG,GAAoB7N,EAAAA,EAAAA,IAAO8N,EAAAA,EAAP9N,EAAoB,QAAC,MAAEK,GAAH,QAAgB,CAC5D2B,OAAQ3B,EAAMG,QAAQ,GACtBiM,SAAU,IAFkC,IAKxCsB,GAAmB/N,EAAAA,EAAAA,IAAOqB,EAAAA,EAAPrB,EAAmB,QAAC,MAAEK,GAAH,QAAgB,CAC1D2N,WAAY,IAD8B,IAI5C,MAAMC,UAAqBpB,EAAAA,cACzBvK,YAAY1B,GACV2B,MAAM3B,GADW,KAgBnBsN,gBAAkB,KAChB,MAAM,IAAErF,EAAF,YAAOsF,GAAgBzL,KAAK9B,MAAMxD,MAAM4F,iBAC9CoL,EAAAA,EAAAA,QACEvF,EAAG,0FACkFsF,IACrFE,MAAMC,IACNA,EAASC,OAAOF,MAAMG,IACpB,MAAMC,EAAkBD,EAAYE,aAAaC,MAC9C5Q,GAASA,EAAK6Q,WAAaT,IAE9B,GAAIM,GAAmBnP,MAAMC,QAAQkP,EAAgBI,YAAa,CAChE,MAAMC,EAAkBL,EAAgBI,WACrChQ,QAAQkQ,GAA+B,iBAAlBA,EAAShR,OAC9BiH,KAAK+J,GAAaA,EAASvI,OAC9B9D,KAAKgB,SAAS,CACZoL,mBAEH,IAXH,GAJF,EAlBiB,KAsCnBE,aAAgB3Q,IACdqE,KAAKgB,SAAS,CACZ,CAACrF,EAAEC,OAAOkI,MAAOnI,EAAEC,OAAOH,OAD5B,EAvCiB,KAiDnB8Q,UAAa5Q,IACXqE,KAAK9B,MAAMxD,MAAM8R,IAAI,kBAAmBxM,KAAKY,MAAM6L,iBACnDzM,KAAK9B,MAAMxD,MAAM8R,IAAI,iBAAkBxM,KAAKY,MAAM8L,gBAClD1M,KAAK9B,MAAMxD,MAAM8R,IAAI,cAAexM,KAAKY,MAAM+L,aAE/C3M,KAAK9B,MAAMxD,MAAME,YAAYgS,SAA7B,EAtDiB,KA8DnBC,YAAelR,IAEbqE,KAAKgB,SAAS,CACZyL,gBAAiB,GACjBE,YAAa,GACbD,eAAgB,KAIlB1M,KAAK9B,MAAMxD,MAAM8R,IAAI,kBAAmB,IACxCxM,KAAK9B,MAAMxD,MAAM8R,IAAI,iBAAkB,IACvCxM,KAAK9B,MAAMxD,MAAM8R,IAAI,cAAe,IAGpCxM,KAAK9B,MAAMxD,MAAME,YAAYgS,SAA7B,EA1EA5M,KAAKY,MAAQ,CACX6L,gBAAiBvO,EAAMxD,MAAMuC,IAAI,oBAAsB,GACvD0P,YAAazO,EAAMxD,MAAMuC,IAAI,gBAAkB,GAC/CyP,eAAgBxO,EAAMxD,MAAMuC,IAAI,mBAAqB,GACrDmP,gBAAiB,IAEnBpM,KAAKwL,iBACN,CAsED1C,SACE,MAAM,MAAEpO,GAAUsF,KAAK9B,MACvB,OAAIxD,aAAiBoS,EAAAA,GAEjB,iCACE,SAACzB,EAAD,CAAkBzD,QAAQ,YAA1B,0DAGA,UAACuD,EAAD,YACE,SAAC,IAAD,CAAYhQ,QAAQ,YAApB,uBACA,SAAC,IAAD,CACEM,MAAOuE,KAAKY,MAAM6L,gBAClB/Q,SAAUsE,KAAKsM,aACfS,WAAY,CACVjJ,KAAM,kBACN1I,GAAI,aALR,SAQG4E,KAAKY,MAAMwL,gBAAgB9J,KAAI,CAAC+J,EAAUxF,KAEvC,SAAC,IAAD,CAAkBpL,MAAO4Q,EAAzB,SACGA,GADYxF,WAOvB,UAACsE,EAAD,YACE,SAAC,IAAD,CAAYhQ,QAAQ,WAApB,8BACA,UAAC,IAAD,CACEM,MAAOuE,KAAKY,MAAM8L,eAClBhR,SAAUsE,KAAKsM,aACfS,WAAY,CACVjJ,KAAM,iBACN1I,GAAI,YALR,WAQE,SAAC,IAAD,CAAUK,MAAM,KAAhB,8BACA,SAAC,IAAD,CAAUA,MAAM,KAAhB,2BACA,SAAC,IAAD,CAAUA,MAAM,KAAhB,uBACA,SAAC,IAAD,CAAUA,MAAM,MAAhB,kCAGJ,SAAC0P,EAAD,WACE,SAAC,IAAD,CACE1P,MAAOuE,KAAKY,MAAM+L,YAClBjR,SAAUsE,KAAKsM,aACf9Q,YAAY,iBACZuR,WAAY,CACVjJ,KAAM,cACN,aAAc,iBAKpB,SAAC,IAAD,CAAQ8D,QAAQ,YAAYoF,MAAM,UAAU9Q,QAAS8D,KAAKuM,UAA1D,uBAGA,SAAC,IAAD,CAAQrQ,QAAS8D,KAAK6M,YAAtB,gCAIG,IAEV,EAGH,W","sources":["plugins/LayerSwitcher/components/CQLFilter.js","plugins/LayerSwitcher/components/DownloadLink.js","plugins/LayerSwitcher/components/LayerGroupItem.js","plugins/LayerSwitcher/components/LayerSettings.js","plugins/LayerSwitcher/components/VectorFilter.js"],"sourcesContent":["import React, { useState } from \"react\";\nimport {\n  InputLabel,\n  OutlinedInput,\n  IconButton,\n  InputAdornment,\n  Tooltip,\n} from \"@mui/material\";\nimport RefreshIcon from \"@mui/icons-material/Refresh\";\n\nconst CQLFilter = ({ layer }) => {\n  const source = layer.getSource();\n  const currentCqlFilterValue =\n    (typeof source.getParams === \"function\" &&\n      source.getParams()?.CQL_FILTER) ||\n    \"\";\n\n  const [cqlFilter, setCqlFilter] = useState(currentCqlFilterValue);\n\n  const updateFilter = () => {\n    let filter = cqlFilter.trim();\n    if (filter.length === 0) filter = undefined; // If length === 0, unset filter.\n    layer.getSource().updateParams({ CQL_FILTER: filter });\n  };\n\n  return (\n    <>\n      <InputLabel htmlFor=\"cqlfilter\">Ange CQL-filter</InputLabel>\n      <OutlinedInput\n        id=\"cqlfilter\"\n        type=\"text\"\n        multiline\n        fullWidth\n        placeholder=\"foo='bar' AND fii='baz'\"\n        value={cqlFilter}\n        onChange={(e) => setCqlFilter(e.target.value)}\n        endAdornment={\n          <InputAdornment position=\"end\">\n            <Tooltip\n              disableInteractive\n              title=\"Tryck för att ladda om lagret med angivet filter\"\n            >\n              <IconButton edge=\"end\" onClick={updateFilter} size=\"large\">\n                <RefreshIcon />\n              </IconButton>\n            </Tooltip>\n          </InputAdornment>\n        }\n      />\n    </>\n  );\n};\n\nexport default CQLFilter;\n","import React from \"react\";\nimport IconButton from \"@mui/material/IconButton\";\nimport CloudDownloadIcon from \"@mui/icons-material/CloudDownload\";\n\n/**\n * @summary Renders a Download button which on click downloads the current layer as KML\n *\n * @param {Object} { index = 0, parent }\n * @returns {React.Component}\n */\nfunction DownloadLink({ index = 0, layer, enableDownloadLink = false }) {\n  const layerName = Array.isArray(layer.subLayers)\n    ? encodeURI(layer.subLayers[index])\n    : null;\n  const wmsUrl = layer.get(\"url\");\n  const downloadUrl = `${wmsUrl}/kml?layers=${layerName}&mode=download`;\n\n  const handleDownloadClick = () => {\n    document.location = downloadUrl;\n  };\n\n  return enableDownloadLink\n    ? layerName !== null && (\n        <IconButton\n          aria-label=\"download\"\n          onClick={handleDownloadClick}\n          size=\"small\"\n        >\n          <CloudDownloadIcon />\n        </IconButton>\n      )\n    : null;\n}\n\nexport default DownloadLink;\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Button, Tooltip, Typography, Grid, Box } from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { withSnackbar } from \"notistack\";\nimport IconWarning from \"@mui/icons-material/Warning\";\nimport CallMadeIcon from \"@mui/icons-material/CallMade\";\nimport InfoIcon from \"@mui/icons-material/Info\";\nimport RemoveCircleIcon from \"@mui/icons-material/RemoveCircle\";\nimport CheckBoxIcon from \"@mui/icons-material/CheckBox\";\nimport CheckBoxOutlineBlankIcon from \"@mui/icons-material/CheckBoxOutlineBlank\";\nimport MoreHorizIcon from \"@mui/icons-material/MoreHoriz\";\nimport CloseIcon from \"@mui/icons-material/Close\";\nimport LayerSettings from \"./LayerSettings.js\";\nimport DownloadLink from \"./DownloadLink\";\nimport KeyboardArrowRightIcon from \"@mui/icons-material/KeyboardArrowRight\";\nimport KeyboardArrowDownIcon from \"@mui/icons-material/KeyboardArrowDown\";\n\nconst ExpandButtonWrapper = styled(\"div\")(() => ({\n  display: \"flex\",\n  float: \"left\",\n  cursor: \"pointer\",\n}));\n\nconst LayerInfo = styled(\"div\")(({ theme }) => ({\n  width: \"100%\",\n  borderBottom: `${theme.spacing(0.2)} solid ${theme.palette.divider}`,\n}));\n\nconst LayerSummaryContainer = styled((props) => (\n  <Grid\n    justifyContent=\"space-between\"\n    container\n    alignItems=\"center\"\n    wrap=\"nowrap\"\n    {...props}\n  />\n))(({ theme }) => ({\n  width: \"100%\",\n}));\n\nconst SummaryButtonsContainer = styled(\"div\")(() => ({\n  display: \"flex\",\n  alignItems: \"center\",\n}));\n\nconst SummaryButtonWrapper = styled(\"div\")(() => ({\n  display: \"flex\",\n  alignItems: \"center\",\n  width: 35,\n  height: 35,\n  cursor: \"pointer\",\n}));\n\nconst Caption = styled(Typography)(({ theme }) => ({\n  cursor: \"pointer\",\n  fontSize: theme.typography.pxToRem(15),\n}));\n\nconst CheckBoxWrapper = styled(\"div\")(() => ({\n  display: \"flex\",\n  alignItems: \"center\",\n  cursor: \"pointer\",\n  float: \"left\",\n  marginRight: \"5px\",\n}));\n\nconst LegendImage = styled(\"img\")(({ theme }) => ({\n  marginLeft: theme.spacing(0.4),\n  maxWidth: \"250px\",\n}));\n\nconst LegendIcon = styled(\"img\")(({ theme }) => ({\n  width: theme.typography.pxToRem(18),\n  height: theme.typography.pxToRem(18),\n  marginRight: \"5px\",\n}));\n\nconst InfoTextContainer = styled(\"div\")(() => ({\n  margin: \"10px 45px\",\n}));\n\nconst StyledList = styled(\"ul\")(() => ({\n  padding: 0,\n  margin: 0,\n  listStyle: \"none\",\n}));\n\nclass LayerGroupItem extends Component {\n  static propTypes = {\n    options: PropTypes.object,\n    layer: PropTypes.object.isRequired,\n    cqlFilterVisible: PropTypes.bool,\n    model: PropTypes.object.isRequired,\n    observer: PropTypes.object,\n    chapters: PropTypes.array,\n  };\n\n  constructor(props) {\n    super(props);\n    const { layer } = props;\n    const layerInfo = props.layer.get(\"layerInfo\");\n    this.state = {\n      caption: layerInfo.caption,\n      visible: props.layer.get(\"visible\"),\n      // If layer is to be shown, check if there are some specified sublayers (if yes, we'll\n      // enable only those). Else, let's default to showing all sublayers, or finally fallback\n      // to an empty array.\n      visibleSubLayers: props.layer.get(\"visible\")\n        ? props.layer.visibleAtStartSubLayers?.length > 0\n          ? props.layer.visibleAtStartSubLayers\n          : props.layer.subLayers\n        : [],\n      expanded: false,\n      name: props.layer.get(\"name\"),\n      legend: layerInfo.legend,\n      status: \"ok\",\n      infoVisible: false,\n      infoTitle: layerInfo.infoTitle,\n      infoText: layerInfo.infoText,\n      infoUrl: layerInfo.infoUrl,\n      infoUrlText: layerInfo.infoUrlText,\n      infoOwner: layerInfo.infoOwner,\n      infoExpanded: false,\n      instruction: layerInfo.instruction,\n      open: false,\n      opacityValue: 1,\n      toggleSettings: false,\n      toggleSubLayerSettings: {},\n    };\n    this.toggleSubLayerSettings = this.toggleSubLayerSettings.bind(this);\n    this.renderSubLayer = this.renderSubLayer.bind(this);\n\n    this.hideExpandArrow = layerInfo?.hideExpandArrow === true ? true : false;\n    // Check if the layer uses min and max zoom levels.\n    this.usesMinMaxZoom = this.layerUsesMinMaxZoom();\n    // Get the minMaxZoomAlertOnToggleOnly property from the layer.\n    this.minMaxZoomAlertOnToggleOnly = layer.get(\"minMaxZoomAlertOnToggleOnly\");\n  }\n  /**\n   * Triggered when the component is successfully mounted into the DOM.\n   * @instance\n   */\n  componentDidMount() {\n    const { model } = this.props;\n    model.globalObserver.subscribe(\"layerswitcher.hideLayer\", this.setHidden);\n    model.globalObserver.subscribe(\"layerswitcher.showLayer\", this.setVisible);\n    model.observer.subscribe(\"hideLayer\", this.setHidden);\n    model.observer.subscribe(\"showLayer\", this.setVisible);\n    model.observer.subscribe(\"toggleGroup\", this.toggleGroupVisible);\n\n    // Listen for changes in the layer's visibility.\n    this.props.layer.on?.(\"change:visible\", (e) => {\n      // Update the 'visible' state based on the layer's new visibility.\n      const visible = !e.oldValue;\n      this.setState({\n        visible,\n      });\n\n      // Listen to zoom changes if the layer is visible.\n      this.listenToZoomChange(visible);\n    });\n\n    // Initially listen to zoom changes if the layer is visible.\n    this.listenToZoomChange(this.state.visible);\n\n    // Set load status by subscribing to a global event. Expect ID (int) of layer\n    // and status (string \"ok\"|\"loaderror\"). Also, once status was set to \"loaderror\",\n    // don't change it back to \"ok\": we'll get a response for each tile, so most of\n    // the tiles might be \"ok\", but if only one of the tiles has \"loaderror\", we\n    // consider that the layer has failed loading and want to inform the user.\n    model.globalObserver.subscribe(\"layerswitcher.wmsLayerLoadStatus\", (d) => {\n      this.state.status !== \"loaderror\" &&\n        this.state.name === d.id &&\n        this.setState({\n          status: d.status,\n        });\n    });\n  }\n\n  /**\n   * Determines if the layer has minimum and maximum zoom level restrictions.\n   *\n   * This function checks the layer properties to see if the layer has minimum and/or maximum\n   * zoom levels defined. If either minZoom or maxZoom is within the valid range (0 to Infinity),\n   * the function returns true, indicating that the layer has zoom restrictions.\n   *\n   * Example: If the layer has minZoom = 5 and maxZoom = 10, it will only be visible\n   * when the map's zoom level is between 5 and 10.\n   *\n   * @returns {boolean} - True if the layer has zoom restrictions, false otherwise.\n   */\n  layerUsesMinMaxZoom() {\n    // Retrieve the layer properties from the layer object.\n    const lprops = this.props.layer.getProperties();\n\n    // Get the maxZoom and minZoom properties if they exist, otherwise set them to 0.\n    const maxZ = lprops.maxZoom ?? 0;\n    const minZ = lprops.minZoom ?? 0;\n\n    // Check if either minZoom or maxZoom is within a valid range (0 < value < Infinity).\n    // Return true if any of them are within the valid range, otherwise return false.\n    return (maxZ > 0 && maxZ < Infinity) || (minZ > 0 && minZ < Infinity);\n  }\n\n  /**\n   * Handles the zoom end event to check if the layer should be visible at the current zoom level.\n   *\n   * This function is triggered when the map's zoom level changes. It checks if the layer's\n   * visibility is within the specified minZoom and maxZoom range. If the layer is not visible\n   * at the current zoom level and the conditions to show a Snackbar message are met, it calls\n   * the showZoomSnack() function to display a message. The function also updates the\n   * state.zoomVisible property accordingly.\n   *\n   * @param {Object} e - The event object (optional).\n   * @returns {boolean} - True if the layer is visible at the current zoom level, false otherwise.\n   */\n  zoomEndHandler = (e) => {\n    // Get the current map zoom level.\n    const zoom = this.props.model.olMap.getView().getZoom();\n    // Retrieve the layer properties.\n    const lprops = this.props.layer.getProperties();\n    // Check if the current zoom level is within the allowed range of minZoom and maxZoom.\n    const layerIsZoomVisible = zoom > lprops.minZoom && zoom <= lprops.maxZoom;\n\n    let showSnack = false;\n\n    // Determine if the Snackbar message should be shown based on the layer visibility and zoom level conditions.\n    if (this.minMaxZoomAlertOnToggleOnly === true) {\n      if (!this.state.visible && !layerIsZoomVisible && e?.type === \"click\") {\n        showSnack = true;\n      }\n    } else {\n      if (\n        !layerIsZoomVisible &&\n        (this.state.zoomVisible || !this.state.visible)\n      ) {\n        showSnack = true;\n      }\n    }\n\n    // If the Snackbar message should be shown, call the showZoomSnack function.\n    if (showSnack === true) {\n      this.showZoomSnack();\n    }\n\n    // Update the state with the new value for zoomVisible.\n    this.setState({\n      zoomVisible: layerIsZoomVisible,\n    });\n    return layerIsZoomVisible;\n  };\n\n  /**\n   * Subscribes or unsubscribes to the zoom end event based on the provided parameter.\n   *\n   * This function either subscribes or unsubscribes the zoomEndHandler() function to the\n   * 'core.zoomEnd' event, depending on the value of the bListen parameter. If the layer\n   * doesn't have any zoom restrictions, the function returns without doing anything.\n   *\n   * Example: If the layer is visible, subscribe to the map's \"moveend\" event to listen for\n   * zoom changes; if it's not visible, unsubscribe from the event.\n   *\n   * @param {boolean} bListen - If true, subscribes to the zoom end event; if false, unsubscribes.\n   */\n  listenToZoomChange(bListen) {\n    const { model } = this.props;\n\n    // If the layer doesn't use minZoom and maxZoom properties, return without doing anything.\n    if (!this.usesMinMaxZoom) return;\n\n    // Define the event name for zoom change events.\n    const eventName = \"core.zoomEnd\";\n\n    // Subscribe or unsubscribe to the zoom change event based on the 'bListen' parameter.\n    if (bListen && !this.zoomEndListener) {\n      this.zoomEndListener = model.globalObserver.subscribe(\n        eventName,\n        this.zoomEndHandler\n      );\n    } else {\n      if (this.zoomEndListener) {\n        model.globalObserver.unsubscribe(eventName, this.zoomEndListener);\n        this.zoomEndListener = null;\n      }\n    }\n  }\n\n  /**\n   * Render the load information component.\n   * @instance\n   * @return {external:ReactElement}\n   */\n  renderStatus() {\n    return (\n      this.state.status === \"loaderror\" && (\n        <Tooltip\n          disableInteractive\n          title=\"Lagret kunde inte laddas in. Kartservern svarar inte.\"\n        >\n          <SummaryButtonWrapper>\n            <IconWarning />\n          </SummaryButtonWrapper>\n        </Tooltip>\n      )\n    );\n  }\n\n  renderLegendImage() {\n    const src =\n      this.state.legend[0] && this.state.legend[0].url\n        ? this.state.legend[0].url\n        : \"\";\n    return src ? <img width=\"60\" alt=\"legend\" src={src} /> : null;\n  }\n\n  openInformative = (chapter) => (e) => {\n    this.props.onOpenChapter(chapter);\n  };\n\n  findChapters(id, chapters) {\n    var result = [];\n    if (Array.isArray(chapters)) {\n      result = chapters.reduce((chaptersWithLayer, chapter) => {\n        if (Array.isArray(chapter.layers)) {\n          if (chapter.layers.some((layerId) => layerId === id)) {\n            chaptersWithLayer = [...chaptersWithLayer, chapter];\n          }\n          if (chapter.chapters.length > 0) {\n            chaptersWithLayer = [\n              ...chaptersWithLayer,\n              ...this.findChapters(id, chapter.chapters),\n            ];\n          }\n        }\n        return chaptersWithLayer;\n      }, []);\n    }\n    return result;\n  }\n\n  renderChapterLinks(chapters) {\n    if (chapters && chapters.length > 0) {\n      const chaptersWithLayer = this.findChapters(\n        this.props.layer.get(\"name\"),\n        chapters\n      );\n      if (chaptersWithLayer.length > 0) {\n        return (\n          <InfoTextContainer>\n            <Typography>\n              Innehåll från denna kategori finns benämnt i följande kapitel i\n              översiktsplanen:\n            </Typography>\n            <StyledList>\n              {chaptersWithLayer.map((chapter, i) => {\n                return (\n                  <li key={i}>\n                    <Button\n                      size=\"small\"\n                      onClick={this.openInformative(chapter)}\n                    >\n                      {chapter.header}\n                      <CallMadeIcon sx={{ marginLeft: 1, fontSize: \"16px\" }} />\n                    </Button>\n                  </li>\n                );\n              })}\n            </StyledList>\n          </InfoTextContainer>\n        );\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  toggle() {\n    this.setState({\n      open: !this.state.open,\n    });\n  }\n\n  toggleInfo() {\n    this.setState({\n      infoVisible: !this.state.infoVisible,\n    });\n  }\n\n  isInfoEmpty() {\n    const chaptersWithLayer = this.findChapters(\n      this.props.layer.get(\"name\"),\n      this.props.chapters\n    );\n    const { infoCaption, infoUrl, infoOwner, infoText } = this.state;\n    return !(\n      infoCaption ||\n      infoUrl ||\n      infoOwner ||\n      infoText ||\n      chaptersWithLayer.length > 0\n    );\n  }\n\n  setHidden = (l) => {\n    const { layer } = this.props;\n\n    if (l.get(\"name\") === layer.get(\"name\")) {\n      // Fix underlying source\n      this.props.layer.getSource().updateParams({\n        // Ensure that the list of sublayers is emptied (otherwise they'd be\n        // \"remembered\" the next time user toggles group)\n        LAYERS: \"\",\n        // Remove any filters\n        CQL_FILTER: null,\n      });\n\n      // Hide the layer in OL\n      layer.setVisible(false);\n\n      // Close any existing zoom warning Snackbars.\n      this.props.closeSnackbar(this.zoomWarningSnack);\n\n      // Update UI state\n      this.setState({\n        visible: false,\n        visibleSubLayers: [],\n      });\n    }\n  };\n\n  setVisible = (la, subLayer) => {\n    let l,\n      subLayersToShow = null;\n\n    // If the incoming parameter is an object that contains additional subLayersToShow,\n    // let's filter out the necessary objects from it\n    if (la.hasOwnProperty(\"layer\") && la.hasOwnProperty(\"subLayersToShow\")) {\n      subLayersToShow = la.subLayersToShow;\n      l = la.layer;\n    } else {\n      // In this case the incoming parameter is the actual OL Layer and there is\n      // no need to further filter. Just set subLayers to everything that's in this\n      // layer, and the incoming object itself as the working 'l' variable.\n      subLayersToShow = this.props.layer.subLayers;\n      l = la;\n    }\n\n    // Now we can be sure that we have the working 'l' variable and can compare\n    // it to the 'layer' object in current props. Note that this is necessary, as\n    // every single LayerGroupItem is subscribing to the event that calls this method,\n    // so without this check we'd end up running this for every LayerGroupItem, which\n    // is not intended.\n    if (l === this.props.layer) {\n      // Show the OL layer\n      this.props.layer.setVisible(true);\n\n      // Set LAYERS and STYLES so that the exact sublayers that are needed\n      // will be visible\n      this.props.layer.getSource().updateParams({\n        // join(), so we always provide a string as value to LAYERS\n        LAYERS: subLayersToShow.join(),\n        CQL_FILTER: null,\n        // Extract .style property from each sub layer.\n        // Join them into a string that will be used to\n        // reset STYLES param for the GET request.\n        STYLES: Object.entries(this.props.layer.layersInfo)\n          .filter((k) => subLayersToShow.indexOf(k[0]) !== -1)\n          .map((l) => l[1].style)\n          .join(\",\"),\n      });\n\n      const { layer } = this.props;\n\n      let visibleLayers = [...subLayersToShow];\n      if (layer.get(\"layers\") && layer.get(\"layers\").length > 0) {\n        visibleLayers.push(layer.get(\"layers\")[0]);\n      }\n\n      this.setState({\n        visible: true,\n        visibleSubLayers: subLayersToShow,\n      });\n    }\n  };\n\n  /**\n   * Toggles the visibility of a group layer and handles Snackbar messages for sublayers.\n   *\n   * This function toggles the visibility of the provided group layer. If the layer becomes visible,\n   * it calls setVisible() and checks the current zoom level to see if the layer should be visible.\n   * If the layer is not visible at the current zoom level and the conditions to show a Snackbar\n   * message are met, it calls the showZoomSnack() function to display a message. The function\n   * also updates the state.zoomVisible and state.visibleSubLayers properties accordingly.\n   * If the layer becomes hidden, it calls setHidden().\n   *\n   * Example: If a layer group has 3 sublayers, clicking the checkbox will show\n   * or hide all 3 sublayers at once.\n   *\n   * @param {Object} layer - The group layer to toggle visibility for.\n   * @returns {function} - A function to handle the onClick event for the group layer.\n   */\n  toggleGroupVisible = (layer) => (e) => {\n    const visible = !this.state.visible;\n\n    // If the layer is becoming visible.\n    if (visible) {\n      // Set the layer as visible.\n      this.setVisible(layer);\n\n      // Get all sublayers of the layer group.\n      const subLayers = Object.keys(layer.getProperties().layerInfo.layersInfo);\n\n      // Get the current zoom level.\n      const zoom = this.props.model.olMap.getView().getZoom();\n      const lprops = this.props.layer.getProperties();\n      const layerIsZoomVisible =\n        zoom > lprops.minZoom && zoom <= lprops.maxZoom;\n\n      let showSnack = false;\n\n      // If the layer is not visible at the current zoom level, show a Snackbar.\n      // Example: If minMaxZoomAlertOnToggleOnly is set to true, a Snackbar will only be shown\n      // when the layer is toggled on and is not visible at the current zoom level.\n      if (this.minMaxZoomAlertOnToggleOnly === true) {\n        if (!this.state.visible && !layerIsZoomVisible && e?.type === \"click\") {\n          showSnack = true;\n        }\n      } else {\n        // If the layer is not visible at the current zoom level and either\n        // state.zoomVisible is true or state.visible is false, a Snackbar will be shown.\n        if (\n          !layerIsZoomVisible &&\n          (this.state.zoomVisible || !this.state.visible)\n        ) {\n          showSnack = true;\n        }\n      }\n\n      // If a Snackbar should be shown, call the showZoomSnack function with the subLayers array and set isGroupLayer to true.\n      // Example: If a group layer has 3 sublayers and none are visible at the current zoom level,\n      // the Snackbar will display a message for each sublayer.\n      if (showSnack === true) {\n        this.showZoomSnack(subLayers, true);\n      }\n\n      // Update the state with the new values for zoomVisible and visibleSubLayers.\n      this.setState({\n        zoomVisible: layerIsZoomVisible,\n        visibleSubLayers: subLayers,\n      });\n    } else {\n      // If the layer is becoming hidden, call setHidden() to set the layer as hidden.\n      this.setHidden(layer);\n    }\n  };\n\n  toggleLayerVisible = (subLayer) => (e) => {\n    var visibleSubLayers = [...this.state.visibleSubLayers],\n      isVisible = visibleSubLayers.some(\n        (visibleSubLayer) => visibleSubLayer === subLayer\n      ),\n      layerVisibility;\n\n    const { visible } = this.state;\n    layerVisibility = visible;\n\n    let isNewSubLayer = false;\n\n    if (isVisible) {\n      visibleSubLayers = visibleSubLayers.filter(\n        (visibleSubLayer) => visibleSubLayer !== subLayer\n      );\n    } else {\n      visibleSubLayers.push(subLayer);\n      isNewSubLayer = true;\n    }\n\n    if (!visible && visibleSubLayers.length > 0) {\n      layerVisibility = true;\n      this.setVisible(this.props.layer, subLayer);\n    }\n\n    if (visibleSubLayers.length === 0) {\n      layerVisibility = false;\n      this.setHidden(this.props.layer);\n    }\n\n    if (visibleSubLayers.length >= 1) {\n      // Create an Array to be used as STYLES param, it should only contain selected sublayers' styles\n      let visibleSubLayersStyles = [];\n      visibleSubLayers.forEach((subLayer) => {\n        visibleSubLayersStyles.push(\n          this.props.layer.layersInfo[subLayer].style\n        );\n      });\n\n      this.props.layer.getSource().updateParams({\n        // join(), so we always provide a string as value to LAYERS\n        LAYERS: visibleSubLayers.join(),\n        // Filter STYLES to only contain styles for currently visible layers,\n        // and maintain the order from layersInfo (it's crucial that the order\n        // of STYLES corresponds exactly to the order of LAYERS!)\n        STYLES: Object.entries(this.props.layer.layersInfo)\n          .filter((k) => visibleSubLayers.indexOf(k[0]) !== -1)\n          .map((l) => l[1].style)\n          .join(\",\"),\n        CQL_FILTER: null,\n      });\n      this.props.layer.setVisible(layerVisibility);\n      this.setState({\n        visible: layerVisibility,\n        visibleSubLayers: visibleSubLayers,\n      });\n\n      // Display a Snackbar message if the layer is not visible at the current zoom level.\n      const zoom = this.props.model.olMap.getView().getZoom();\n      const lprops = this.props.layer.getProperties();\n      const layerIsZoomVisible =\n        zoom > lprops.minZoom && zoom <= lprops.maxZoom;\n\n      let showSnack = false;\n\n      if (this.minMaxZoomAlertOnToggleOnly === true) {\n        if (!this.state.visible && !layerIsZoomVisible && e?.type === \"click\") {\n          showSnack = true;\n        }\n      } else {\n        if (\n          !layerIsZoomVisible &&\n          (this.state.zoomVisible || !this.state.visible)\n        ) {\n          showSnack = true;\n        }\n      }\n\n      if (isNewSubLayer && !layerIsZoomVisible) {\n        showSnack = true;\n      }\n\n      if (showSnack === true) {\n        this.showZoomSnack(subLayer, false);\n      }\n\n      this.setState({\n        zoomVisible: layerIsZoomVisible,\n      });\n    } else {\n      this.setHidden(this.props.layer);\n    }\n  };\n\n  renderLegendIcon(url) {\n    return <LegendIcon alt=\"Teckenförklaringsikon\" src={url} />;\n  }\n\n  renderSubLayer(layer, subLayer, index) {\n    const { visibleSubLayers } = this.state;\n    const visible = visibleSubLayers.some(\n      (visibleSubLayer) => visibleSubLayer === subLayer\n    );\n    const toggleSettings = this.toggleSubLayerSettings.bind(this, index);\n    const legendIcon = layer.layersInfo[subLayer].legendIcon;\n\n    return (\n      <LayerInfo key={index}>\n        <LayerSummaryContainer>\n          <Grid\n            container\n            alignItems=\"center\"\n            wrap=\"nowrap\"\n            onClick={this.toggleLayerVisible(subLayer)}\n          >\n            <CheckBoxWrapper>\n              {!visible ? (\n                <CheckBoxOutlineBlankIcon />\n              ) : (\n                <CheckBoxIcon\n                  sx={{\n                    fill: (theme) =>\n                      !this.state.zoomVisible && this.state.visible\n                        ? theme.palette.warning.dark\n                        : \"\",\n                  }}\n                />\n              )}\n            </CheckBoxWrapper>\n            {legendIcon && this.renderLegendIcon(legendIcon)}\n            <Caption>{layer.layersInfo[subLayer].caption}</Caption>\n          </Grid>\n          <SummaryButtonsContainer>\n            <SummaryButtonWrapper>\n              <DownloadLink\n                index={index}\n                layer={this.props.layer}\n                enableDownloadLink={this.props.mapConfig.map.enableDownloadLink}\n              />\n            </SummaryButtonWrapper>\n            <SummaryButtonWrapper>\n              {this.state.toggleSubLayerSettings[index] ? (\n                <CloseIcon onClick={() => toggleSettings()} />\n              ) : (\n                <MoreHorizIcon onClick={() => toggleSettings()} />\n              )}\n            </SummaryButtonWrapper>\n          </SummaryButtonsContainer>\n        </LayerSummaryContainer>\n        {this.state.toggleSubLayerSettings[index] ? (\n          <Grid item xs={12}>\n            <LegendImage\n              alt=\"Teckenförklaring\"\n              src={this.props.layer.layersInfo[subLayer].legend}\n            />\n          </Grid>\n        ) : null}\n      </LayerInfo>\n    );\n  }\n\n  renderSubLayers() {\n    const { open } = this.state;\n    const { layer } = this.props;\n\n    if (open) {\n      return (\n        <Box sx={{ marginLeft: \"45px\" }}>\n          {layer.subLayers.map((subLayer, index) =>\n            this.renderSubLayer(layer, subLayer, index)\n          )}\n        </Box>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderInfo() {\n    const { infoTitle, infoText } = this.state;\n    if (infoText) {\n      return (\n        <InfoTextContainer>\n          <Typography variant=\"subtitle2\">{infoTitle}</Typography>\n          <Typography\n            variant=\"body2\"\n            dangerouslySetInnerHTML={{\n              __html: infoText,\n            }}\n          />\n        </InfoTextContainer>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderMetadataLink() {\n    const { infoUrl, infoUrlText } = this.state;\n    if (infoUrl) {\n      return (\n        <InfoTextContainer>\n          <a href={infoUrl} target=\"_blank\" rel=\"noopener noreferrer\">\n            {infoUrlText || infoUrl}\n          </a>\n        </InfoTextContainer>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderOwner() {\n    const { infoOwner } = this.state;\n    if (infoOwner) {\n      return (\n        <InfoTextContainer>\n          <Typography\n            variant=\"body2\"\n            dangerouslySetInnerHTML={{ __html: infoOwner }}\n          ></Typography>\n        </InfoTextContainer>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderDetails() {\n    if (this.state.infoVisible) {\n      return (\n        <div>\n          {this.renderInfo()}\n          {this.renderMetadataLink()}\n          {this.renderOwner()}\n          <div>{this.renderChapterLinks(this.props.chapters || [])}</div>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  toggleSettings() {\n    this.setState({\n      toggleSettings: !this.state.toggleSettings,\n    });\n  }\n\n  toggleSubLayerSettings(index) {\n    var selected = this.state.toggleSubLayerSettings;\n    selected[index] = !selected[index];\n    this.setState({ toggleSubLayerSettings: selected });\n  }\n\n  renderInfoToggler = () => {\n    return (\n      !this.isInfoEmpty() && (\n        <SummaryButtonWrapper>\n          {this.state.infoVisible ? (\n            <RemoveCircleIcon onClick={() => this.toggleInfo()} />\n          ) : (\n            <InfoIcon\n              onClick={() => this.toggleInfo()}\n              style={{\n                boxShadow: this.state.infoVisible\n                  ? \"rgb(204, 204, 204) 2px 3px 1px\"\n                  : \"inherit\",\n                borderRadius: \"100%\",\n              }}\n            />\n          )}\n        </SummaryButtonWrapper>\n      )\n    );\n  };\n\n  /**\n   * Displays a Snackbar message to inform the user about the layer's visibility at the current zoom level.\n   *\n   * This function shows a Snackbar message for each visible sublayer that is not visible at the\n   * current zoom level, informing the user that the layer is not visible. If the layer is a\n   * group layer, it handles the Snackbar messages for all sublayers within the group.\n   *\n   * @param {Array|string} sublayer - The sublayer or an array of sublayers to show the Snackbar message for.\n   * @param {boolean} isGroupLayer - True if the layer is a group layer, false otherwise.\n   */\n  showZoomSnack(sublayer, isGroupLayer) {\n    // If a zoom warning snackbar is already displayed, return without doing anything.\n    // This method ensures that only one Snackbar notification is displayed at a time, preventing multiple notifications from overlapping.\n    if (this.zoomWarningSnack) return;\n\n    const { layer } = this.props;\n    const layerProperties = layer.getProperties();\n    const layerInfo = layerProperties.layerInfo || {};\n    const layersInfo = layerInfo.layersInfo || {};\n\n    let visibleLayers = [...this.state.visibleSubLayers];\n    if (layer.get(\"layers\") && layer.get(\"layers\").length > 0) {\n      visibleLayers.push(layer.get(\"layers\")[0]);\n    }\n\n    /**\n     * Adds captions to sublayers for display in a Snackbar message.\n     *\n     * This function receives a sublayer and retrieves the corresponding layer caption from the\n     * layerInfo object. It then creates a message string and enqueues a Snackbar with the message.\n     * The Snackbar will be displayed with a \"warning\" variant and will be removed when closed.\n     *\n     * @param {Object} subLayer - The sublayer for which to add captions.\n     */\n    const addSubLayerCaptions = (subLayer) => {\n      if (subLayer) {\n        const layerCaption = layersInfo[subLayer]?.caption;\n        if (layerCaption) {\n          const message = `Lagret \"${layerCaption}\" är inte synligt vid aktuell zoomnivå.`;\n\n          this.zoomWarningSnack = this.props.enqueueSnackbar(message, {\n            variant: \"warning\",\n            preventDuplicate: false,\n            onClose: () => {\n              this.zoomWarningSnack = null;\n            },\n          });\n        }\n      }\n    };\n\n    // Check if isGroupLayer is true and sublayer is an array.\n    if (isGroupLayer && Array.isArray(sublayer)) {\n      // Iterate through the sublayer array and call addSubLayerCaptions for each subLayer.\n      sublayer.forEach((subLayer) => {\n        addSubLayerCaptions(subLayer);\n      });\n    } else if (sublayer) {\n      // Check if sublayer is defined (not undefined or null).\n      addSubLayerCaptions(sublayer);\n    } else {\n      // If sublayer is undefined, iterate through the visibleLayers array and call addSubLayerCaptions for each subLayer.\n      visibleLayers.forEach((subLayer) => {\n        addSubLayerCaptions(subLayer);\n      });\n    }\n  }\n\n  /**\n   * Returns a checkbox element for the layer group.\n   *\n   * This function creates and returns a checkbox element for the layer group. The checkbox\n   * will toggle the visibility of the layer group when clicked.\n   *\n   * @returns {ReactElement} - A checkbox element for the layer group.\n   */\n  getCheckBox() {\n    const { layer } = this.props;\n    const { visible, visibleSubLayers } = this.state;\n    return (\n      <CheckBoxWrapper>\n        {!visible ? (\n          <CheckBoxOutlineBlankIcon />\n        ) : visibleSubLayers.length !== layer.subLayers.length ? (\n          <CheckBoxIcon sx={{ fill: \"gray\" }} />\n        ) : (\n          <CheckBoxIcon />\n        )}\n      </CheckBoxWrapper>\n    );\n  }\n\n  render() {\n    const { cqlFilterVisible, layer } = this.props;\n    const { open, toggleSettings, infoVisible } = this.state;\n\n    const legendIcon = layer.get(\"layerInfo\").legendIcon;\n    return (\n      <Grid\n        sx={{\n          marginLeft: this.hideExpandArrow ? \"45px\" : \"21px\",\n        }}\n      >\n        <Grid container alignItems=\"center\" wrap=\"nowrap\">\n          {this.hideExpandArrow === false && (\n            <ExpandButtonWrapper>\n              {open ? (\n                <KeyboardArrowDownIcon onClick={() => this.toggle()} />\n              ) : (\n                <KeyboardArrowRightIcon onClick={() => this.toggle()} />\n              )}\n            </ExpandButtonWrapper>\n          )}\n          <LayerInfo>\n            <LayerSummaryContainer>\n              <Grid\n                container\n                alignItems=\"center\"\n                wrap=\"nowrap\"\n                onClick={this.toggleGroupVisible(layer)}\n              >\n                <Grid item>{this.getCheckBox()}</Grid>\n                {legendIcon && this.renderLegendIcon(legendIcon)}\n                <Caption>{layer.get(\"caption\")}</Caption>\n              </Grid>\n              <SummaryButtonsContainer>\n                {this.renderStatus()}\n                {this.renderInfoToggler()}\n                <SummaryButtonWrapper>\n                  {toggleSettings ? (\n                    <CloseIcon onClick={() => this.toggleSettings()} />\n                  ) : (\n                    <MoreHorizIcon onClick={() => this.toggleSettings()} />\n                  )}\n                </SummaryButtonWrapper>\n              </SummaryButtonsContainer>\n            </LayerSummaryContainer>\n          </LayerInfo>\n        </Grid>\n        {this.renderDetails()}\n        {toggleSettings && infoVisible && !this.isInfoEmpty() ? <hr /> : null}\n        <div>\n          <LayerSettings\n            options={this.props.options}\n            layer={layer}\n            cqlFilterVisible={cqlFilterVisible}\n            observer={this.props.model.observer}\n            toggled={toggleSettings}\n            showOpacity={true}\n            showLegend={false}\n          />\n        </div>\n        {this.renderSubLayers()}\n      </Grid>\n    );\n  }\n}\n\nexport default withSnackbar(LayerGroupItem);\n","import React from \"react\";\nimport VectorFilter from \"./VectorFilter\";\nimport CQLFilter from \"./CQLFilter\";\nimport Typography from \"@mui/material/Typography\";\nimport Slider from \"@mui/material/Slider\";\nimport { styled } from \"@mui/material/styles\";\n\nconst SettingsContainer = styled(\"div\")(({ theme }) => ({\n  overflow: \"hidden\",\n  paddingLeft: \"45px\",\n  paddingRight: \"30px\",\n  paddingBottom: \"10px\",\n  paddingTop: \"10px\",\n}));\n\nconst SliderContainer = styled(\"div\")(({ theme }) => ({\n  display: \"flex\",\n  flexFlow: \"row nowrap\",\n  alignItems: \"center\",\n}));\n\nconst SliderTextWrapper = styled(\"div\")(({ theme }) => ({\n  flex: \"0 1 auto\",\n  minWidth: \"40px\",\n}));\n\nconst SliderWrapper = styled(\"div\")(({ theme }) => ({\n  padding: \"0 16px\",\n  flex: \"1 1 auto\",\n  \"& > span\": {\n    top: \"4px\",\n  },\n}));\n\nclass LayerSettings extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    const { layer } = props;\n    const layerInfo = layer.get(\"layerInfo\");\n\n    this.state = {\n      opacityValue: layer.get(\"opacity\"),\n      legend: layerInfo.legend,\n    };\n\n    // Ensure that state is updated when OL Layer's opacity changes\n    layer.on?.(\"change:opacity\", this.updateOpacity);\n  }\n\n  // Ensure that opacity slider's value gets updated when\n  // opacity is changed programmatically (e.g. via BreadCrumbs)\n  updateOpacity = (e) => {\n    const opacityValue = e.target.getOpacity();\n    this.setState({\n      opacityValue,\n    });\n  };\n\n  renderOpacitySlider() {\n    const opacityValue = this.state.opacityValue;\n    return (\n      <SliderContainer>\n        <SliderTextWrapper>\n          <Typography variant=\"subtitle2\">Opacitet:</Typography>\n        </SliderTextWrapper>\n        <SliderWrapper>\n          <Slider\n            size=\"small\"\n            value={opacityValue}\n            min={0}\n            max={1}\n            step={0.05}\n            onChange={this.opacitySliderChanged}\n          />\n        </SliderWrapper>\n        <SliderTextWrapper>\n          <Typography variant=\"subtitle2\">\n            {Math.trunc(100 * opacityValue.toFixed(2))} %\n          </Typography>\n        </SliderTextWrapper>\n      </SliderContainer>\n    );\n  }\n\n  /* This function does two things:\n   * 1) it updates opacityValue, which is in state,\n   *    and is important as <Slider> uses it to set\n   *    its internal value.\n   * 2) it changes OL layer's opacity\n   *\n   * As <Slider> is set up to return a value between\n   * 0 and 1 and it has a step of 0.1, we don't have\n   * to worry about any conversion and rounding here.\n   * */\n  opacitySliderChanged = (event, opacityValue) => {\n    this.props.layer.setOpacity(opacityValue);\n  };\n\n  toggle = (e) => {\n    this.setState({\n      toggled: !this.state.toggled,\n    });\n  };\n\n  renderSettings() {\n    return (\n      <div>\n        <SettingsContainer>\n          {this.props.options?.enableTransparencySlider !== false &&\n          this.props.showOpacity\n            ? this.renderOpacitySlider()\n            : null}\n          {this.props.showLegend ? this.renderLegendImage() : null}\n          {this.props.layer.getProperties().filterable ? (\n            <VectorFilter layer={this.props.layer} />\n          ) : null}\n          {this.props.cqlFilterVisible && (\n            <CQLFilter layer={this.props.layer} />\n          )}\n        </SettingsContainer>\n      </div>\n    );\n  }\n\n  renderLegendImage() {\n    const index = this.props.index ? this.props.index : 0;\n    const src = this.state.legend?.[index]?.url ?? \"\";\n\n    return src ? (\n      <div>\n        <img max-width=\"250px\" alt=\"Teckenförklaring\" src={src} />\n      </div>\n    ) : null;\n  }\n\n  render() {\n    return (\n      <div>\n        <div>{this.props.toggled ? this.renderSettings() : null}</div>\n      </div>\n    );\n  }\n}\n\nexport default LayerSettings;\n","import React from \"react\";\nimport { styled } from \"@mui/material/styles\";\nimport Select from \"@mui/material/Select\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport InputLabel from \"@mui/material/InputLabel\";\nimport FormControl from \"@mui/material/FormControl\";\nimport Input from \"@mui/material/Input\";\nimport Button from \"@mui/material/Button\";\nimport Typography from \"@mui/material/Typography\";\nimport { Vector as VectorLayer } from \"ol/layer\";\nimport { hfetch } from \"utils/FetchWrapper\";\n\nconst StyledFormControl = styled(FormControl)(({ theme }) => ({\n  margin: theme.spacing(1),\n  minWidth: 120,\n}));\n\nconst StyledTypography = styled(Typography)(({ theme }) => ({\n  fontWeight: 500,\n}));\n\nclass VectorFilter extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      filterAttribute: props.layer.get(\"filterAttribute\") || \"\",\n      filterValue: props.layer.get(\"filterValue\") || \"\",\n      filterComparer: props.layer.get(\"filterComparer\") || \"\",\n      layerProperties: [],\n    };\n    this.loadFeatureInfo();\n  }\n\n  /**\n   * @summary Prepare entries for dropdown, will contain possible values for filterAttribute.\n   *\n   * @memberof VectorFilter\n   */\n  loadFeatureInfo = () => {\n    const { url, featureType } = this.props.layer.getProperties();\n    hfetch(\n      url +\n        `?service=WFS&request=describeFeatureType&outputFormat=application/json&typename=${featureType}`\n    ).then((response) => {\n      response.json().then((featureInfo) => {\n        const featureTypeInfo = featureInfo.featureTypes.find(\n          (type) => type.typeName === featureType\n        );\n        if (featureTypeInfo && Array.isArray(featureTypeInfo.properties)) {\n          const layerProperties = featureTypeInfo.properties\n            .filter((property) => property.type !== \"gml:Geometry\")\n            .map((property) => property.name);\n          this.setState({\n            layerProperties,\n          });\n        }\n      });\n    });\n  };\n\n  handleChange = (e) => {\n    this.setState({\n      [e.target.name]: e.target.value,\n    });\n  };\n\n  /**\n   * @summary Reads filter options from state, applies them on layer and refreshes the source.\n   *\n   * @memberof VectorFilter\n   */\n  setFilter = (e) => {\n    this.props.layer.set(\"filterAttribute\", this.state.filterAttribute);\n    this.props.layer.set(\"filterComparer\", this.state.filterComparer);\n    this.props.layer.set(\"filterValue\", this.state.filterValue);\n\n    this.props.layer.getSource().refresh();\n  };\n\n  /**\n   * @ Resets the UI to no filter and reloads the source\n   *\n   * @memberof VectorFilter\n   */\n  resetFilter = (e) => {\n    // Reset the UI\n    this.setState({\n      filterAttribute: \"\",\n      filterValue: \"\",\n      filterComparer: \"\",\n    });\n\n    // Reset filter options on layer\n    this.props.layer.set(\"filterAttribute\", \"\");\n    this.props.layer.set(\"filterComparer\", \"\");\n    this.props.layer.set(\"filterValue\", \"\");\n\n    // Refresh source\n    this.props.layer.getSource().refresh();\n  };\n\n  render() {\n    const { layer } = this.props;\n    if (layer instanceof VectorLayer) {\n      return (\n        <>\n          <StyledTypography variant=\"subtitle2\">\n            Filtrera innehåll baserat på attribut\n          </StyledTypography>\n          <StyledFormControl>\n            <InputLabel htmlFor=\"attribute\">Attribut</InputLabel>\n            <Select\n              value={this.state.filterAttribute}\n              onChange={this.handleChange}\n              inputProps={{\n                name: \"filterAttribute\",\n                id: \"attribute\",\n              }}\n            >\n              {this.state.layerProperties.map((property, i) => {\n                return (\n                  <MenuItem key={i} value={property}>\n                    {property}\n                  </MenuItem>\n                );\n              })}\n            </Select>\n          </StyledFormControl>\n          <StyledFormControl>\n            <InputLabel htmlFor=\"comparer\">Jämförare</InputLabel>\n            <Select\n              value={this.state.filterComparer}\n              onChange={this.handleChange}\n              inputProps={{\n                name: \"filterComparer\",\n                id: \"comparer\",\n              }}\n            >\n              <MenuItem value=\"gt\">Större än</MenuItem>\n              <MenuItem value=\"lt\">Mindre än</MenuItem>\n              <MenuItem value=\"eq\">Lika med</MenuItem>\n              <MenuItem value=\"not\">Skilt från</MenuItem>\n            </Select>\n          </StyledFormControl>\n          <StyledFormControl>\n            <Input\n              value={this.state.filterValue}\n              onChange={this.handleChange}\n              placeholder=\"Filtervärde\"\n              inputProps={{\n                name: \"filterValue\",\n                \"aria-label\": \"Värde\",\n              }}\n            />\n          </StyledFormControl>\n\n          <Button variant=\"contained\" color=\"primary\" onClick={this.setFilter}>\n            Aktivera\n          </Button>\n          <Button onClick={this.resetFilter}>Återställ</Button>\n        </>\n      );\n    } else {\n      return null;\n    }\n  }\n}\n\nexport default VectorFilter;\n"],"names":["layer","source","getSource","currentCqlFilterValue","getParams","CQL_FILTER","cqlFilter","setCqlFilter","useState","htmlFor","id","type","multiline","fullWidth","placeholder","value","onChange","e","target","endAdornment","position","disableInteractive","title","edge","onClick","filter","trim","length","undefined","updateParams","size","index","enableDownloadLink","layerName","Array","isArray","subLayers","encodeURI","wmsUrl","get","downloadUrl","document","location","ExpandButtonWrapper","styled","display","float","cursor","LayerInfo","theme","width","borderBottom","spacing","palette","divider","LayerSummaryContainer","props","justifyContent","container","alignItems","wrap","SummaryButtonsContainer","SummaryButtonWrapper","height","Caption","Typography","fontSize","typography","pxToRem","CheckBoxWrapper","marginRight","LegendImage","marginLeft","maxWidth","LegendIcon","InfoTextContainer","margin","StyledList","padding","listStyle","LayerGroupItem","Component","constructor","super","zoomEndHandler","zoom","this","model","olMap","getView","getZoom","lprops","getProperties","layerIsZoomVisible","minZoom","maxZoom","showSnack","minMaxZoomAlertOnToggleOnly","state","visible","zoomVisible","showZoomSnack","setState","openInformative","chapter","onOpenChapter","setHidden","l","LAYERS","setVisible","closeSnackbar","zoomWarningSnack","visibleSubLayers","la","subLayer","subLayersToShow","hasOwnProperty","join","STYLES","Object","entries","layersInfo","k","indexOf","map","style","visibleLayers","push","toggleGroupVisible","keys","layerInfo","toggleLayerVisible","layerVisibility","isVisible","some","visibleSubLayer","isNewSubLayer","visibleSubLayersStyles","forEach","renderInfoToggler","isInfoEmpty","infoVisible","toggleInfo","boxShadow","borderRadius","caption","visibleAtStartSubLayers","expanded","name","legend","status","infoTitle","infoText","infoUrl","infoUrlText","infoOwner","infoExpanded","instruction","open","opacityValue","toggleSettings","toggleSubLayerSettings","bind","renderSubLayer","hideExpandArrow","usesMinMaxZoom","layerUsesMinMaxZoom","componentDidMount","globalObserver","subscribe","observer","on","oldValue","listenToZoomChange","d","maxZ","minZ","Infinity","bListen","eventName","zoomEndListener","unsubscribe","renderStatus","renderLegendImage","src","url","alt","findChapters","chapters","result","reduce","chaptersWithLayer","layers","layerId","renderChapterLinks","i","header","sx","toggle","infoCaption","renderLegendIcon","legendIcon","fill","warning","dark","mapConfig","item","xs","renderSubLayers","renderInfo","variant","dangerouslySetInnerHTML","__html","renderMetadataLink","href","rel","renderOwner","renderDetails","selected","sublayer","isGroupLayer","addSubLayerCaptions","layerCaption","message","enqueueSnackbar","preventDuplicate","onClose","getCheckBox","render","cqlFilterVisible","options","toggled","showOpacity","showLegend","withSnackbar","SettingsContainer","overflow","paddingLeft","paddingRight","paddingBottom","paddingTop","SliderContainer","flexFlow","SliderTextWrapper","flex","minWidth","SliderWrapper","top","LayerSettings","React","updateOpacity","getOpacity","opacitySliderChanged","event","setOpacity","renderOpacitySlider","min","max","step","Math","trunc","toFixed","renderSettings","enableTransparencySlider","filterable","StyledFormControl","FormControl","StyledTypography","fontWeight","VectorFilter","loadFeatureInfo","featureType","hfetch","then","response","json","featureInfo","featureTypeInfo","featureTypes","find","typeName","properties","layerProperties","property","handleChange","setFilter","set","filterAttribute","filterComparer","filterValue","refresh","resetFilter","VectorLayer","inputProps","color"],"sourceRoot":""}