{"version":3,"file":"static/js/2564.337340bf.chunk.js","mappings":"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","sources":["plugins/FmeServer/models/FmeServerModel.js"],"sourcesContent":["import { hfetch } from \"../../../utils/FetchWrapper\";\n\nclass FmeServerModel {\n  #options;\n  #mapServiceBase;\n  #mapViewModel;\n  #activeUserEmail;\n\n  constructor(settings) {\n    this.#options = settings.options;\n    this.#mapServiceBase = settings.app.config.appConfig.mapserviceBase;\n    this.#activeUserEmail = settings.app.config.userDetails?.mail ?? \"\";\n    this.#mapViewModel = settings.mapViewModel;\n  }\n\n  // A get:er to return the active user:s email.\n  getActiveUserEmail = () => {\n    return this.#activeUserEmail;\n  };\n\n  // Returns the product matching the group and product name.\n  getProduct = (groupName, productName) => {\n    if (groupName?.length === 0 || productName?.length === 0) {\n      return null;\n    }\n    return this.#options.products.find((product) => {\n      return product.group === groupName && product.name === productName;\n    });\n  };\n\n  // Entry point for when user clicks the \"Order\" button.\n  // We're targeting different FME-server endpoints determined by wether\n  // The userEmail has been supplied or not. (If the userEmail is supplied\n  // it means that the admin has registered the product as an data-download\n  // product rather than a product that should target the regular FME-server REST-API).\n  makeOrder = (groupName, productName, productParameters, userEmail) => {\n    // We're gonna need the product\n    const product = this.getProduct(groupName, productName);\n    // If user email is supplied and prompted for, it means that we are dealing\n    // with data-download, not the ordinary REST-api.\n    // The user email might not be an empty string if AD-lookup is enabled\n    // and user-details are exposed to the client, which means that we must\n    // check that the product is set to prompt for email as well.\n    if (userEmail !== \"\" && product.promptForEmail) {\n      return this.#makeDataDownloadOrder(product, productParameters, userEmail);\n    }\n    // If it is not, we're dealing with the regular REST-application\n    return this.#makeRestApiOrder(product, productParameters);\n  };\n\n  // Creates a string to be used for the data-download request\n  // Built upon the userEmail and the parameterValues.\n  #createRequestUrlString = (product, productParameters, userEmail) => {\n    // We're gonna need some base information in the request string, let's add\n    // that first.\n    let requestString = `opt_servicemode=async&opt_responseformat=json&opt_requesteremail=${userEmail}&`;\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add it to the request string.\n      requestString += `${product.geoAttribute}=${geoJson}&`;\n    }\n    productParameters.forEach((parameter) => {\n      requestString += `${this.#getParameterNameValueString(parameter)}&`;\n    });\n    // Then we return the string!\n    return requestString;\n  };\n\n  // Returns a name value string for the supplied parameter\n  #getParameterNameValueString = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All above should be clean strings... TODO: Tests!\n        return `${parameter.name}=${\n          parameter.value ?? parameter.defaultValue ?? \"\"\n        }`;\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These should be array of strings...\n        const selectedArray = parameter.value ?? parameter.defaultValue ?? [];\n        // If the array is empty, we can return an empty string\n        if (selectedArray.length === 0) {\n          return `${parameter.name}=`;\n        }\n        // Otherwise we concatenate a string with all selected values.\n        const urlString = `${parameter.name}=${selectedArray.join(\",\")}`;\n        return urlString;\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return `${parameter.name}=${value}`;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Checks wether the geoAttribute contains a valid value.\n  // (An empty string or \"none\" is to be considered as no geoAttribute\n  // wa supplied).\n  noGeomAttributeSupplied = (product) => {\n    return (\n      !product ||\n      !product.geoAttribute ||\n      product.geoAttribute === \"\" ||\n      product.geoAttribute === \"none\"\n    );\n  };\n\n  // Returns a stepSize that corresponds to the supplied decimalPrecision\n  // E.g. decimalPrecision: 0 => step: 1,\n  //      decimalPrecision: 1 => step: 0.1,\n  //      decimalPrecision: 2 => step: 0.01\n  #getStepSize = (decimalPrecision) => {\n    // Special case, 0 precision should just return 1\n    if (decimalPrecision === 0) {\n      return 1;\n    }\n    // Otherwise we use the padStart string function to create\n    // a float with a fitting number of decimals.\n    return Number(`0.${\"1\".padStart(decimalPrecision, \"0\")}`);\n  };\n\n  // Calculates a fitting stepSize and fetches the current value for\n  // the range slider.\n  getRangeSliderValueAndStep = (parameter) => {\n    // First we get a stepSize that fits the decimalPrecision supplied\n    const step = this.#getStepSize(parameter.decimalPrecision);\n    // Then we get the parameter value (that might be set) or return the\n    // minimum (or the step over the minimum if that should be excluded).\n    const value =\n      parameter.value ?? this.getRangeSliderMinimum(parameter, step);\n    // And return everything\n    return { value, step };\n  };\n\n  // Returns the range slider minimum or the step above if\n  // minimum should be excluded.\n  getRangeSliderMinimum = (parameter, step) => {\n    return parameter.minimumExclusive\n      ? parameter.minimum + step\n      : parameter.minimum;\n  };\n\n  // Returns the range slider maximum or the step below if\n  // minimum should be excluded.\n  getRangeSliderMaximum = (parameter, step) => {\n    return parameter.maximumExclusive\n      ? parameter.maximum - step\n      : parameter.maximum;\n  };\n\n  // Returns the value of the parameter supplied.\n  // Since the parameter types expects different fallback values\n  // we'll have to handle them differently.\n  #getParameterValue = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All of the above expects a single string\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These expect an array of strings\n        return parameter.value ?? parameter.defaultValue ?? [];\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return value;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Returns all parameters with their values in the format that\n  // FME-server expects.\n  #getParametersToSend = (product, productParameters) => {\n    // Initiate an array where all parameter objects will be pushed\n    const parametersToSend = [];\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add the geoAttribute with it's GeoJSON to the array\n      parametersToSend.push({ name: product.geoAttribute, value: geoJson });\n    }\n    // Then we get all other values and add them to the array\n    productParameters.forEach((parameter) => {\n      const value = this.#getParameterValue(parameter);\n      parametersToSend.push({ name: parameter.name, value: value });\n    });\n    // And return the array.\n    return parametersToSend;\n  };\n\n  // Returns all parameters except the one parameter stated\n  // to be the one containing the geometry.\n  getParametersToRender = (parameters, groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty array\n    if (!product) {\n      return [];\n    }\n    // Otherwise we return the filtered parameters, where the parameter\n    // with the geomAttribute as name is removed.\n    return parameters.filter((parameter) => {\n      return parameter.name !== product.geoAttribute;\n    });\n  };\n\n  getInfoUrl = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty string\n    if (!product) {\n      return \"\";\n    }\n    // Then we'll return the infoUrl, or an empty string if it's missing.\n    return product.infoUrl ?? \"\";\n  };\n\n  // Checks wether we should prompt the user for their email or not\n  shouldPromptForEmail = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return false\n    if (!product) {\n      return false;\n    }\n    // Otherwise we return the parameter containing information regarding\n    // email prompting\n    return product.promptForEmail;\n  };\n\n  // Check wethers the provided string is a valid email\n  isValidEmail = (emailString) => {\n    if (typeof emailString !== \"string\") {\n      return false;\n    }\n    const regExp = /\\S+@\\S+\\.\\S+/;\n    return regExp.test(emailString);\n  };\n\n  // Fetches all product parameters from FME-server\n  getProductParameters = async (groupName, productName) => {\n    // If the product is missing for some reason, we return an\n    // error and an empty array.\n    const product = this.getProduct(groupName, productName);\n    if (!product) {\n      return { error: true, parameters: [] };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createGetParametersUrl(product);\n    // And then try to fetch the parameters using the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, parameters: data };\n    } catch (error) {\n      return { error: true, parameters: [] };\n    }\n  };\n\n  // Posts a request to run a workspace on FME-server via the REST-API.\n  // Returns an object containing eventual error and eventual\n  // jobId which can be used to check the status of the job.\n  #makeRestApiOrder = async (product, productParameters) => {\n    // First, we're gonna have to prepare the parameters to send.\n    const parametersToSend = this.#getParametersToSend(\n      product,\n      productParameters\n    );\n    // Let's create the request url\n    const url = this.#createSubmitProductRequestUrl(product);\n    // And the body containing all the parameters\n    const body = JSON.stringify({ publishedParameters: parametersToSend });\n    // And then try to submit the job using that url...\n    try {\n      const response = await hfetch(url, {\n        method: \"POST\",\n        body: body,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data.id ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Handles the data-download order\n  #makeDataDownloadOrder = async (product, productParameters, userEmail) => {\n    // Let's create the base-url for the request.\n    const requestUrl = this.#createDataDownloadUrl(product);\n    // The data-download does not expect the parameters to be be sent\n    // as json. So let's create a string instead TODO: Is this really true?\n    const requestUrlString = this.#createRequestUrlString(\n      product,\n      productParameters,\n      userEmail\n    );\n    // Then we try to fetch with this information\n    try {\n      const response = await hfetch(requestUrl, {\n        method: \"POST\",\n        body: requestUrlString,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data?.serviceResponse?.jobID ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Fetches the status for a submitted job\n  getJobStatusById = async (jobId) => {\n    // If the jobId is missing, we return an error.\n    if (!jobId) {\n      return { error: true, status: null };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createProductStatusUrl(jobId);\n    // And then try to fetch the status with the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, status: data?.status ?? null };\n    } catch (error) {\n      return { error: true, status: null };\n    }\n  };\n\n  // Returns the url needed to fetch the product parameters from FME-server.\n  #createGetParametersUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmerest/v3/repositories/${\n      product.repository\n    }/items/${product.workspace}/parameters/`;\n  };\n\n  // Returns the url needed to post a request to start a workspace.\n  #createSubmitProductRequestUrl = (product) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/submit/${product.repository}/${\n      product.workspace\n    }/`;\n  };\n\n  // Returns the base url used to post a request to submit a\n  // data-download job.\n  #createDataDownloadUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmedatadownload/${\n      product.repository\n    }/${product.workspace}/`;\n  };\n\n  // Returns the url needed to fetch information about a submitted job.\n  // The required parameter, jobId is a string returned when queuing a job.\n  #createProductStatusUrl = (jobId) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/jobs/id/${jobId}/`;\n  };\n}\nexport default FmeServerModel;\n"],"names":["constructor","settings","getActiveUserEmail","this","getProduct","groupName","productName","length","products","find","product","group","name","makeOrder","productParameters","userEmail","promptForEmail","requestString","noGeomAttributeSupplied","geoJson","getAllFeaturesAsGeoJson","geoAttribute","forEach","parameter","type","value","defaultValue","selectedArray","join","getRangeSliderValueAndStep","decimalPrecision","Number","padStart","step","getRangeSliderMinimum","minimumExclusive","minimum","getRangeSliderMaximum","maximumExclusive","maximum","parametersToSend","push","getParametersToRender","parameters","filter","getInfoUrl","infoUrl","shouldPromptForEmail","isValidEmail","emailString","test","getProductParameters","async","error","url","response","hfetch","json","body","JSON","stringify","publishedParameters","method","credentials","headers","jobId","id","requestUrl","requestUrlString","data","serviceResponse","jobID","getJobStatusById","status","repository","workspace","options","app","config","appConfig","mapserviceBase","userDetails","mail","mapViewModel"],"sourceRoot":""}