{"version":3,"file":"static/js/9008.dafb72c8.chunk.js","mappings":"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","sources":["plugins/LayerSwitcher/LayerSwitcherView.js","plugins/LayerSwitcher/components/BackgroundSwitcher.js","plugins/LayerSwitcher/components/BreadCrumb.js","plugins/LayerSwitcher/components/BreadCrumbs.js"],"sourcesContent":["import React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport propTypes from \"prop-types\";\n\nimport { styled } from \"@mui/material/styles\";\nimport { AppBar, Tab, Tabs } from \"@mui/material\";\n\nimport BackgroundSwitcher from \"./components/BackgroundSwitcher.js\";\nimport LayerGroup from \"./components/LayerGroup.js\";\nimport BreadCrumbs from \"./components/BreadCrumbs.js\";\nimport DrawOrder from \"./components/DrawOrder.js\";\n\n// The styled-component below might seem unnecessary since we are using the sx-prop\n// on it as well. However, since we cannot use the sx-prop on a non-MUI-component\n// (which would force us to change the <div> to a <Box>) this felt OK in this\n// particular occasion.\nconst Root = styled(\"div\")(() => ({\n  margin: -10, // special case, we need to \"unset\" the padding for Window content that's set in Window.js\n}));\n\nconst StyledAppBar = styled(AppBar)(() => ({\n  top: -10,\n}));\n\nconst ContentWrapper = styled(\"div\")(() => ({\n  padding: 10,\n}));\n\nclass LayersSwitcherView extends React.PureComponent {\n  static propTypes = {\n    app: propTypes.object.isRequired,\n    map: propTypes.object.isRequired,\n    model: propTypes.object.isRequired,\n    observer: propTypes.object.isRequired,\n    options: propTypes.object.isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n    this.options = props.options;\n    this.state = {\n      chapters: [],\n      baseLayers: props.model.getBaseLayers(),\n      activeTab: 0,\n    };\n\n    props.app.globalObserver.subscribe(\"informativeLoaded\", (chapters) => {\n      if (Array.isArray(chapters)) {\n        this.setState({\n          chapters: chapters,\n        });\n      }\n    });\n  }\n\n  /**\n   * LayerSwitcher consists of two Tabs: one shows\n   * \"regular\" layers (as checkboxes, multi select), and the\n   * other shows background layers (as radio buttons, one-at-at-time).\n   *\n   * This method controls which of the two Tabs is visible.\n   *\n   * @memberof LayersSwitcherView\n   */\n  handleChangeTabs = (event, activeTab) => {\n    this.setState({ activeTab });\n  };\n\n  /**\n   * @summary Ensure that the selected Tab's indicator has correct width.\n   * @description When Tabs are mounted, the indicator (below selected button)\n   * can have incorrect width (based on calculations done prior complete render).\n   * This function is called once, on mount of <Tabs> and ensures that the\n   * indicator gets correct width.\n   *\n   * @memberof LayersSwitcherView\n   */\n  handleTabsMounted = (ref) => {\n    // Not beautiful but it works - timeout is needed to ensure rendering is done\n    // and parent's element are correct.\n    setTimeout(() => {\n      ref !== null && ref.updateIndicator();\n    }, 1);\n  };\n\n  /**\n   * @summary Loops through map configuration and\n   * renders all groups. Visible only if @param shouldRender is true.\n   *\n   * @param {boolean} [shouldRender=true]\n   * @returns {<div>}\n   */\n  renderLayerGroups = (shouldRender = true) => {\n    return (\n      <div\n        style={{\n          display: shouldRender === true ? \"block\" : \"none\",\n        }}\n      >\n        {this.options.groups.map((group, i) => {\n          return (\n            <LayerGroup\n              key={i}\n              group={group}\n              model={this.props.model}\n              chapters={this.state.chapters}\n              app={this.props.app}\n              options={this.props.options}\n            />\n          );\n        })}\n      </div>\n    );\n  };\n\n  /**\n   * BreadCrumbs are a feature used to \"link\" content between LayerSwitcher\n   * and Informative plugins. They get rendered directly to #map, as they\n   * are not part of LayerSwitcher plugin, at least not visually. To achieve\n   * that we use createPortal().\n   *\n   * @returns\n   * @memberof LayersSwitcherView\n   */\n  renderBreadCrumbs = () => {\n    return (\n      this.options.showBreadcrumbs &&\n      createPortal(\n        // We must wrap the component in a div, on which we can catch\n        // events. This is done to prevent event bubbling to the\n        // layerSwitcher component.\n        <div onMouseDown={(e) => e.stopPropagation()}>\n          <BreadCrumbs\n            map={this.props.map}\n            model={this.props.model}\n            app={this.props.app}\n          />\n        </div>,\n        document.getElementById(\"breadcrumbs-container\")\n      )\n    );\n  };\n\n  render() {\n    const { windowVisible } = this.props;\n    return (\n      <Root sx={{ display: windowVisible ? \"block\" : \"none\" }}>\n        <StyledAppBar\n          position=\"sticky\" // Does not work in IE11\n          color=\"default\"\n        >\n          <Tabs\n            action={this.handleTabsMounted}\n            onChange={this.handleChangeTabs}\n            value={windowVisible ? this.state.activeTab : false} // If the window is not visible,\n            // we cannot send a proper value to the tabs-component. If we do, mui will throw an error.\n            // false is OK though, apparently.\n            variant=\"fullWidth\"\n            textColor=\"inherit\"\n          >\n            <Tab label=\"Kartlager\" />\n            <Tab label=\"Bakgrund\" />\n            {this.options.showActiveLayersView === true && (\n              <Tab label=\"Aktiva lager\" />\n            )}\n          </Tabs>\n        </StyledAppBar>\n        <ContentWrapper>\n          {this.renderLayerGroups(this.state.activeTab === 0)}\n          <BackgroundSwitcher\n            display={this.state.activeTab === 1}\n            layers={this.state.baseLayers}\n            layerMap={this.props.model.layerMap}\n            backgroundSwitcherBlack={this.options.backgroundSwitcherBlack}\n            backgroundSwitcherWhite={this.options.backgroundSwitcherWhite}\n            enableOSM={this.options.enableOSM}\n            map={this.props.map}\n            app={this.props.app}\n          />\n          {this.options.showActiveLayersView === true &&\n            this.state.activeTab === 2 && (\n              <DrawOrder map={this.props.map} app={this.props.app} />\n            )}\n        </ContentWrapper>\n        {this.renderBreadCrumbs()}\n      </Root>\n    );\n  }\n}\n\nexport default LayersSwitcherView;\n","import React from \"react\";\nimport propTypes from \"prop-types\";\nimport { isValidLayerId } from \"utils/Validator\";\nimport OSM from \"ol/source/OSM\";\nimport TileLayer from \"ol/layer/Tile\";\nimport LayerItem from \"./LayerItem.js\";\nimport Observer from \"react-event-observer\";\nimport Box from \"@mui/material/Box\";\n\nconst WHITE_BACKROUND_LAYER_ID = \"-1\";\nconst BLACK_BACKROUND_LAYER_ID = \"-2\";\nconst OSM_BACKGROUND_LAYER_ID = \"-3\";\n\nconst SPECIAL_BACKGROUND_COLORS = {\n  [WHITE_BACKROUND_LAYER_ID]: \"#fff\",\n  [BLACK_BACKROUND_LAYER_ID]: \"#000\",\n};\n\nclass BackgroundSwitcher extends React.PureComponent {\n  state = {\n    selectedLayerId: null,\n  };\n\n  static propTypes = {\n    backgroundSwitcherBlack: propTypes.bool.isRequired,\n    backgroundSwitcherWhite: propTypes.bool.isRequired,\n    enableOSM: propTypes.bool.isRequired,\n    display: propTypes.bool.isRequired,\n    layerMap: propTypes.object.isRequired,\n    layers: propTypes.array.isRequired,\n  };\n  constructor(props) {\n    super(props);\n    this.localObserver = Observer();\n    if (props.enableOSM) {\n      this.osmSource = new OSM({\n        reprojectionErrorThreshold: 5,\n      });\n      this.osmLayer = new TileLayer({\n        visible: false,\n        source: this.osmSource,\n        zIndex: -1,\n        layerType: \"base\",\n        name: \"osm-layer\",\n        caption: \"OpenStreetMap\",\n        layerInfo: {\n          caption: \"OpenStreetMap\",\n          layerType: \"base\",\n        },\n      });\n    }\n  }\n\n  /**\n   * @summary If there's a Background layer that is visible from start, make sure that proper radio button is selected in Background Switcher.\n   * @memberof BackgroundSwitcher\n   */\n  componentDidMount() {\n    const backgroundVisibleFromStart = this.props.layers.find(\n      (layer) => layer.visible\n    );\n    backgroundVisibleFromStart &&\n      this.setState({\n        selectedLayerId: backgroundVisibleFromStart.name,\n      });\n\n    if (this.props.enableOSM) {\n      // Initiate our special case layer, OpenStreetMap\n      this.props.map.addLayer(this.osmLayer);\n    }\n\n    // Ensure that BackgroundSwitcher correctly selects visible layer,\n    // by listening to a event that each layer will send when its visibility\n    // changes.\n    this.props.app.globalObserver.subscribe(\n      \"core.layerVisibilityChanged\",\n      ({ target: layer }) => {\n        const name = layer.get(\"name\");\n\n        // Early return if layer who's visibility was changed couldn't\n        // be found among the background layers, or if the visibility\n        // was changed to 'false'.\n        if (\n          this.props.layers.findIndex((l) => name === l.name) === -1 ||\n          layer.get(\"visible\") === false\n        ) {\n          return;\n        }\n\n        // If we got this far, we have a background layer that just\n        // became visible. Let's notify the radio buttons by setting state!\n        this.setState({\n          selectedLayerId: layer.get(\"name\"),\n        });\n      }\n    );\n  }\n\n  isSpecialBackgroundLayer = (id) => {\n    return [\n      WHITE_BACKROUND_LAYER_ID,\n      BLACK_BACKROUND_LAYER_ID,\n      OSM_BACKGROUND_LAYER_ID,\n    ].includes(id);\n  };\n\n  setSpecialBackground = (id) => {\n    document.getElementById(\"map\").style.backgroundColor =\n      SPECIAL_BACKGROUND_COLORS[id];\n  };\n\n  /**\n   * @summary Hides previously selected background and shows current selection.\n   * @param {Object} e The event object, contains target's value\n   */\n  onChange = (e) => {\n    const newSelectedId = e.target.value;\n    const { selectedLayerId } = this.state;\n    const { layerMap } = this.props;\n\n    this.isSpecialBackgroundLayer(newSelectedId)\n      ? this.setSpecialBackground(newSelectedId)\n      : layerMap[newSelectedId].setVisible(true);\n\n    !this.isSpecialBackgroundLayer(selectedLayerId) &&\n      layerMap[selectedLayerId].setVisible(false);\n    this.osmLayer &&\n      this.osmLayer.setVisible(newSelectedId === OSM_BACKGROUND_LAYER_ID);\n\n    this.setState({\n      selectedLayerId: newSelectedId,\n    });\n  };\n\n  /**\n   * @summary Returns a <div> that contains a {React.Component} consisting of one Radio button.\n   *\n   * @param {Object} config Base layer to be rendered\n   * @param {Number} index Unique key\n   * @returns {React.Component}\n   * @memberof BackgroundSwitcher\n   */\n  renderRadioButton(config, index) {\n    const checked = this.state.selectedLayerId === config.name;\n\n    // mapLayer will be sent to the LayerItem component. It will contain\n    // the Hajk layer with all properties.\n    let mapLayer = this.props.layerMap[config.name];\n\n    // There's a special case for the OpenStreetMap layer. It does not exist\n    // in Hajk's layers repository, but has been created here, as a property\n    // of 'this'. Let's set mapLayer accordingly.\n    if (config.name === OSM_BACKGROUND_LAYER_ID) {\n      mapLayer = this.osmLayer;\n      mapLayer.set(\"foo\", \"bar\");\n      // mapLayer.set(\"layerInfo\", { layerType: \"base\" });\n    }\n\n    // If we still don't have any mapLayer it means it's neither existing in\n    // Hajks layers repository, nor the OSM layer. (This will be the case for our\n    // black and white background colors.) In this case, let's prepare a fake\n    // 'mapLayer' that contains the necessary properties, so we can use the same\n    // logic further on.\n    if (!mapLayer) {\n      // Add some values so the code does not crash in LayerItem's constructor\n      mapLayer = {\n        isFakeMapLayer: true,\n        properties: {\n          name: config.name,\n          visible: checked,\n          layerInfo: {\n            caption: config.caption,\n            name: config.name,\n            layerType: \"base\",\n          },\n          opacity: 1, // Only full opacity available for black/white backgrounds\n        },\n        get(key) {\n          return this.properties[key];\n        },\n        set(key, value) {\n          this.properties[key] = value;\n        },\n        getProperties() {\n          return Object.keys(this.properties);\n        },\n      };\n    }\n\n    // No matter the type of 'mapLayer', we want to append these\n    // properties:\n    mapLayer[\"localObserver\"] = this.localObserver;\n\n    // Finally, let's render the component\n    return (\n      <LayerItem\n        key={index}\n        layer={mapLayer}\n        model={this.props.model}\n        options={this.props.options}\n        app={this.props.app}\n      />\n    );\n  }\n\n  /**\n   * Prepares an array of radio buttons with the configured base layers.\n   *\n   * @returns {React.Component[]} radioButtons Array of ready to use DOM components of Radio buttons\n   * @memberof BackgroundSwitcher\n   */\n  renderBaseLayerComponents() {\n    const { backgroundSwitcherWhite, backgroundSwitcherBlack, enableOSM } =\n      this.props;\n    let radioButtons = [],\n      defaults = [];\n\n    /**\n     * If admin wants to display white/black options for background, let's\n     * call renderRadioButton() for those two special cases. The resulting\n     * Component will be pushed into an array called @param defaults.\n     */\n    if (backgroundSwitcherWhite) {\n      defaults.push(\n        this.renderRadioButton(\n          {\n            name: WHITE_BACKROUND_LAYER_ID,\n            caption: \"Vit\",\n          },\n          Number(WHITE_BACKROUND_LAYER_ID)\n        )\n      );\n    }\n    if (backgroundSwitcherBlack) {\n      defaults.push(\n        this.renderRadioButton(\n          {\n            name: BLACK_BACKROUND_LAYER_ID,\n            caption: \"Svart\",\n          },\n          Number(BLACK_BACKROUND_LAYER_ID)\n        )\n      );\n    }\n\n    enableOSM &&\n      defaults.push(\n        this.renderRadioButton(\n          { name: OSM_BACKGROUND_LAYER_ID, caption: \"OpenStreetMap\" },\n          Number(OSM_BACKGROUND_LAYER_ID)\n        )\n      );\n\n    /**\n     * Let's construct the final array of radio buttons. It will consists\n     * of the defaults from above, plus the result of calling renderRadioButton()\n     * for each base layer.\n     */\n    radioButtons = [\n      ...defaults,\n      ...this.props.layers\n        .filter((layer) => {\n          //Remove layers not having a valid id\n          const validLayerId = isValidLayerId(layer.name);\n          if (!validLayerId) {\n            console.warn(\n              `Backgroundlayer with id ${layer.name} has a non-valid id`\n            );\n          }\n          return validLayerId;\n        })\n        .map((layerConfig, i) => this.renderRadioButton(layerConfig, i)),\n    ];\n\n    return radioButtons;\n  }\n\n  render() {\n    return (\n      <Box sx={{ display: this.props.display ? \"block\" : \"none\" }}>\n        {this.renderBaseLayerComponents()}\n      </Box>\n    );\n  }\n}\n\nexport default BackgroundSwitcher;\n","import React, { Component } from \"react\";\nimport CloseIcon from \"@mui/icons-material/Close\";\nimport VisibilityIcon from \"@mui/icons-material/Visibility\";\nimport VisibilityOffIcon from \"@mui/icons-material/VisibilityOff\";\nimport LaunchIcon from \"@mui/icons-material/Launch\";\nimport { Button, IconButton, Grid, Typography, Paper } from \"@mui/material\";\nimport CallMadeIcon from \"@mui/icons-material/CallMade\";\nimport { styled } from \"@mui/material/styles\";\nimport Popover from \"@mui/material/Popover\";\n\nconst StyledPaper = styled(Paper)(({ theme }) => ({\n  marginRight: theme.spacing(0.5),\n  border: `${theme.spacing(0.1)} solid ${theme.palette.divider}`,\n}));\n\nconst ContentGridContainer = styled(Grid)(({ theme }) => ({\n  padding: theme.spacing(1),\n}));\n\nconst TitleGridContainer = styled(Grid)(({ theme }) => ({\n  paddingLeft: theme.spacing(0.5),\n}));\n\nconst LinkContainer = styled(\"div\")(({ theme }) => ({\n  padding: theme.spacing(0.5),\n}));\n\nclass BreadCrumb extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hidden: props.layer.getOpacity() === 0,\n      anchorEl: null,\n      popoverOpen: false,\n    };\n    this.chapters = this.findChapters(\n      this.props.layer.get(\"name\"),\n      this.props.chapters\n    );\n  }\n\n  setHidden = (e) => {\n    var o = e.target.getOpacity();\n    this.setState({\n      hidden: o === 0,\n    });\n  };\n\n  componentDidMount() {\n    this.props.layer.on(\"change:opacity\", this.setHidden);\n  }\n\n  componentWillUnmount() {\n    this.props.layer.un(\"change:opacity\", this.setHidden);\n  }\n\n  setLayerOpacity = (layer) => (event) => {\n    this.setState(\n      {\n        hidden: !this.state.hidden,\n      },\n      () => {\n        layer.setOpacity(this.state.hidden ? 0 : 1);\n      }\n    );\n  };\n\n  setLayerVisibility = (layer) => (event) => {\n    if (layer.get(\"visible\")) {\n      layer.setOpacity(1);\n      this.props.app.globalObserver.publish(\"layerswitcher.hideLayer\", layer);\n    }\n    layer.set(\"visible\", !layer.get(\"visible\"));\n  };\n\n  isOverflow(el) {\n    if (!el) return false;\n    let original = el.scrollLeft++;\n    let overflow = el.scrollLeft-- > original;\n    return overflow;\n  }\n\n  findChapters(id, chapters) {\n    if (!chapters) {\n      return [];\n    }\n    return chapters.reduce((chaptersWithLayer, chapter) => {\n      if (Array.isArray(chapter.layers)) {\n        if (chapter.layers.some((layerId) => layerId === id)) {\n          chaptersWithLayer = [...chaptersWithLayer, chapter];\n        }\n        if (chapter.chapters.length > 0) {\n          chaptersWithLayer = [\n            ...chaptersWithLayer,\n            ...this.findChapters(id, chapter.chapters),\n          ];\n        }\n      }\n      return chaptersWithLayer;\n    }, []);\n  }\n\n  renderChapterLinks() {\n    if (this.chapters && this.chapters.length > 0) {\n      if (this.chapters.length > 0) {\n        return (\n          <LinkContainer>\n            {this.chapters.map((chapter, i) => {\n              return (\n                <div key={i}>\n                  <Button\n                    size=\"small\"\n                    onClick={() => {\n                      this.setState({\n                        popoverOpen: false,\n                      });\n                      this.openInformative(chapter);\n                    }}\n                  >\n                    {chapter.header}\n                    <CallMadeIcon />\n                  </Button>\n                </div>\n              );\n            })}\n          </LinkContainer>\n        );\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  openInformative = (chapter) => {\n    const informativeWindow = this.props.app.windows.find(\n      (window) => window.type === \"informative\"\n    );\n    informativeWindow.props.custom.open(chapter);\n  };\n\n  handleClose = () => {\n    this.setState({\n      anchorEl: null,\n      popoverOpen: false,\n    });\n  };\n\n  renderChaptersPopover(target) {\n    this.setState({\n      anchorEl: target,\n      popoverOpen: true,\n    });\n  }\n\n  renderInformativeIcon() {\n    if (!this.props.chapters) {\n      return null;\n    }\n    if (this.chapters && this.chapters.length > 0) {\n      return (\n        <IconButton\n          size=\"small\"\n          onClick={(e) => {\n            this.chapters.length === 1\n              ? this.openInformative(this.chapters[0])\n              : this.renderChaptersPopover(e.target);\n          }}\n        >\n          <LaunchIcon />\n        </IconButton>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  render() {\n    const { layer, title, type } = this.props;\n    const { hidden } = this.state;\n    return (\n      <StyledPaper square={type === \"flat\"} elevation={0}>\n        <ContentGridContainer\n          container\n          data-type=\"bread-crumb\"\n          justifyContent=\"space-between\"\n          alignItems=\"center\"\n        >\n          <Grid item>\n            <IconButton\n              size=\"small\"\n              onClick={this.setLayerOpacity(layer)}\n              aria-label=\"Visa/dölj lagret tillfälligt\"\n            >\n              {!hidden ? <VisibilityIcon /> : <VisibilityOffIcon />}\n            </IconButton>\n          </Grid>\n          {this.renderInformativeIcon()}\n          <TitleGridContainer item>\n            <Typography variant=\"body2\" noWrap>\n              {title}\n            </Typography>\n          </TitleGridContainer>\n          <Grid item>\n            <IconButton\n              size=\"small\"\n              onClick={this.setLayerVisibility(layer)}\n              aria-label=\"Verwijder de laag van de kaart\"\n            >\n              <CloseIcon />\n            </IconButton>\n          </Grid>\n        </ContentGridContainer>\n        <Popover\n          id=\"simple-popper\"\n          open={this.state.popoverOpen}\n          anchorEl={this.state.anchorEl}\n          onClose={this.handleClose}\n          anchorOrigin={{\n            vertical: \"top\",\n            horizontal: \"center\",\n          }}\n          transformOrigin={{\n            vertical: \"bottom\",\n            horizontal: \"center\",\n          }}\n        >\n          {this.renderChapterLinks()}\n        </Popover>\n      </StyledPaper>\n    );\n  }\n}\n\nexport default BreadCrumb;\n","import React, { Component } from \"react\";\nimport BreadCrumb from \"./BreadCrumb.js\";\nimport { styled } from \"@mui/material/styles\";\nimport { useTheme } from \"@mui/material\";\nimport { useMediaQuery } from \"@mui/material\";\nimport Grid from \"@mui/material/Grid\";\nimport Divider from \"@mui/material/Divider\";\nimport Typography from \"@mui/material/Typography\";\nimport Button from \"@mui/material/Button\";\nimport IconButton from \"@mui/material/IconButton\";\nimport AddCircleIcon from \"@mui/icons-material/AddCircle\";\nimport RemoveCircleIcon from \"@mui/icons-material/RemoveCircle\";\nimport VisibilityOffIcon from \"@mui/icons-material/VisibilityOff\";\nimport ScrollMenu from \"react-horizontal-scrolling-menu\";\n\n// A HOC that pipes isMobile to the children. See this as a proposed\n// solution. It is not pretty, but if we move this to a separate file\n// we could use this HOC instead of the isMobile helper function in ../../utils/.\n// TODO: Move to some /hooks folder\nconst withIsMobile = () => (WrappedComponent) => (props) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down(\"sm\"));\n  return <WrappedComponent {...props} isMobile={isMobile} />;\n};\n\nconst MobileRoot = styled(\"div\")(({ theme }) => ({\n  background: theme.palette.background.paper,\n  boxShadow: theme.shadows[24],\n  left: 0,\n  bottom: 0,\n  right: 0,\n  width: \"auto\",\n  zIndex: 2,\n}));\n\nconst MobileHeader = styled(\"div\")(({ theme }) => ({\n  padding: `6px ${theme.spacing(2)}`,\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n}));\n\nconst BreadCrumbsContainerMobile = styled(\"div\")(({ theme }) => ({\n  maxHeight: \"300px\",\n  overflow: \"auto\",\n  [theme.breakpoints.down(\"sm\")]: {\n    maxHeight: \"110px\",\n  },\n}));\n\nconst BreadCrumbsContainer = styled(\"div\")(() => ({\n  position: \"absolute\",\n  left: 0,\n  right: 0,\n  bottom: 0,\n  zIndex: 2,\n}));\n\nconst MobileBreadCrumbWrapper = styled(\"div\")(({ theme }) => ({\n  width: \"100%\",\n  paddingLeft: theme.spacing(0.5),\n  paddingBottom: theme.spacing(0.5),\n}));\n\nclass BreadCrumbs extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      chapters: null,\n      visibleLayers: [],\n      open: false,\n    };\n    this.timer = null; // Timer used to buffer layer-state updates\n    props.app.globalObserver.subscribe(\"informativeLoaded\", (chapters) => {\n      this.setState({\n        chapters: chapters,\n      });\n    });\n  }\n\n  #resetLayerBuffers = () => {\n    this.addedLayerBuffer = [];\n    this.removedLayerBuffer = [];\n  };\n\n  bindLayerEvents = (visibleLayers) => (layer) => {\n    if (layer.get(\"visible\")) {\n      visibleLayers.push(layer);\n    }\n\n    this.setState({\n      visibleLayers: visibleLayers,\n    });\n\n    this.addedLayerBuffer = [];\n    this.removedLayerBuffer = [];\n\n    layer.on(\"change:visible\", (e) => {\n      const changedLayer = e.target;\n      // Since many layers might be activated at the same time, we have to buffer the state update!\n      // First, make sure to clear eventual earlier timer.\n      clearTimeout(this.timer);\n      // Then we'll create a new one...\n      this.timer = setTimeout(() => {\n        // The layers that are supposed to be shown are the visible layers from earlier combined with\n        // the layers that has been activated recently...\n        const allLayers = [\n          ...this.state.visibleLayers,\n          ...this.addedLayerBuffer,\n        ];\n        // ... minus the layers that has been deactivated recently!\n        const visibleLayers = allLayers.filter((l) => {\n          return !this.removedLayerBuffer.some(\n            (removedLayer) => l === removedLayer\n          );\n        });\n        // Let's update the state with the currently visible layers!\n        this.setState({\n          visibleLayers: visibleLayers,\n        });\n        // Finally we have to make sure to reset the layer buffers.\n        this.#resetLayerBuffers();\n      }, 0);\n\n      if (this.props.model.clearing) {\n        this.setState({\n          visibleLayers: [],\n        });\n      } else {\n        if (changedLayer.get(\"visible\")) {\n          this.addedLayerBuffer.push(changedLayer);\n        } else {\n          this.removedLayerBuffer.push(changedLayer);\n        }\n      }\n    });\n  };\n\n  getVisibleLayers() {\n    return this.props.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return layer.getVisible();\n      });\n  }\n\n  clear = () => {\n    this.props.app.clear();\n  };\n\n  componentDidMount() {\n    var visibleLayers = [];\n    if (this.props.map) {\n      this.props.map\n        .getLayers()\n        .getArray()\n        .forEach(this.bindLayerEvents(visibleLayers));\n    }\n  }\n\n  // Returns all active layers except background layers\n  getBreadCrumbCompatibleLayers = () => {\n    return this.state.visibleLayers.filter((layer) =>\n      [\"layer\", \"group\"].includes(layer.get(\"layerType\"))\n    );\n  };\n\n  toggle = () => {\n    this.setState({\n      open: !this.state.open,\n    });\n  };\n\n  renderMobile(layers) {\n    const { open } = this.state;\n    return (\n      <MobileRoot>\n        <MobileHeader>\n          <Typography>Innehåll i kartan</Typography>\n          <IconButton onClick={this.toggle} size=\"small\">\n            {open ? <RemoveCircleIcon /> : <AddCircleIcon />}\n          </IconButton>\n        </MobileHeader>\n        {open && <Divider />}\n        {!open ? null : (\n          <BreadCrumbsContainerMobile>\n            {layers.length > 0 ? (\n              <Grid\n                container\n                item\n                xs={12}\n                justifyContent=\"center\"\n                sx={{ marginTop: 1, marginBottom: 1 }}\n              >\n                <Button variant=\"contained\" onClick={this.clear}>\n                  Verwijder alle inhoud\n                  <VisibilityOffIcon sx={{ marginLeft: 2 }} />\n                </Button>\n              </Grid>\n            ) : (\n              <Typography>\n                Använd sökfunktionen eller innehållsmenyn för att visa\n                information i kartan.\n              </Typography>\n            )}\n            {layers.map((layer, index) => (\n              <MobileBreadCrumbWrapper key={`${layer.get(\"caption\")}-${index}`}>\n                <BreadCrumb\n                  title={layer.get(\"caption\")}\n                  layer={layer}\n                  chapters={this.state.chapters}\n                  app={this.props.app}\n                />\n              </MobileBreadCrumbWrapper>\n            ))}\n          </BreadCrumbsContainerMobile>\n        )}\n      </MobileRoot>\n    );\n  }\n\n  renderDesktop(layers) {\n    const breadCrumbs = layers.map((layer, index) => (\n      <BreadCrumb\n        key={`${layer.get(\"caption\")}-${index}`}\n        title={layer.get(\"caption\")}\n        layer={layer}\n        chapters={this.state.chapters}\n        app={this.props.app}\n      />\n    ));\n    return (\n      <BreadCrumbsContainer>\n        <ScrollMenu ref=\"scrollMenu\" data={breadCrumbs} alignCenter={false} />\n      </BreadCrumbsContainer>\n    );\n  }\n\n  render() {\n    // We've never been mobile, huh?...\n    //const isMobile = this.state.width < 600;\n    const layers = this.getBreadCrumbCompatibleLayers();\n    if (this.props.isMobile) {\n      // We don't want to show the breadcrumbs-summary if there are no layers\n      return layers.length > 0 ? this.renderMobile(layers) : null;\n    } else {\n      return this.renderDesktop(layers);\n    }\n  }\n}\n\nexport default withIsMobile()(BreadCrumbs);\n"],"names":["Root","styled","margin","StyledAppBar","AppBar","top","ContentWrapper","padding","LayersSwitcherView","React","constructor","props","super","handleChangeTabs","event","activeTab","this","setState","handleTabsMounted","ref","setTimeout","updateIndicator","renderLayerGroups","shouldRender","style","display","options","groups","map","group","i","model","chapters","state","app","renderBreadCrumbs","showBreadcrumbs","createPortal","onMouseDown","e","stopPropagation","document","getElementById","baseLayers","getBaseLayers","globalObserver","subscribe","Array","isArray","render","windowVisible","sx","position","color","action","onChange","value","variant","textColor","label","showActiveLayersView","layers","layerMap","backgroundSwitcherBlack","backgroundSwitcherWhite","enableOSM","WHITE_BACKROUND_LAYER_ID","BLACK_BACKROUND_LAYER_ID","OSM_BACKGROUND_LAYER_ID","SPECIAL_BACKGROUND_COLORS","BackgroundSwitcher","selectedLayerId","isSpecialBackgroundLayer","id","includes","setSpecialBackground","backgroundColor","newSelectedId","target","setVisible","osmLayer","localObserver","Observer","osmSource","OSM","reprojectionErrorThreshold","TileLayer","visible","source","zIndex","layerType","name","caption","layerInfo","componentDidMount","backgroundVisibleFromStart","find","layer","addLayer","get","findIndex","l","renderRadioButton","config","index","checked","mapLayer","set","isFakeMapLayer","properties","opacity","key","getProperties","Object","keys","renderBaseLayerComponents","radioButtons","defaults","push","Number","filter","validLayerId","isValidLayerId","console","warn","layerConfig","StyledPaper","Paper","theme","marginRight","spacing","border","palette","divider","ContentGridContainer","Grid","TitleGridContainer","paddingLeft","LinkContainer","BreadCrumb","Component","setHidden","o","getOpacity","hidden","setLayerOpacity","setOpacity","setLayerVisibility","publish","openInformative","chapter","windows","window","type","custom","open","handleClose","anchorEl","popoverOpen","findChapters","on","componentWillUnmount","un","isOverflow","el","original","scrollLeft","reduce","chaptersWithLayer","some","layerId","length","renderChapterLinks","size","onClick","header","renderChaptersPopover","renderInformativeIcon","title","square","elevation","container","justifyContent","alignItems","item","noWrap","onClose","anchorOrigin","vertical","horizontal","transformOrigin","MobileRoot","background","paper","boxShadow","shadows","left","bottom","right","width","MobileHeader","BreadCrumbsContainerMobile","maxHeight","overflow","breakpoints","down","BreadCrumbsContainer","MobileBreadCrumbWrapper","paddingBottom","WrappedComponent","BreadCrumbs","addedLayerBuffer","removedLayerBuffer","bindLayerEvents","visibleLayers","changedLayer","clearTimeout","timer","removedLayer","clearing","clear","getBreadCrumbCompatibleLayers","toggle","getVisibleLayers","getLayers","getArray","getVisible","forEach","renderMobile","xs","marginTop","marginBottom","marginLeft","renderDesktop","breadCrumbs","data","alignCenter","isMobile","useTheme","useMediaQuery"],"sourceRoot":""}