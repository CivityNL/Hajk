{"version":3,"file":"static/js/8702.a78212b1.chunk.js","mappings":"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","sources":["plugins/Buffer/BufferModel.js"],"sourcesContent":["import { Circle, Stroke, Fill, Style } from \"ol/style.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\n\nimport GeoJSON from \"ol/format/GeoJSON.js\";\n\nimport HajkTransformer from \"utils/HajkTransformer\";\nimport { hfetch } from \"utils/FetchWrapper\";\n\nclass BufferModel {\n  #HT;\n\n  constructor(settings) {\n    this.map = settings.map;\n    this.#HT = new HajkTransformer({\n      projection: settings.map.getView().getProjection().getCode(),\n    });\n\n    // Will contain new features for clicked objects/features\n    this.highlightSource = new VectorSource();\n    this.highlightLayer = new VectorLayer({\n      source: this.highlightSource,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginBufferSelection\",\n      caption: \"Buffer selection layer\",\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 168, 231, 0.47)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(255, 168, 231, 1)\",\n          width: 4,\n        }),\n        image: new Circle({\n          radius: 6,\n          fill: new Fill({\n            color: \"rgba(255, 168, 231, 0.47)\",\n          }),\n          stroke: new Stroke({\n            color: \"rgba(255, 168, 231, 1)\",\n            width: 1,\n          }),\n        }),\n      }),\n    });\n\n    // Will contain the actual buffer zone features\n    this.bufferSource = new VectorSource();\n    this.bufferLayer = new VectorLayer({\n      source: this.bufferSource,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginBuffer\",\n      caption: \"Buffer layer\",\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 255, 255, 0.5)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(75, 100, 115, 1.5)\",\n          width: 4,\n        }),\n        image: new Circle({\n          radius: 6,\n          fill: new Fill({\n            color: \"rgba(255, 255, 255, 0.5)\",\n          }),\n          stroke: new Stroke({\n            color: \"rgba(75, 100, 115, 1.5)\",\n            width: 2,\n          }),\n        }),\n      }),\n    });\n\n    // Add layers to map\n    this.map.addLayer(this.highlightLayer);\n    this.map.addLayer(this.bufferLayer);\n  }\n\n  // Called onWindowShow and onWindowHide\n  setActive(active) {\n    if (active === false) {\n      this.activateSelecting(false);\n    }\n  }\n\n  activateSelecting = (v) => {\n    if (v === true) {\n      this.map.on(\"click\", this.handleClick);\n      this.map.clickLock.add(\"buffer\");\n    } else {\n      this.map.un(\"click\", this.handleClick);\n      this.map.clickLock.delete(\"buffer\");\n    }\n  };\n\n  handleClick = (e) => {\n    // Handle all vector features\n    this.map\n      // Get all features from all vector sources at given pixel…\n      .getFeaturesAtPixel(e.pixel, {\n        layerFilter: function (l) {\n          const name = l.get(\"name\");\n          return name !== \"pluginBuffer\" && name !== \"pluginBufferSelection\"; // …but ignore them if they happen to come from buffer layer.\n        },\n      })\n      // Take each of the returned features from any vector layer…\n      .forEach((f) => {\n        const clonedFeature = f.clone(); // …clone it…\n        clonedFeature.setStyle(); // …and reset it's style (so it uses layer's default)…\n        this.highlightSource.addFeature(clonedFeature); //…and add it to the highlight source (so we collect them there).\n      });\n\n    // We're done with vector sources' features (e.g from WFS layers or the Draw plugin).\n    // Still we must handle visible WMS layers, see if we get any features at given coordinate\n    // and if so, add them to the highlight source too.\n    this.map\n      .getLayers() // Grab layers…\n      .getArray() // …as array…\n      .filter((l) => l.getVisible()) // …only currently visible…\n      .filter((l) => l.layersInfo) // …and only those that contain a \"layersInfo\" property - that means it's a Hajk layer - see ConfigMapper.js.\n      // Each of the remaining layers must now be queried separately. Let's do it:\n      .map(async (layer) => {\n        // Async, as we will await some fetch.\n        try {\n          const subLayers = Object.values(layer.layersInfo); // Transform the object to an array of objects\n          const subLayersToQuery = subLayers\n            .filter((subLayer) => subLayer.queryable === true) // Use only those layers that are specifically queryable\n            .map((queryableSubLayer) => queryableSubLayer.id); // Grab the id property (which is the name that we'll use in our URL)\n\n          if (e.coordinate !== undefined) {\n            const view = this.map.getView();\n\n            const url = layer // Prepare a URL that we'll call to see if there are features at a given coordinate\n              .getSource()\n              // Get the URL to FeatureInfo for given layer\n              .getFeatureInfoUrl(\n                e.coordinate, // Use current click event coordinate - that's what we're interested in!\n                view.getResolution(),\n                view.getProjection().getCode(),\n                {\n                  INFO_FORMAT: \"application/json\",\n                  QUERY_LAYERS: subLayersToQuery.join(\",\"), // Use the layer names we got earlier in the query\n                }\n              );\n\n            const response = await hfetch(url);\n            const json = await response.json();\n            const features = new GeoJSON().readFeatures(json); // Parse OL Features from returned JSON.\n\n            this.highlightSource.addFeatures(features); // Add them to the highlight source.\n          }\n        } catch (error) {} // There might be errors in the fetch/JSON parse stage, keep them quiet.\n      });\n  };\n\n  bufferFeatures = (distance) => {\n    const arr = [];\n\n    // Grab all selected features from highlight source…\n    for (const f of this.highlightSource.getFeatures()) {\n      // …use HajkTransformer utility to create a buffered feature…\n      const bufferedFeature = this.#HT.getBuffered(f, distance);\n      arr.push(bufferedFeature);\n    }\n    // …that finally gets added to the buffer zone features source.\n    this.bufferSource.addFeatures(arr);\n  };\n\n  clear = () => {\n    this.highlightSource.clear();\n    this.bufferSource.clear();\n  };\n}\nexport default BufferModel;\n"],"names":["constructor","settings","activateSelecting","v","this","map","on","handleClick","clickLock","add","un","delete","e","getFeaturesAtPixel","pixel","layerFilter","l","name","get","forEach","f","clonedFeature","clone","setStyle","highlightSource","addFeature","getLayers","getArray","filter","getVisible","layersInfo","async","subLayersToQuery","Object","values","layer","subLayer","queryable","queryableSubLayer","id","undefined","coordinate","view","getView","url","getSource","getFeatureInfoUrl","getResolution","getProjection","getCode","INFO_FORMAT","QUERY_LAYERS","join","response","hfetch","json","features","GeoJSON","readFeatures","addFeatures","error","bufferFeatures","distance","arr","getFeatures","bufferedFeature","getBuffered","push","bufferSource","clear","HajkTransformer","projection","VectorSource","highlightLayer","VectorLayer","source","layerType","zIndex","caption","style","Style","fill","Fill","color","stroke","Stroke","width","image","Circle","radius","bufferLayer","addLayer","setActive","active"],"sourceRoot":""}