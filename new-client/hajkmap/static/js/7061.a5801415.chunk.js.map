{"version":3,"file":"static/js/7061.a5801415.chunk.js","mappings":"6+CAsdA,UA5cA,MAcEA,YAAYC,GAAW,IAAD,muBAoBL,MAEf,OAAAC,KAAA,cAAmBA,KAAnB,SAEA,OAAAA,KAAA,cAAkBA,KAAlB,cACEA,KADF,cAEEA,KAFF,QAGE,CACEC,UAAW,SACXC,OAAQ,IACRC,KAAM,qBAIV,OAAAH,KAAA,MAAUI,UAAV,OAAmBJ,KAAnB,UAlCoB,gDAuCD,MAEnB,OAAAA,KAAA,MAAoBK,UAAU,4BAA6BC,KACzD,OAAAN,KAAA,MAAsBM,CAAtB,KAGF,OAAAN,KAAA,MAAoBK,UAClB,wBADF,OAEEL,KAFF,QAKA,OAAAA,KAAA,MAAoBK,UAAU,oBAA9B,OAAkDL,KAAlD,YAlDoB,gDAuDD,MAGnB,OAAAA,KAAA,SAEA,OAAAA,KAAA,MAA2BO,SAASC,cAAc,QAElD,OAAAR,KAAA,MAAyBS,aACvB,SADF,OAEET,KAFF,QAKA,OAAAA,KAAA,MAAoB,IAAIU,EAAAA,EAAQ,CAC9BC,SAAQ,OAACX,KAAF,MACPY,OAAQ,CAAC,IAAK,GACdC,YAAa,mBAGf,OAAAb,KAAA,MAAUc,YAAV,OAAqBd,KAArB,UAzEoB,gDA8Ec,MAGlC,OAAIA,KAAJ,SAEE,OAAAA,KAAA,MAAyBe,WAAWC,eAApC,OACEhB,KADF,QAIA,OAAAA,KAAA,MAA2B,KAC5B,IAxFmB,gDA4Fc,MAGlC,OAAIA,KAAJ,SAEE,OAAAA,KAAA,MAAUiB,eAAV,OAAwBjB,KAAxB,QAEA,OAAAA,KAAA,MAAoB,KACrB,IApGmB,gDAwGA,MAEpB,OAAAA,KAAA,SAEA,OAAAA,KAAA,WA5GoB,gDAgHE,KAGf,CAAEkB,aAFW,OAAAlB,KAAA,MAAcmB,iBAAmB,qBAElBC,WADjB,OAAApB,KAAA,MAAcqB,eAAiB,6BAlH7B,gDAuHN,IACP,IAAIC,EAAAA,GAAM,CACfC,OAAQ,IAAIC,EAAAA,EAAO,CACjBC,OAAO,OAAAzB,KAAA,MAAwBkB,YAC/BQ,MAAO,IAETC,KAAM,IAAIC,EAAAA,EAAK,CACbH,OAAO,OAAAzB,KAAA,MAAwBoB,YAEjCS,MAAO,IAAIC,EAAAA,EAAO,CAChBC,OAAQ,EACRR,OAAQ,IAAIC,EAAAA,EAAO,CACjBC,OAAO,OAAAzB,KAAA,MAAwBkB,YAC/BQ,MAAO,UApIO,gDA2IFM,IAElB,MAAMC,GAAa,OAAGjC,KAAH,QAGbkC,GAAS,OAAGlC,KAAH,MAA6BgC,GAI5C,OAFAC,EAAcE,QAAQD,GAEfD,CAAP,IApJoB,gDAyJED,GACf,IAAII,EAAAA,EAAK,CACdC,UAAW,SACXC,aAAc,SACdC,KAAM,kBACNZ,KAAM,IAAIC,EAAAA,EAAK,CAAEH,MAAO,SACxBe,MAAK,OAACxC,KAAF,QAAuBgC,GAC3BS,UAAU,EACVlB,OAAQ,IAAIC,EAAAA,EAAO,CACjBC,MAAO,qBACPC,MAAO,IAETgB,QAAS,EACTC,QAAS,EACTC,SAAU,EACVC,MAAO,MAxKW,gDA6KA,IACb,IAAIC,EAAAA,EAAa,CAAEC,OAAO,MA9Kb,gDAkLD,SAACC,EAAQC,GAAuB,IAAhBC,EAAe,uDAAP,CAAC,EAC5C,OAAO,IAAIC,EAAAA,EAAY,CACrBH,OAAQA,EACRC,MAAOA,KACJC,GAEN,IAxLqB,gDA2LG,MACvB,OAAIlD,KAAJ,QACE,OAAAA,KAAA,MAAUoD,mBAAV,OAA4BpD,KAA5B,MACD,IA9LmB,gDAkME,MAGtB,OAAAA,KAAA,MAAUqD,GAAG,eAAb,OAA4BrD,KAA5B,QACA,OAAAA,KAAA,MAAiBqD,GAAG,cAApB,OAAkCrD,KAAlC,QAEA,OAAIA,KAAJ,SACE,OAAAA,KAAA,MAAWqD,GAAG,aAAd,OAA2BrD,KAA3B,QACA,OAAAA,KAAA,MAAWqD,GAAG,WAAd,OAAyBrD,KAAzB,QACA,OAAAA,KAAA,MAAUqD,GAAG,eAAb,OAA4BrD,KAA5B,OACD,IA5MmB,gDAgNF,SAACsD,GAAkC,IAAtBC,EAAqB,wDAQpD,IANA,SAAI,GAAJ,MAEA,SAAI,GAAJ,MAEA,SAAI,GAAJ,GAAUC,UAAUC,OAAO,aAER,WAAfH,EACF,OAAO,SAAP,QAIEA,GAA6B,KAAfA,KAEhB,SAAI,GAAJ,GAAa,IAAII,EAAAA,GAAK,CACpBV,QAAO,OAAC,EAAF,MAGNW,KAAqB,cAAfL,EAA6B,SAAWA,EAE9CC,WAAU,CAAC,SAAU,aAAaK,SAASN,IAEvCC,EACJM,WAAW,EACXC,iBACiB,cAAfR,GACIS,EAAAA,EAAAA,MACe,WAAfT,GACAU,EAAAA,EAAAA,MACA,KACNf,OAAM,OAAC,EAAF,WAGP,SAAI,GAAJ,GAAUO,UAAUS,IAAI,cAExB,SAAI,GAAJ,GAAWC,GAAG,aAAd,OAA2B,EAA3B,QAEA,SAAI,GAAJ,GAAWA,GAAG,WAAd,OAAyB,EAAzB,QAGA,SAAI,GAAJ,GAAUA,GAAG,eAAb,OAA4B,EAA5B,QAEA,SAAI,GAAJ,GAAUC,gBAAV,OAAyB,EAAzB,QAEA,SAAI,GAAJ,GAAiBD,GAAG,cAApB,OAAkC,EAAlC,OAEH,IA/PqB,gDAmQQ,MAG5B,OAAAlE,KAAA,MAAUwD,UAAUS,IAAI,cAExB,OAAAjE,KAAA,MAAUkE,GAAG,eAAb,OAA4BlE,KAA5B,QACA,OAAAA,KAAA,MAAiBkE,GAAG,cAApB,OAAkClE,KAAlC,UAzQoB,gDA6QOoE,KAC3BC,EAAAA,EAAAA,aAAYD,EAAOA,EAAME,KAAMC,IAE7B,MAGMC,EAHWD,EAASE,SAGQC,QAAQ1C,GACjCA,EAAQ2C,gBAGe,IAA5BH,EAAiBI,UAMrB,OAAA5E,KAAA,SAIA,OAAAA,KAAA,MAAiB6E,WAAWL,EAAiB,IAA7C,GAnBF,IA9QoB,gDAsSI,KACxB,IAEE,MAAMC,GAAQ,OAAGzE,KAAH,UAER8E,GAAS,OAAG9E,KAAH,MAAsByE,IAErC,OAAAzE,KAAA,MAAoB+E,QAAQ,mBAAoB,CAC9CC,MAAqB,IAAdF,EACPL,SAAUA,EACVK,UAAWA,GASd,CAPC,MAAOE,IAEP,OAAAhF,KAAA,MAAoB+E,QAAQ,mBAAoB,CAC9CC,OAAO,EACPP,SAAU,GACVK,UAAW,GAEd,KAzTmB,gDA6TLL,GACRA,EAASQ,QAAO,CAACC,EAAKlD,IACpBkD,GAAG,OAAGlF,KAAH,MAAwBgC,IACjC,KAhUiB,gDAqUFmD,IACFA,EAAEnD,QACVkC,GAAG,UAAX,OAAqBlE,KAArB,UAvUoB,gDA+UJmF,KAGhB,OAAAnF,KAAA,QAEA,MAAM,QAAEgC,GAAYmD,GACpB,OAAAnF,KAAA,MAAyBoF,UAAY,MACrC,OAAApF,KAAA,MAAiC,MACjC,OAAAA,KAAA,MAAkBqF,aAAlB,OAA8BrF,KAA9B,OAEAgC,EAAQsD,UAAR,OAAiBtF,KAAjB,MAAuCgC,GAAvC,IAzVoB,gDA4VwB,KAAO,IAAD,EAIlD,MAAMuD,EAAyB,WAC7B,OAAAvF,KAAA,MAAoBwF,+BADS,SAGzBC,GAAmB,OAAAzF,KAAA,MAAiB0F,cAAcd,OAKnDW,GAAkD,IAArBE,KAChC,OAAAzF,KAAA,MAAiB2F,SACjB,OAAA3F,KAAA,MAAoB+E,QAAQ,2BAC7B,IA3WmB,gDAgXAI,KACpB,OAAAnF,KAAA,MAAiCmF,EAAES,UAAnC,IAjXoB,gDAsXET,IACtB,MAAMnD,EAAUmD,EAAEU,OACZC,GAAW,OAAG9F,KAAH,QAAwBgC,IAEzC,OAAAhC,KAAA,MAAyBoF,UAAYU,GACrC,OAAA9F,KAAA,MAAkBqF,aAAlB,OAA8BrF,KAA9B,UA3XoB,gDAgYHgC,IACjB,MAAM+D,EAAW/D,EAAQ2C,cAIzB,GAAIoB,aAAoBC,EAAAA,EAAgB,CACtC,MAAMjE,EAASgE,EAASE,YAExB,OAAOC,KAAKC,MAAMD,KAAKE,IAAIrE,EAAQ,GAAKmE,KAAKG,GAC9C,CAGD,OAAOH,KAAKC,MAAMJ,EAASO,UAA3B,IA5YoB,iDAgZHtE,IAEjB,MAAMuE,GAAW,OAAGvG,KAAH,MAAwBgC,GAEzC,OAAIuE,GAAe,IAGX,GAAN,QAAWA,EAAc,KAAKC,QAAQ,GAAtC,WAGI,GAAN,OAAUD,EAAYE,iBAAtB,aA1ZoB,iDA8ZN,MACd,OAAAzG,KAAA,MAAUwD,UAAUC,OAAO,cAC3B,OAAAzD,KAAA,MAAiB2F,SACjB,OAAA3F,KAAA,SACA,OAAAA,KAAA,SACA,OAAAA,KAAA,WAnaoB,iDAuaF,KACX,OAAAA,KAAA,MAAiB0F,gBAxaJ,KA4atBgB,wBAA0B,KAExB,MAAMjC,GAAQ,OAAGzE,KAAH,UAEd,OAAwB,IAApByE,EAASG,OACJ,KAKe,IAApBH,EAASG,QACJ,IAAI+B,EAAAA,GAAUC,aAAanC,EAAS,KAItC,IAAIkC,EAAAA,GAAUE,cAAcpC,EAAnC,GA1bA,OAAAzE,KAAA,MAAYD,EAASuE,KACrB,OAAAtE,KAAA,MAAsBD,EAAS+G,eAC/B,OAAA9G,KAAA,MAAgBD,EAASgH,SACzB,OAAA/G,KAAA,MAAa,MACb,OAAAA,KAAA,MAA2B,MAC3B,OAAAA,KAAA,MAAoB,MACpB,OAAAA,KAAA,MAAiC,MACjC,OAAAA,KAAA,MAAsB,MACtB,OAAAA,KAAA,MACE,8IAEF,OAAAA,KAAA,cAA0BA,KAA1B,SACA,OAAAA,KAAA,SACA,OAAAA,KAAA,SACA,OAAAA,KAAA,OACD,E","sources":["plugins/FmeServer/models/MapViewModel.js"],"sourcesContent":["import { Draw } from \"ol/interaction\";\nimport { Circle as CircleGeometry } from \"ol/geom.js\";\nimport { createBox, createRegularPolygon } from \"ol/interaction/Draw\";\nimport { Vector as VectorLayer } from \"ol/layer\";\nimport VectorSource from \"ol/source/Vector\";\nimport { Stroke, Style, Circle, Fill, Text } from \"ol/style\";\nimport Overlay from \"ol/Overlay.js\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport { handleClick } from \"../../../models/Click\";\n\nclass MapViewModel {\n  #map;\n  #localObserver;\n  #options;\n  #drawStyleSettings;\n  #draw;\n  #drawSource;\n  #drawLayer;\n  #drawTooltipElement;\n  #drawTooltipElementStyle;\n  #drawTooltip;\n  #currentPointerCoordinate;\n  #activeProduct;\n\n  constructor(settings) {\n    this.#map = settings.map;\n    this.#localObserver = settings.localObserver;\n    this.#options = settings.options;\n    this.#draw = null;\n    this.#drawTooltipElement = null;\n    this.#drawTooltip = null;\n    this.#currentPointerCoordinate = null;\n    this.#activeProduct = null;\n    this.#drawTooltipElementStyle =\n      \"position: relative; background: rgba(0, 0, 0, 0.5); border-radius: 4px; color: white; padding: 4px 8px; opacity: 0.7; white-space: nowrap;\";\n\n    this.#drawStyleSettings = this.#getDrawStyleSettings();\n    this.#initDrawLayer();\n    this.#bindSubscriptions();\n    this.#createDrawTooltip();\n  }\n\n  // Initializes the layer in which the user will be adding their\n  // drawn geometries.\n  #initDrawLayer = () => {\n    // Let's grab a vector-source.\n    this.#drawSource = this.#getNewVectorSource();\n    // Let's create a layer\n    this.#drawLayer = this.#getNewVectorLayer(\n      this.#drawSource,\n      this.#getDrawStyle(),\n      {\n        layerType: \"system\",\n        zIndex: 5000,\n        name: \"pluginFmeServer\",\n      }\n    );\n    // Then we can add the layer to the map.\n    this.#map.addLayer(this.#drawLayer);\n  };\n\n  // We must make sure that we are listening to the appropriate events from\n  // the local observer.\n  #bindSubscriptions = () => {\n    // Will fire when the active product changes\n    this.#localObserver.subscribe(\"view.activeProductChange\", (product) => {\n      this.#activeProduct = product;\n    });\n    // Will fire when the user changes tool\n    this.#localObserver.subscribe(\n      \"map.toggleDrawMethod\",\n      this.#toggleDrawMethod\n    );\n    // Will fire when the user wants to reset the drawing.\n    this.#localObserver.subscribe(\"map.resetDrawing\", this.#resetDrawing);\n  };\n\n  // Creates the element and overlay used to display the area of the feature\n  // currently being drawn.\n  #createDrawTooltip = () => {\n    // If the element already exists in the dom (which it will if #drawTooltipElement\n    //  isn't nullish), we must make sure to remove it.\n    this.#removeEventualDrawTooltipElement();\n    // Let's crete a element that we can use in the overlay.\n    this.#drawTooltipElement = document.createElement(\"div\");\n    // Let's style the element a bit so it looks prettier...\n    this.#drawTooltipElement.setAttribute(\n      \"style\",\n      this.#drawTooltipElementStyle\n    );\n    // Then let's create the overlay...\n    this.#drawTooltip = new Overlay({\n      element: this.#drawTooltipElement,\n      offset: [30, -5],\n      positioning: \"bottom-center\",\n    });\n    // And add it to the map!\n    this.#map.addOverlay(this.#drawTooltip);\n  };\n\n  // We have to make sure that we remove eventual unused elements\n  // from the dom tree so they're not lurking around.\n  #removeEventualDrawTooltipElement = () => {\n    // Before we do anything else, we make sire that there actually is\n    // an element present.\n    if (this.#drawTooltipElement) {\n      // Then we can remove it\n      this.#drawTooltipElement.parentNode.removeElement(\n        this.#drawTooltipElement\n      );\n      // And clear the variable\n      this.#drawTooltipElement = null;\n    }\n  };\n\n  // We have to make sure that we leave no unused overlays behind\n  #removeEventualDrawTooltipOverlay = () => {\n    // Before anything else, we make sure that there is an overlay\n    // present.\n    if (this.#drawTooltip) {\n      // Then we can remove it\n      this.#map.removeOverlay(this.#drawTooltip);\n      // And clear the variable\n      this.#drawTooltip = null;\n    }\n  };\n\n  // Makes sure that we clean up after ourselves.\n  #cleanupMapOverlays = () => {\n    // Remove unused elements\n    this.#removeEventualDrawTooltipElement();\n    // REmove unused overlays\n    this.#removeEventualDrawTooltipOverlay();\n  };\n\n  // Returns the style settings used in the OL-style.\n  #getDrawStyleSettings = () => {\n    const strokeColor = this.#options.drawStrokeColor || \"rgba(74,74,74,0.5)\";\n    const fillColor = this.#options.drawFillColor || \"rgba(255,255,255,0.07)\";\n    return { strokeColor: strokeColor, fillColor: fillColor };\n  };\n\n  // Returns an OL style to be used in the draw-layer.\n  #getDrawStyle = () => {\n    return new Style({\n      stroke: new Stroke({\n        color: this.#drawStyleSettings.strokeColor,\n        width: 4,\n      }),\n      fill: new Fill({\n        color: this.#drawStyleSettings.fillColor,\n      }),\n      image: new Circle({\n        radius: 6,\n        stroke: new Stroke({\n          color: this.#drawStyleSettings.strokeColor,\n          width: 2,\n        }),\n      }),\n    });\n  };\n\n  // Returns the style that should be used on the drawn features\n  #getFeatureStyle = (feature) => {\n    // Let's start by grabbing the standard draw style as a baseline\n    const baseLineStyle = this.#getDrawStyle();\n    // Then we'll create a new text-style which will allow us to show\n    // the area of the drawn feature.\n    const textStyle = this.#getFeatureTextStyle(feature);\n    // Apply the text-style to the baseline style...\n    baseLineStyle.setText(textStyle);\n    // And return the finished style.\n    return baseLineStyle;\n  };\n\n  // Returns a text-style that shows the tooltip-label\n  // (i.e. the area of the feature in a readable format).\n  #getFeatureTextStyle = (feature) => {\n    return new Text({\n      textAlign: \"center\",\n      textBaseline: \"middle\",\n      font: \"12pt sans-serif\",\n      fill: new Fill({ color: \"#FFF\" }),\n      text: this.#getTooltipText(feature),\n      overflow: true,\n      stroke: new Stroke({\n        color: \"rgba(0, 0, 0, 0.5)\",\n        width: 3,\n      }),\n      offsetX: 0,\n      offsetY: 0,\n      rotation: 0,\n      scale: 1,\n    });\n  };\n\n  // Returns a new vector source.\n  #getNewVectorSource = () => {\n    return new VectorSource({ wrapX: false });\n  };\n\n  // Returns a new vector layer.\n  #getNewVectorLayer = (source, style, props = {}) => {\n    return new VectorLayer({\n      source: source,\n      style: style,\n      ...props,\n    });\n  };\n\n  // Removes the draw interaction if there is one active\n  #removeDrawInteraction = () => {\n    if (this.#draw) {\n      this.#map.removeInteraction(this.#draw);\n    }\n  };\n\n  // We have to make sure to remove all event listeners to avoid clogging.\n  #removeEventListeners = () => {\n    // Some listeners will exist even if the draw interaction is not existing.\n    // (The \"Select\" listeners)\n    this.#map.un(\"singleclick\", this.#handleSelectFeatureClick);\n    this.#drawSource.un(\"addfeature\", this.#handleDrawFeatureAdded);\n    // While some will only exist if draw is/has ever been active...\n    if (this.#draw) {\n      this.#draw.un(\"drawstart\", this.#handleDrawStart);\n      this.#draw.un(\"drawend\", this.#handleDrawEnd);\n      this.#map.un(\"pointermove\", this.#handlePointerMove);\n    }\n  };\n\n  // Toggles the draw method\n  #toggleDrawMethod = (drawMethod, freehand = false) => {\n    // We begin with removing potential existing draw\n    this.#removeDrawInteraction();\n    // And also remove potential event listeners\n    this.#removeEventListeners();\n    // We also want to make sure to remove the potential click-lock\n    this.#map.clickLock.delete(\"fmeServer\");\n    // If the interaction is \"Select\" we don't want a draw method\n    if (drawMethod === \"Select\") {\n      return this.#enableSelectFeaturesSearch();\n    }\n    // If the drawMethod is missing or equals an empty string, the user\n    // is toggling draw off.\n    if (drawMethod && drawMethod !== \"\") {\n      // If the drawMethod contains something, they want to toggle on!\n      this.#draw = new Draw({\n        source: this.#drawSource,\n        // Rectangles should be created with the \"Circle\" method\n        // apparently.\n        type: drawMethod === \"Rectangle\" ? \"Circle\" : drawMethod,\n        // We want freehand drawing for rectangles and circles\n        freehand: [\"Circle\", \"Rectangle\"].includes(drawMethod)\n          ? true\n          : freehand,\n        stopClick: true,\n        geometryFunction:\n          drawMethod === \"Rectangle\"\n            ? createBox()\n            : drawMethod === \"Circle\"\n            ? createRegularPolygon()\n            : null,\n        style: this.#getDrawStyle(),\n      });\n      // Let's add the clickLock to avoid the featureInfo\n      this.#map.clickLock.add(\"fmeServer\");\n      // Then we'll add a listener for when the drawing starts\n      this.#draw.on(\"drawstart\", this.#handleDrawStart);\n      // And a listener for when the drawing is complete\n      this.#draw.on(\"drawend\", this.#handleDrawEnd);\n      // We'll also want a handler for the pointer event to keep\n      // track of where the users pointer is located.\n      this.#map.on(\"pointermove\", this.#handlePointerMove);\n      // Then we'll add the interaction to the map!\n      this.#map.addInteraction(this.#draw);\n      // We need a listener for when a feature is added to the source.\n      this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n    }\n  };\n\n  // We're not only letting the user draw features in the map,\n  // they can also select existing features (from active layers).\n  #enableSelectFeaturesSearch = () => {\n    // We don't want the FeatureInfo to get in the way, so let's add\n    // the clickLock.\n    this.#map.clickLock.add(\"fmeServer\");\n    // Then we'll register the required event listeners\n    this.#map.on(\"singleclick\", this.#handleSelectFeatureClick);\n    this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n  };\n\n  // Handles singleClick(s) in the map when the current draw method is set to \"Select\"\n  #handleSelectFeatureClick = (event) => {\n    handleClick(event, event.map, (response) => {\n      // The response will contain an array\n      const features = response.features;\n      // Which might contain features without geometry. We have to make sure\n      // we remove those.\n      const featuresWithGeom = features.filter((feature) => {\n        return feature.getGeometry();\n      });\n      // The resulting array might be empty, then we abort.\n      if (featuresWithGeom.length === 0) {\n        return;\n      }\n      // If we know that we are going to add a feature to the layer,\n      // we must make sure to remove the existing geometry if multiple\n      // geometries are not allowed.\n      this.#handlePotentialMultipleGeometriesException();\n      // But it might also contain several features that we should add to the map.\n      // However, we're only adding the first one, otherwise it might get messy if the\n      // user has 15 layers active at the same time.\n      this.#drawSource.addFeature(featuresWithGeom[0]);\n    });\n  };\n\n  // Handles the addfeature event\n  #handleDrawFeatureAdded = () => {\n    try {\n      // First we need to get all the drawn features\n      const features = this.#getDrawnFeatures();\n      // Then we'll calculate the total area\n      const totalArea = this.#getTotalArea(features);\n      // And publish the results\n      this.#localObserver.publish(\"map.featureAdded\", {\n        error: totalArea === 0,\n        features: features,\n        totalArea: totalArea,\n      });\n    } catch (error) {\n      // If we've error:ed we have to let the view know\n      this.#localObserver.publish(\"map.featureAdded\", {\n        error: true,\n        features: [],\n        totalArea: 0,\n      });\n    }\n  };\n\n  // Returns the combined area of all features supplied.\n  #getTotalArea = (features) => {\n    return features.reduce((acc, feature) => {\n      return acc + this.#getFeatureArea(feature);\n    }, 0);\n  };\n\n  // This handler has one job; add a change listener to the feature\n  // currently being drawn.\n  #handleDrawStart = (e) => {\n    const feature = e.feature;\n    feature.on(\"change\", this.#handleFeatureChange);\n  };\n\n  // This handler will make sure that the overlay will be removed\n  // when the feature is done. It also makes sure to remove previously\n  // drawn geometries if multiple geometries is not allowed.\n  // It also publishes an event in the case that the previously drawn geometry\n  // was removed.\n  #handleDrawEnd = (e) => {\n    // First we must make sure to handle and remove potential features\n    // that exceed the maximum allowance.\n    this.#handlePotentialMultipleGeometriesException();\n    // Then we make sure to remove the draw tooltip\n    const { feature } = e;\n    this.#drawTooltipElement.innerHTML = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n    // And set a nice style on the feature to be added.\n    feature.setStyle(this.#getFeatureStyle(feature));\n  };\n\n  #handlePotentialMultipleGeometriesException = () => {\n    // First we must check if the currently active product allows for\n    // multiple geometries. We fallback on false if the config option\n    // is missing (since is more usual that only one geometry is allowed).\n    const multipleGeometriesAllowed =\n      this.#activeProduct.allowMultipleGeometries ?? false;\n    // Then we must check if the user has already drawn a geometry\n    const numFeaturesDrawn = this.#drawSource.getFeatures().length;\n    // If they had, and multiple geometries are not allowed, we remove\n    // the previously drawn geometry by clearing the draw source.\n    // Then we publish an event to let the user know that we removed\n    // a geometry from the map.\n    if (!multipleGeometriesAllowed && numFeaturesDrawn !== 0) {\n      this.#drawSource.clear();\n      this.#localObserver.publish(\"map.maxFeaturesExceeded\");\n    }\n  };\n\n  // This handler has one job; get the coordinate from the event,\n  // and store it for later use.\n  #handlePointerMove = (e) => {\n    this.#currentPointerCoordinate = e.coordinate;\n  };\n\n  // This handler will make sure that we keep the area calculation\n  // updated during the feature changes.\n  #handleFeatureChange = (e) => {\n    const feature = e.target;\n    const toolTipText = this.#getTooltipText(feature);\n\n    this.#drawTooltipElement.innerHTML = toolTipText;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // Calculates the area of the supplied feature.\n  // Accepts an OL-feature, and is tested for Circle and Polygon.\n  #getFeatureArea = (feature) => {\n    const geometry = feature.getGeometry();\n    // Apparently the circle geometry instance does not expose a\n    // getArea method. Here's a quick fix. (Remember that this area\n    // is only used as an heads-up for the user.)\n    if (geometry instanceof CircleGeometry) {\n      const radius = geometry.getRadius();\n      // We're rounding since precision isn't important when choosing the area.\n      return Math.round(Math.pow(radius, 2) * Math.PI);\n    }\n    // If we're not dealing with a circle, we can just return the area.\n    // We're rounding since precision isn't important when choosing the area.\n    return Math.round(geometry.getArea());\n  };\n\n  // Returns the area of the supplied feature in a readable format.\n  #getTooltipText = (feature) => {\n    // First we must get the feature area.\n    const featureArea = this.#getFeatureArea(feature);\n    // Let's check if we're dealing with a huge area.\n    if (featureArea >= 1e6) {\n      // If the area is larger than one square kilometer we show the result in km²\n      // Rounded to show 3 decimals.\n      return `${(featureArea / 1e6).toFixed(3)} km²`;\n    }\n    // Otherwise m² will do. (Displayed in local format).\n    return `${featureArea.toLocaleString()} m²`;\n  };\n\n  // Resets the draw-layer\n  #resetDrawing = () => {\n    this.#map.clickLock.delete(\"fmeServer\");\n    this.#drawSource.clear();\n    this.#removeDrawInteraction();\n    this.#removeEventListeners();\n    this.#cleanupMapOverlays();\n  };\n\n  // Returns all drawn features.\n  #getDrawnFeatures = () => {\n    return this.#drawSource.getFeatures();\n  };\n\n  // Returns all drawn features in GeoJSON format.\n  getAllFeaturesAsGeoJson = () => {\n    // First we need to get all the ol-features\n    const features = this.#getDrawnFeatures();\n    // If there are no features, we return null\n    if (features.length === 0) {\n      return null;\n    }\n    // If there's exactly one feature, we use the writeFeature method,\n    // otherwise we would get a featureCollection with one feature.\n    // (We rather want just the single feature, not a collection).\n    if (features.length === 1) {\n      return new GeoJSON().writeFeature(features[0]);\n    }\n    // If there's more than one feature, we use the writeFeatures method,\n    // which returns a featureCollection.\n    return new GeoJSON().writeFeatures(features);\n  };\n}\nexport default MapViewModel;\n"],"names":["constructor","settings","this","layerType","zIndex","name","addLayer","subscribe","product","document","createElement","setAttribute","Overlay","element","offset","positioning","addOverlay","parentNode","removeElement","removeOverlay","strokeColor","drawStrokeColor","fillColor","drawFillColor","Style","stroke","Stroke","color","width","fill","Fill","image","Circle","radius","feature","baseLineStyle","textStyle","setText","Text","textAlign","textBaseline","font","text","overflow","offsetX","offsetY","rotation","scale","VectorSource","wrapX","source","style","props","VectorLayer","removeInteraction","un","drawMethod","freehand","clickLock","delete","Draw","type","includes","stopClick","geometryFunction","createBox","createRegularPolygon","add","on","addInteraction","event","handleClick","map","response","featuresWithGeom","features","filter","getGeometry","length","addFeature","totalArea","publish","error","reduce","acc","e","innerHTML","setPosition","setStyle","multipleGeometriesAllowed","allowMultipleGeometries","numFeaturesDrawn","getFeatures","clear","coordinate","target","toolTipText","geometry","CircleGeometry","getRadius","Math","round","pow","PI","getArea","featureArea","toFixed","toLocaleString","getAllFeaturesAsGeoJson","GeoJSON","writeFeature","writeFeatures","localObserver","options"],"sourceRoot":""}