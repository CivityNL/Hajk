{"version":3,"file":"static/js/4311.76dff013.chunk.js","mappings":"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","sources":["models/DrawModel.js"],"sourcesContent":["import { Draw, Modify, Select, Translate } from \"ol/interaction\";\nimport { createBox } from \"ol/interaction/Draw\";\nimport { Vector as VectorLayer } from \"ol/layer\";\nimport VectorSource from \"ol/source/Vector\";\nimport { Icon, Stroke, Style, Circle, Fill, Text } from \"ol/style\";\nimport { Circle as CircleGeometry, LineString } from \"ol/geom\";\nimport { fromCircle } from \"ol/geom/Polygon\";\nimport { MultiPoint, Point } from \"ol/geom\";\nimport Overlay from \"ol/Overlay\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport transformTranslate from \"@turf/transform-translate\";\nimport { getArea as getExtentArea, getCenter, getWidth } from \"ol/extent\";\nimport { Feature } from \"ol\";\nimport { handleClick } from \"./Click\";\n\n/*\n * A model supplying useful Draw-functionality.\n * Required settings:\n * - layerName: (string): The name of the layer that initially should be connected to the Draw-model.\n *   If it already exists a layer in the map with the same name, the model will be connected\n *   to that layer. Otherwise, a new vector-layer will be created and added to the map.\n * - map: (olMap): The current map-object.\n *\n * Optional settings:\n * - observer: (Observer): An observer on which the drawModel can publish events, for example when a geometry has been deleted.\n * - observerPrefix (String): A string acting as a prefix on all messages published on the observer.\n * - modifyDefaultEnabled: (Boolean): States if the Modify-interaction be enabled when the Edit-interaction is enabled.\n * - translateDefaultEnabled: (Boolean): States if the Translate-interaction should be enabled when the Move-interaction is enabled.\n *\n * Exposes a couple of methods:\n * - refreshFeaturesTextStyle(): Refreshes the text-style on all features in the draw-source.\n * - refreshDrawLayer(): Redraws all features in the draw-layer.\n * - addFeature(feature): Adds the supplied feature to the draw-source.\n * - duplicateFeature(feature): Duplicates the supplied feature and adds it to the draw-source.\n * - removeFeature(feature): Removes the supplied feature from the draw-source.\n * - getCurrentExtent(): Returns the current extent of the current draw-layer.\n * - getCurrentLayerName(): Returns the name of the layer currently connected to the draw-model.\n * - removeDrawnFeatures():  Removes all drawn features from the current draw-source.\n * - setLayer(layerName <string>): Sets (or creates) the layer that should be connected to the draw-model.\n * - toggleDrawInteraction(drawType, settings): Accepts a string with the drawType and an object containing settings.\n * - zoomToCurrentExtent(): Fits the map-view to the current extent of the current draw-source.\n * - getRGBAString(RGBA-object <object>): Accepts an object with r-, g-, b-, and a-properties and returns the string representation.\n * - parseColorString(hex/rgba-string <string>): Accepts a string and returns an object with r-, g-, b-, and a-properties.\n * - getCurrentVectorSource(): Returns the vector-source currently connected to the draw-model.\n * - get/set drawStyleSettings(): Get or set the style settings used by the draw-model.\n * - get/set showDrawTooltip(): Get or set wether a tooltip should be shown when drawing.\n * - get/set modifyActive(): Get or set wether the Modify-interaction should be active or not.\n * - get/set translateActive(): Get or set wether the Translate-interaction should be active or not.\n * - get/set measurementSettings(): Get or set the measurement-settings (units, show-area etc.)\n * - get/set circleRadius(): Get or set the radius of the circle.\n */\nclass DrawModel {\n  #map;\n  #layerName;\n  #layerCaption;\n  #geoJSONParser;\n  #observer;\n  #observerPrefix;\n  #drawSource;\n  #drawLayer;\n  #currentExtent;\n  #drawTooltipElement;\n  #drawTooltipElementStyle;\n  #drawTooltip;\n  #currentPointerCoordinate;\n  #showDrawTooltip;\n  #measurementSettings;\n  #drawStyleSettings;\n  #textStyleSettings;\n  #drawInteraction;\n  #removeInteractionActive;\n  #editInteractionActive;\n  #featureChosenForEdit;\n  #moveInteractionActive;\n  #selectInteraction;\n  #translateInteraction;\n  #modifyInteraction;\n  #keepModifyActive;\n  #keepTranslateActive;\n  #customHandleDrawStart;\n  #customHandleDrawEnd;\n  #customHandlePointerMove;\n  #customHandleAddFeature;\n  #customGetDrawImageStyle;\n  #highlightFillColor;\n  #highlightStrokeColor;\n  #circleRadius;\n  #circleInteractionActive;\n  #selectInteractionActive;\n  #lastZIndex;\n\n  constructor(settings) {\n    // Let's make sure that we don't allow initiation if required settings\n    // are missing.\n    if (!settings.map || !settings.layerName) {\n      return this.#handleInitiationParametersMissing();\n    }\n    // Make sure that we keep track of the supplied settings.\n    this.#map = settings.map;\n    this.#layerName = settings.layerName;\n    this.#layerCaption = settings.layerCaption;\n    // We're gonna need a GeoJSON-parser with the maps projection set.\n    this.#geoJSONParser = new GeoJSON({\n      featureProjection: this.#map.getView().getProjection(),\n    });\n    // An observer might be supplied. If it is, the drawModel will publish messages when features are deleted etc.\n    this.#observer = settings.observer || null;\n    // There might be an \"observerPrefix\" (string) passed. States a string\n    // which will act as a prefix on all messages published on the\n    // supplied observer.\n    this.#observerPrefix = this.#getObserverPrefix(settings);\n    this.#customGetDrawImageStyle = settings.customGetDrawImageStyle;\n    this.#measurementSettings =\n      settings.measurementSettings ?? this.#getDefaultMeasurementSettings();\n    this.#drawStyleSettings =\n      settings.drawStyleSettings ?? this.#getDefaultDrawStyleSettings();\n    this.#textStyleSettings =\n      settings.textStyleSettings ?? this.#getDefaultTextStyleSettings();\n    // We are going to be keeping track of the current extent of the draw-source...\n    this.#currentExtent = null;\n    // And the current draw interaction.\n    this.#drawInteraction = null;\n    // We also have to make sure to keep track of if any other interaction is active.\n    // E.g. \"Remove\", or \"Edit\".\n    this.#removeInteractionActive = false;\n    this.#editInteractionActive = false;\n    this.#moveInteractionActive = false;\n    this.#modifyInteraction = null;\n    this.#keepModifyActive = settings.modifyDefaultEnabled ?? false;\n    this.#translateInteraction = null;\n    this.#keepTranslateActive = settings.translateDefaultEnabled ?? true;\n    this.#selectInteraction = null;\n    this.#featureChosenForEdit = null;\n    // We're also keeping track of the tooltip-settings\n    this.#showDrawTooltip = settings.showDrawTooltip ?? true;\n    this.#drawTooltip = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltipElement = null;\n    this.#drawTooltipElementStyle =\n      \"position: relative; background: rgba(0, 0, 0, 0.5); border-radius: 4px; color: white; padding: 4px 8px; opacity: 0.7; white-space: nowrap;\";\n    // There might be some custom event-listeners passed when initiating the draw interaction,\n    // we have to keep track of them.\n    this.#customHandleDrawStart = null;\n    this.#customHandleDrawEnd = null;\n    this.#customHandlePointerMove = null;\n    this.#customHandleAddFeature = null;\n    this.#highlightFillColor = \"rgba(35,119,252,1)\";\n    this.#highlightStrokeColor = \"rgba(255,255,255,1)\";\n    this.#circleRadius = 0;\n    this.#selectInteractionActive = false;\n    this.#lastZIndex = 1;\n\n    // A Draw-model is not really useful without a vector-layer, let's initiate it\n    // right away, either by creating a new layer, or connect to an existing layer.\n    this.#initiateDrawLayer();\n    // We also have to initiate the element for the draw-tooltip\n    this.#createDrawTooltip();\n  }\n\n  // Returns the supplied observerPrefix from the supplied settings or null if none was supplied.\n  #getObserverPrefix = (settings) => {\n    return typeof settings.observerPrefix === \"string\"\n      ? settings.observerPrefix\n      : null;\n  };\n\n  // Helper function that accepts an object containing two parameters:\n  // - subject: (string): The subject to be published on the observer\n  // - payLoad: (any): The payload to send when publishing.\n  #publishInformation = ({ subject, payLoad }) => {\n    // If no observer has been set-up, or if the subject is missing, we abort\n    if (!this.#observer || !subject) {\n      return;\n    }\n    // Otherwise we create the prefixed-subject to send. (The drawModel might have\n    // been initiated with a prefix that should be added on all subjects).\n    const prefixedSubject = this.#observerPrefix\n      ? `${this.#observerPrefix}.${subject}`\n      : subject;\n    // Then we publish the event!\n    this.#observer.publish(prefixedSubject, payLoad);\n  };\n\n  // Returns the default style settings used by the draw-model.\n  #getDefaultDrawStyleSettings = () => {\n    const strokeColor = \"rgba(74,74,74,0.5)\";\n    const strokeDash = null;\n    const strokeWidth = 2;\n    const fillColor = \"rgba(255,255,255,0.07)\";\n    return {\n      strokeColor: strokeColor,\n      lineDash: strokeDash,\n      strokeWidth: strokeWidth,\n      fillColor: fillColor,\n    };\n  };\n\n  // Returns the default settings used to display measurement-labels\n  #getDefaultMeasurementSettings = () => {\n    return {\n      showText: false,\n      showArea: false,\n      showPerimeter: false,\n      areaUnit: \"AUTO\",\n      lengthUnit: \"AUTO\",\n      precision: 0,\n    };\n  };\n\n  // Returns the default text-style settings used by the draw-model.\n  #getDefaultTextStyleSettings = () => {\n    const foregroundColor = \"#FFFFFF\";\n    const backgroundColor = \"#000000\";\n    const size = 14;\n    return { foregroundColor, backgroundColor, size };\n  };\n\n  // If required parameters are missing, we have to make sure we abort the\n  // initiation of the draw-model.\n  #handleInitiationParametersMissing = () => {\n    throw new Error(\n      \"Failed to initiate Draw-model, - required parameters missing. \\n Required parameters: map, layerName\"\n    );\n  };\n\n  // We have to initiate a vector layer that can be used by the draw-model\n  #initiateDrawLayer = () => {\n    if (this.#vectorLayerExists()) {\n      return this.#connectExistingVectorLayer();\n    }\n    return this.#createNewDrawLayer();\n  };\n\n  // Checks wether the layerName supplied when initiating the Draw-model\n  // corresponds to an already existing vector-layer.\n  #vectorLayerExists = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Check wether any of the layers has the same name (type)\n    // as the supplied layerName.\n    // Also makes sure that the found layer is a vectorLayer. (We cannot\n    // add features to an imageLayer...).\n    return allMapLayers.some((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n  };\n\n  // Returns all layers connected to the map-object supplied\n  // when initiating the model.\n  #getAllMapLayers = () => {\n    return this.#map.getLayers().getArray();\n  };\n\n  // Checks wether the name (type) of the supplied layer matches\n  // the layerName supplied when initiating the model. Also makes\n  // sure that the layer is a vectorLayer.\n  #layerHasCorrectNameAndType = (layer) => {\n    return layer.get(\"name\") === this.#layerName && this.#isVectorLayer(layer);\n  };\n\n  // Checks wether the supplied layer is a vectorLayer or not.\n  #isVectorLayer = (layer) => {\n    return layer instanceof VectorLayer;\n  };\n\n  // Connects the private fields of the draw-model to an already existing\n  // vectorLayer.\n  #connectExistingVectorLayer = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Then we'll grab the layer corresponding to the supplied layerName.\n    const connectedLayer = allMapLayers.find((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n    // Then we'll set the private fields\n    this.#drawLayer = connectedLayer;\n    this.#drawSource = connectedLayer.getSource();\n  };\n\n  // Creates a new vector layer that can be used by the draw-model\n  #createNewDrawLayer = () => {\n    // Let's grab a vector-source.\n    this.#drawSource = this.#getNewVectorSource();\n    // Then we'll create the layer\n    this.#drawLayer = this.#getNewVectorLayer(this.#drawSource);\n    // Make sure to set a unique name\n    this.#drawLayer.set(\"name\", this.#layerName);\n    // We're also gonna have to set the queryable-property to true so that we can enable \"Select\" on the layer.\n    this.#drawLayer.set(\"queryable\", true);\n    // We don't want drawn features to show in feature-info (the info-click-window)\n    this.#drawLayer.set(\"ignoreInFeatureInfo\", true);\n    // Then we can add the layer to the map.\n    this.#map.addLayer(this.#drawLayer);\n  };\n\n  // Creates the element and overlay used to display the area of the feature\n  // currently being drawn.\n  #createDrawTooltip = () => {\n    // If the element already exists in the dom (which it will if #drawTooltipElement\n    //  isn't nullish), we must make sure to remove it.\n    this.#removeEventualDrawTooltipElement();\n    // Let's crete a element that we can use in the overlay.\n    this.#drawTooltipElement = document.createElement(\"div\");\n    // Let's style the element a bit so it looks prettier...\n    this.#drawTooltipElement.setAttribute(\n      \"style\",\n      this.#drawTooltipElementStyle\n    );\n    // Then let's create the overlay...\n    this.#drawTooltip = new Overlay({\n      element: this.#drawTooltipElement,\n      offset: [30, -5],\n      positioning: \"bottom-center\",\n    });\n    // And add it to the map!\n    this.#map.addOverlay(this.#drawTooltip);\n  };\n\n  // We have to make sure that we remove eventual unused elements\n  // from the dom tree so they're not lurking around.\n  #removeEventualDrawTooltipElement = () => {\n    // Before we do anything else, we make sire that there actually is\n    // an element present.\n    if (this.#drawTooltipElement) {\n      // Then we can remove it\n      this.#drawTooltipElement.parentNode.removeElement(\n        this.#drawTooltipElement\n      );\n      // And clear the variable\n      this.#drawTooltipElement = null;\n    }\n  };\n\n  // Find the highest zindex used and move on top of it.\n  moveFeatureZIndexToTop = (feature) => {\n    const indexes = this.#getAllZIndexes();\n    const topIndex = Math.max(...indexes);\n    if (isFinite(topIndex)) {\n      this.#setFeatureZIndex(feature, topIndex + 1);\n    }\n  };\n\n  // Find the closest zindex and move on top of it.\n  moveFeatureZIndexUp = (feature) => {\n    const zIndex = this.#findClosestZIndex(feature, true);\n    this.#setFeatureZIndex(feature, zIndex);\n  };\n\n  // Find the lowest zindex used and move below it.\n  moveFeatureZIndexToBottom = (feature) => {\n    const indexes = this.#getAllZIndexes();\n    const bottomIndex = Math.min(...indexes);\n    if (isFinite(bottomIndex)) {\n      this.#setFeatureZIndex(feature, bottomIndex - 1);\n    }\n  };\n\n  // Find the closest zindex and move below it.\n  moveFeatureZIndexDown = (feature) => {\n    const zIndex = this.#findClosestZIndex(feature, false);\n    this.#setFeatureZIndex(feature, zIndex);\n  };\n\n  // Find the closest zindex and move on top of it.\n  #getFeaturesSortedByZIndex = () => {\n    return this.#drawSource.getFeatures().sort((a, b) => {\n      return this.#getFeatureZIndex(a) < this.#getFeatureZIndex(b);\n    });\n  };\n\n  // Get an array of all zindexes\n  #getAllZIndexes = () => {\n    let indexes = [];\n    this.#getFeaturesSortedByZIndex().forEach((f) => {\n      indexes.push(this.#getFeatureZIndex(f));\n    });\n    return indexes;\n  };\n\n  // Find the closest valid zindex\n  #findClosestZIndex = (feature, up) => {\n    let zIndex = this.#getFeatureZIndex(feature);\n\n    const indexes = this.#getAllZIndexes().filter((index) => {\n      return up === true ? index > zIndex : index < zIndex;\n    });\n\n    let closest = Math.max(...indexes);\n    if (!isFinite(closest)) {\n      closest = up === true ? zIndex + 1 : zIndex - 1;\n    }\n\n    indexes.forEach((index) => {\n      if (\n        (up === true && index >= zIndex && index < closest) ||\n        (up === false && index <= zIndex && index > closest)\n      ) {\n        closest = index;\n      }\n    });\n\n    zIndex = up === true ? closest + 1 : closest - 1;\n\n    return zIndex;\n  };\n\n  #setFeatureZIndex = (feature, zIndex) => {\n    let style = feature.getStyle();\n    style = Array.isArray(style) ? style[0] : style;\n    if (style) {\n      style.setZIndex(zIndex);\n      feature.setStyle(style);\n    }\n  };\n\n  #getFeatureZIndex = (feature) => {\n    let style = feature.getStyle();\n    if (style) {\n      style = Array.isArray(style) ? style[0] : style;\n      return style.getZIndex() || 0;\n    }\n    return 0;\n  };\n\n  // Returns the style that should be used on the drawn features\n  #getFeatureStyle = (feature, settingsOverride) => {\n    if (feature.getStyle()) {\n      const currentZIndex = this.#getFeatureZIndex(feature);\n      if (currentZIndex === 0) {\n        // force a newly drawn feature to get a valid zindex.\n        this.#lastZIndex++;\n        this.#setFeatureZIndex(feature, this.#lastZIndex);\n      }\n    }\n\n    if (feature.get(\"HIDDEN\") === true) {\n      !feature.get(\"STYLE_BEFORE_HIDE\") &&\n        feature.set(\"STYLE_BEFORE_HIDE\", feature.getStyle());\n      return new Style({});\n    }\n    // If we're dealing with \"Arrow\" we'll return a special style array\n    if (feature?.get(\"DRAW_METHOD\") === \"Arrow\") {\n      return this.#getArrowStyle(feature, settingsOverride);\n    }\n    // Otherwise we'll grab the 'current' style. The 'current' style might be\n    // stored in the 'STYLE_BEFORE_HIDE' property (and feature.getStyle() will\n    // return an empty style). This case happens when the feature has been hid, and\n    // is now to be shown again. For all the 'ordinary' cases, this property will be null\n    // and wont affect the feature-style.\n    const currentStyle = feature.get(\"STYLE_BEFORE_HIDE\") || feature.getStyle();\n    feature.set(\"STYLE_BEFORE_HIDE\", null);\n    // Let's grab the standard draw (or the currently set) style as a baseline.\n    // The standard style can be overridden if the override is supplied. This is a real mess,\n    // since OL might decide to apply a style-array sometimes (in that case we want the fist style\n    // from the style-array) and sometimes its not an array.\n    const baseLineStyle = settingsOverride\n      ? this.#getDrawStyle(settingsOverride)\n      : currentStyle\n      ? Array.isArray(currentStyle)\n        ? currentStyle[0]\n        : currentStyle\n      : this.#getDrawStyle();\n    // If we're dealing with a text-feature, we don't want an image-style.\n    feature.get(\"DRAW_METHOD\") === \"Text\" && baseLineStyle.setImage(null);\n    // ILet's create a text-style. (Remember that this might be null, depending\n    // on the feature-text-settings, see more info in the method itself).\n    const textStyle = this.#getFeatureTextStyle(feature);\n    // Apply the text-style to the baseline style...\n    baseLineStyle.setText(textStyle);\n    // If the \"EDIT_ACTIVE\"-property is set (meaning that the feature has been selected for\n    // editing of its color etc) we have to return the baseline-style along with a highligh-style.\n    if (feature.get(\"EDIT_ACTIVE\") === true) {\n      return [baseLineStyle, this.#getNodeHighlightStyle(feature)];\n    } else {\n      // If its not set, we just return the baseline style!\n      return baseLineStyle;\n    }\n  };\n\n  // Method returning if we're supposed to be showing text on the feature\n  // or not. We're showing text in two cases: One: if the feature is of text-type,\n  // or two: if we're supposed to be showing feature measurements. If the feature is\n  // of arrow-type, we're never showing text.\n  #shouldShowText = (feature) => {\n    if (!feature) {\n      console.warn(\n        \"Could not evaluate '#shouldShowText' since no feature was supplied.\"\n      );\n      return false;\n    }\n    // The \"SHOW_TEXT\" prop can be toggled by the user allowing them to hide all texts.\n    if (feature.get(\"SHOW_TEXT\") === false) {\n      return false;\n    }\n    // Let's get the feature draw-method\n    const featureDrawMethod =\n      feature.get(\"DRAW_METHOD\") || feature.get(\"geometryType\");\n    // And check if we're supposed to be showing text or not.\n    // (We're never showing text on arrow-features, and text-features override\n    // the measurement-settings, since the text-features would be useless\n    // if the text wasn't shown).\n    return (\n      featureDrawMethod !== \"Arrow\" &&\n      (this.#measurementSettings.showText || featureDrawMethod === \"Text\")\n    );\n  };\n\n  // Returns a text-style that shows the tooltip-label\n  // (i.e. the area of the feature in a readable format).\n  // *If the measurement-label is supposed to be shown!*\n  #getFeatureTextStyle = (feature) => {\n    // First we have to make sure we're supposed to be showing text on the feature.\n    const shouldShowText = this.#shouldShowText(feature);\n    // If we're not supposed to be showing any text, we can just return null\n    if (!shouldShowText) {\n      return null;\n    }\n    // Before we create the text-style we have to check if we,re dealing with a\n    // point. If we are, we have to make sure to offset the text in the negative y-direction.\n    const featureIsPoint = feature?.getGeometry() instanceof Point;\n    // We also have to check if we're dealing with a text-feature or not\n    const featureIsTextType = feature?.get(\"DRAW_METHOD\") === \"Text\";\n    // Let's grab the foreground (fill) and background (stroke) colors that we're supposed to use.\n    // First we'll try to grab the color from the feature style, then from the current settings, and lastly from the fallback.\n    const foregroundColor = featureIsTextType\n      ? feature.get(\"TEXT_SETTINGS\")?.foregroundColor ??\n        this.#textStyleSettings.foregroundColor\n      : \"#FFF\";\n    // Same applies for the background\n    const backgroundColor = featureIsTextType\n      ? feature.get(\"TEXT_SETTINGS\")?.backgroundColor ??\n        this.#textStyleSettings.backgroundColor\n      : \"rgba(0, 0, 0, 0.5)\";\n    // Then we can create and return the style\n    return new Text({\n      textAlign: \"center\",\n      textBaseline: \"middle\",\n      font: `${\n        featureIsTextType\n          ? feature.get(\"TEXT_SETTINGS\")?.size ?? this.#textStyleSettings.size\n          : 12\n      }pt sans-serif`,\n      fill: new Fill({\n        color: featureIsTextType\n          ? feature.get(\"TEXT_SETTINGS\")?.foregroundColor ??\n            this.#textStyleSettings.foregroundColor\n          : \"#FFF\",\n      }),\n      text: this.#getFeatureLabelText(feature),\n      overflow: true,\n      stroke:\n        // If the foreground and the background are the same color, we don't need a stroke.\n        foregroundColor !== backgroundColor\n          ? new Stroke({\n              color: featureIsTextType\n                ? feature.get(\"TEXT_SETTINGS\")?.backgroundColor ??\n                  this.#textStyleSettings.backgroundColor\n                : \"rgba(0, 0, 0, 0.7)\",\n              width: 3,\n            })\n          : null,\n      offsetX: 0,\n      offsetY: featureIsPoint && !featureIsTextType ? -15 : 0,\n      rotation: 0,\n      scale: 1,\n    });\n  };\n\n  #getArrowBaseStyle = (settings) => {\n    // First we'll grab the feature base-style\n    const baseStyle = this.#getDrawStyle(settings);\n    // Then we'll alter the base-style a bit... We don't want to apply\n    // eventual line-dash, and we also want a hard-coded stroke-width.\n    const baseStroke = baseStyle.getStroke();\n    baseStroke.setWidth(5);\n    baseStroke.setLineDash(null);\n    // Then we return the altered base-style\n    return baseStyle;\n  };\n\n  // Returns a svg-string that is used to display arrows in the draw-source.\n  #createArrowSvg = (color) => {\n    const svgString = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"32pt\" height=\"32pt\" fill=\"${color}\"><path d=\"M 1 5 L 1 5 L 1 13 L 1 21 L 1 21 L 12 13\"/></svg>`;\n    return `data:image/svg+xml;base64,${window.btoa(svgString)}`; // We need base64 for kml-exports to work.\n  };\n\n  // Returns a style array that is used to style arrow features.\n  // (All other features consist of a single style-object).\n  #getArrowStyle = (feature, settings) => {\n    // First we'll extract the current style. We only want the current style if it is\n    // an array! Otherwise we're not dealing with an arrow-style... (Arrow-style should always be an array).\n    const currentStyle = Array.isArray(feature.getStyle())\n      ? feature.getStyle()\n      : null;\n    // Then we'll grab the arrow base-style, which should be the first style in the current\n    // style-array. If that style is missing, we'll create a new one.\n    const baseStyle = settings\n      ? this.#getArrowBaseStyle(settings)\n      : currentStyle\n      ? currentStyle[0]\n      : this.#getArrowBaseStyle();\n    // We have to extract the base-color as well, so that we can create an arrow-head with\n    // the correct color.\n    const baseColor = baseStyle.getStroke()?.getColor() ?? null;\n    // Then we'll add the base-style to the styles-array\n    const styles = [baseStyle];\n    // Then we'll add the arrow-head at the end of every line-segment.\n    feature?.getGeometry().forEachSegment((start, end) => {\n      // We'll have to rotate the arrow-head, let's calculate the\n      // line-segments rotation.\n      const dx = end[0] - start[0];\n      const dy = end[1] - start[1];\n      const rotation = Math.atan2(dy, dx);\n      // Then we'll push a style for each arrow-head.\n      styles.push(\n        new Style({\n          geometry: new Point(end),\n          image: new Icon({\n            src: this.#createArrowSvg(\n              settings\n                ? settings.strokeStyle.color\n                : baseColor\n                ? baseColor\n                : this.#drawStyleSettings.strokeColor\n            ),\n            anchor: [0.38, 0.53],\n            rotateWithView: true,\n            rotation: -rotation,\n          }),\n        })\n      );\n    });\n    // And finally return the style-array.\n    return styles;\n  };\n\n  // Creates a highlight style (a style marking the coordinates of the supplied feature).\n  #getNodeHighlightStyle = (feature) => {\n    try {\n      return new Style({\n        image: new Circle({\n          radius: 5,\n          fill: new Fill({\n            color: this.#highlightFillColor,\n          }),\n          stroke: new Stroke({ color: this.#highlightStrokeColor, width: 2 }),\n        }),\n        geometry: () => {\n          const coordinates = this.#getFeatureCoordinates(feature);\n          return new MultiPoint(coordinates);\n        },\n      });\n    } catch (error) {\n      console.error(`Could not create highlight style. Error: ${error}`);\n      return null;\n    }\n  };\n\n  // Returns an array of arrays with the coordinates of the supplied feature\n  #getFeatureCoordinates = (feature) => {\n    // First, we have to extract the feature geometry\n    const geometry = feature.getGeometry();\n    // Then we'll have to extract the feature type, since we have to extract the\n    // coordinates in different ways, depending on the geometry type.\n    const geometryType = geometry.getType();\n    // Then we'll use a switch-case to make sure we return the coordinates in\n    // the correct format.\n    switch (geometryType) {\n      case \"Circle\":\n        // If we're dealing with a circle, we'll create a simplified geometry\n        // with 8 points, which we can use to highlight some of the \"nodes\" of\n        // the circle. GetCoordinates returns the coordinates in an extra wrapping\n        // array (for polygons), so let's return the first element.\n        return fromCircle(geometry, 8).getCoordinates()[0];\n      case \"LineString\":\n        // GetCoordinates returns an array of arrays with coordinates for LineStrings,\n        // so we can return it as-is.\n        return geometry.getCoordinates();\n      case \"Point\":\n        // GetCoordinates returns an array with the coordinates for points,\n        // so we have to wrap that array in an array before returning.\n        return [geometry.getCoordinates()];\n      default:\n        // The default catches Polygons, which are wrapped in an \"extra\" array, so let's\n        // return the first element.\n        return geometry.getCoordinates()[0];\n    }\n  };\n\n  // Returns the area, perimeter, and/or length of the supplied feature in a readable format.\n  #getFeatureMeasurementLabel = (feature, labelType) => {\n    // First we must get the feature measurements (The returned measurements will differ\n    // Depending on if we're dealing with Point, LineString, or surface).\n    const measurements = this.#getFeatureMeasurements(feature);\n    // Then we'll reduce the measurements down to a string that we can show.\n    return measurements.reduce((acc, curr) => {\n      switch (curr.type) {\n        case \"COORDINATES\":\n          return (acc += `N: ${Math.round(curr.value[1])} E: ${Math.round(\n            curr.value[0]\n          )}`);\n        case \"AREA\":\n        case \"PERIMETER\":\n        case \"LENGTH\":\n          return (acc += this.#getFormattedMeasurementString(curr, labelType));\n        default:\n          return acc;\n      }\n    }, \"\");\n  };\n\n  #getFormattedMeasurementString = (measurement, labelType) => {\n    // Let's destruct some measurement-information that we can\n    // use to construct the measurement-string.\n    const { type, value, prefix } = measurement;\n    // We have to make sure that we're supposed to show the measurement-text.\n    // This is controlled in the measurement-settings, but is also affected by\n    // the supplied type (if we're creating a tooltip, we're always showing everything!).\n    const showMeasurement =\n      labelType === \"TOOLTIP\" ||\n      (type === \"LENGTH\" && this.#measurementSettings.showLength) ||\n      (type === \"AREA\" && this.#measurementSettings.showArea) ||\n      (type === \"PERIMETER\" && this.#measurementSettings.showPerimeter);\n    // If we're not supposed to be showing the measurement, lets return an empty string.\n    if (!showMeasurement) {\n      return \"\";\n    }\n    // Otherwise we'll handle the formatting according to the labelFormat set by the user\n    switch (this.#getLabelFormatFromMeasurementType(type)) {\n      case \"AUTO\":\n        const formatted = this.#shouldFormatToKm(value, type)\n          ? this.#getKilometerMeasurementString(value, type)\n          : this.#getMeasurementString(value, type);\n        return `${prefix} ${formatted}`;\n      case \"KM\":\n      case \"KM2\":\n        // If the format is \"KM2\", we'll show the measurement in km²\n        // (Or km if we're measuring length). Rounded to show 3 decimals.\n        return `${prefix} ${this.#getKilometerMeasurementString(value, type)}`;\n      case \"HECTARE\":\n        // If the format is \"HECTARE\" we will show the measurement in hectare\n        // if we're dealing with a surface. If we're dealing with a lineString\n        // we will return the measurement with \"M2\" format.\n        return `${prefix} ${this.#getHectareMeasurementString(value, type)}`;\n      default:\n        // Otherwise m² (or m) will do. (Displayed in local format).\n        return `${prefix} ${this.#getMeasurementString(value, type)}`;\n    }\n  };\n\n  #getLabelFormatFromMeasurementType = (type) => {\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return this.#measurementSettings.lengthUnit;\n      default:\n        return this.#measurementSettings.areaUnit;\n    }\n  };\n\n  // Checks if the supplied value and type should be formatted to km or not.\n  #shouldFormatToKm = (value, type) => {\n    // If the format is AUTO, we're checking if the measurement is large\n    // enough to show it in kilometers or not. First, we need to set\n    // the cutoff points for the kilometer display.\n    const lengthCutOff = 1e3;\n    const areaCutOff = 1e6;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return value > lengthCutOff;\n      default:\n        return value > areaCutOff;\n    }\n  };\n\n  // Returns the label text that should be shown on the feature.\n  // Usually the text is constructed by the measurement of the feature,\n  // but if the feature is of text-type, we show the user-added-text.\n  #getFeatureLabelText = (feature) => {\n    // Are we dealing with a text-feature? Let's return the user-\n    // added-text.\n    if (feature.get(\"DRAW_METHOD\") === \"Text\") {\n      return feature.get(\"USER_TEXT\") ?? \"\";\n    }\n    // There might be a title present on the feature, if there is, we'll want\n    // to display it.\n    const featureTitle = feature.get(\"FEATURE_TITLE\") ?? \"\";\n    // We'll also have to grab the eventual measurement-label\n    const measurementLabel = this.#measurementSettings.showText\n      ? this.#getFeatureMeasurementLabel(feature, \"LABEL\")\n      : \"\";\n    // Finally, we can return the eventual title, and the eventual measurement-label combined.\n    return featureTitle.length > 0\n      ? `${featureTitle}${\n          measurementLabel.length > 0 ? \"\\n\" : \"\"\n        }${measurementLabel}`\n      : measurementLabel;\n  };\n\n  // Returns the supplied measurement as a kilometer-formatted string.\n  // If we're measuring area, km² is returned, otherwise, km is returned.\n  #getKilometerMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return `${Number(\n          (featureMeasure / 1e3).toFixed(precision)\n        ).toLocaleString()} km`;\n      default:\n        return `${Number(\n          (featureMeasure / 1e6).toFixed(precision)\n        ).toLocaleString()} km²`;\n    }\n  };\n\n  // Returns the measurement in hectare if we're dealing with a surface, and if\n  // we're dealing with a line-string we return the measurement in metres.\n  #getHectareMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return this.#getMeasurementString(featureMeasure, type);\n      default:\n        return `${Number(\n          (featureMeasure / 1e4).toFixed(precision)\n        ).toLocaleString()} ha`;\n    }\n  };\n\n  // Returns the supplied measurement as a locally formatted string.\n  // If we're measuring area m² is returned, otherwise, m is returned.\n  #getMeasurementString = (featureMeasure, type) => {\n    // The precision can be changed by the user and is set in the measurement-settings.\n    const precision = this.#measurementSettings.precision ?? 0;\n    switch (type) {\n      case \"LENGTH\":\n      case \"PERIMETER\":\n        return `${Number(\n          featureMeasure.toFixed(precision)\n        ).toLocaleString()} m`;\n      default:\n        return `${Number(\n          featureMeasure.toFixed(precision)\n        ).toLocaleString()} m²`;\n    }\n  };\n\n  // Calculates the area, length, or placement of the supplied feature.\n  // Accepts an OL-feature, and is tested for Circle, LineString, Point, and Polygon.\n  #getFeatureMeasurements = (feature) => {\n    // Let's get the geometry-type to begin with, we are going\n    // to be handling points, line-strings, and surfaces differently.\n    const geometry = feature.getGeometry();\n    // If we're dealing with a point, we simply return the coordinates of the point.\n    if (geometry instanceof Point) {\n      return [\n        { type: \"COORDINATES\", value: geometry.getCoordinates(), prefix: \"\" },\n      ];\n    }\n    // If the user has chosen to only show the area (and not the perimeter), we don't\n    // need to show the area-prefix. The area-prefix should only be shown if both area and\n    // perimeter is chosen to be shown.\n    const showAreaPrefix =\n      this.#measurementSettings.showArea &&\n      this.#measurementSettings.showPerimeter;\n    // Apparently the circle geometry instance does not expose a\n    // getArea method. Here's a quick fix. (Remember that this area\n    // is only used as an heads-up for the user.)\n    if (geometry instanceof CircleGeometry) {\n      const radius = geometry.getRadius();\n      return [\n        {\n          type: \"AREA\",\n          value: Math.pow(radius, 2) * Math.PI,\n          prefix: `${showAreaPrefix ? \"Area:\" : \"\"}`,\n        },\n        {\n          type: \"PERIMETER\",\n          value: radius,\n          prefix: \"\\n Radie:\",\n        },\n      ];\n    }\n    // If we're dealing with a line we cannot calculate an area,\n    // instead, we only calculate the length.\n    if (geometry instanceof LineString) {\n      return [{ type: \"LENGTH\", value: geometry.getLength(), prefix: \"\" }];\n    }\n    // If we're not dealing with a point, circle, or a line, we are probably dealing\n    // with a polygon. For the polygons, we want to return the area and perimeter.\n    return [\n      {\n        type: \"AREA\",\n        value: geometry?.getArea() || 0,\n        prefix: `${showAreaPrefix ? \"Area:\" : \"\"}`,\n      },\n      {\n        type: \"PERIMETER\",\n        value: this.#getPolygonPerimeter(geometry),\n        prefix: \"\\n Omkrets:\",\n      },\n    ];\n  };\n\n  // Returns the perimeter of the supplied polygon-geometry\n  #getPolygonPerimeter = (geometry) => {\n    try {\n      // To get the perimeter, we have to get the coordinates of the\n      // outer (0) linear-ring of the supplied geometry. If we fail to extract these\n      // coordinates, we set the linear-ring-coords to null.\n      const linearRingCoords =\n        geometry?.getLinearRing(0)?.getCoordinates() || null;\n      // If no coords were found, we simply return an area of 0.\n      if (!linearRingCoords) {\n        return 0;\n      }\n      // If some coords were found, we can construct a Line-string, and get the length\n      // of that line-string!\n      return new LineString(linearRingCoords)?.getLength() || 0;\n    } catch (error) {\n      // If we fail somewhere, we return 0. Would be better with more handling here!\n      return 0;\n    }\n  };\n\n  // Returns an OL style to be used in the draw-interaction.\n  #getDrawStyle = (settings) => {\n    return new Style({\n      stroke: this.#getDrawStrokeStyle(settings),\n      fill: this.#getDrawFillStyle(settings),\n      image: this.#getDrawImageStyle(settings),\n      zIndex: this.#getDrawZIndex(settings),\n    });\n  };\n\n  // Returns the stroke style (based on the style settings)\n  #getDrawStrokeStyle = (settings) => {\n    return new Stroke({\n      color: settings?.strokeStyle?.color\n        ? settings.strokeStyle.color\n        : this.#drawStyleSettings.strokeColor,\n      lineDash: settings?.strokeStyle\n        ? settings.strokeStyle.dash\n        : this.#drawStyleSettings.lineDash,\n      width: settings?.strokeStyle?.width\n        ? settings.strokeStyle.width\n        : this.#drawStyleSettings.strokeWidth,\n    });\n  };\n\n  // Returns the fill style (based on the style settings)\n  #getDrawFillStyle = (settings) => {\n    return new Fill({\n      color: settings?.fillStyle?.color\n        ? settings.fillStyle.color\n        : this.#drawStyleSettings.fillColor,\n    });\n  };\n\n  // Returns the feature zIndex\n  #getDrawZIndex = (settings) => {\n    return settings?.zIndex || 0;\n  };\n\n  // Returns the image style (based on the style settings)\n  #getDrawImageStyle = (settings) => {\n    if (this.#customGetDrawImageStyle) {\n      return this.#customGetDrawImageStyle();\n    }\n\n    // If image style is present we will use it\n    // Otherwise we need to fallback to default style (same as drawing) as it is used in Sketch plugin\n    const storedSettings = this.#drawStyleSettings.image\n      ? this.#drawStyleSettings.image\n      : this.#drawStyleSettings;\n\n    return new Circle({\n      radius: 6,\n      stroke: new Stroke({\n        color: settings?.strokeStyle?.color\n          ? settings.strokeStyle.color\n          : storedSettings.strokeColor,\n        width: settings?.strokeStyle?.width\n          ? settings.strokeStyle.width\n          : storedSettings.strokeWidth,\n        lineDash: settings?.strokeStyle\n          ? settings.strokeStyle.dash\n          : storedSettings.lineDash,\n      }),\n      fill: new Fill({\n        color: settings?.fillStyle?.color\n          ? settings.fillStyle.color\n          : storedSettings.fillColor,\n      }),\n    });\n  };\n\n  // Extracts the fill-style from the supplied feature-style\n  #getFillStyleInfo = (featureStyle) => {\n    try {\n      // Since we might be dealing with a style-array instead of a style-object\n      // (in case of the special Arrow feature-type) we have to make sure to get\n      // the actual base-style (which is located at position 0 in the style-array).\n      const color = Array.isArray(featureStyle)\n        ? featureStyle[0]?.getFill()?.getColor()\n        : featureStyle?.getFill()?.getColor();\n      return { color: this.getRGBAString(color) };\n    } catch (error) {\n      console.error(`Failed to extract fill-style, ${error.message}`);\n      return { color: null };\n    }\n  };\n\n  // Extracts the stroke-style from the supplied feature-style\n  #getStrokeStyleInfo = (featureStyle) => {\n    try {\n      // Since we might be dealing with a style-array instead of a style-object\n      // (in case of the special Arrow feature-type) we have to make sure to get\n      // the actual base-style (which is located at position 0 in the style-array).\n      const s = Array.isArray(featureStyle)\n        ? featureStyle[0]?.getStroke()\n        : featureStyle?.getStroke();\n      const color = s?.getColor();\n      const dash = s?.getLineDash();\n      const width = s?.getWidth();\n      return {\n        color: this.getRGBAString(color),\n        dash,\n        width,\n      };\n    } catch (error) {\n      console.error(`Failed to extract stroke-style, ${error.message}`);\n      return { color: null, dash: null, width: null };\n    }\n  };\n\n  // Extracts the image-style from the supplied feature-style\n  #getImageStyleInfo = (featureStyle) => {\n    // Since we might be dealing with a style-array instead of a style-object\n    // (in case of the special Arrow feature-type) we have to make sure to get\n    // the actual base-style (which is located at position 0 in the style-array).\n    const s = Array.isArray(featureStyle)\n      ? featureStyle[0]?.getImage()\n      : featureStyle?.getImage();\n    // Let's extract the fill- and stroke-style from the image-style.\n    const fillStyle = s?.getFill?.();\n    const strokeStyle = s?.getStroke?.();\n    // Let's make sure the image-style has fill- and stroke-style before moving on\n    if (!fillStyle || !strokeStyle) {\n      return {\n        fillColor: null,\n        strokeColor: null,\n        strokeWidth: null,\n        dash: null,\n      };\n    }\n    const fillColor = fillStyle.getColor();\n    const strokeColor = strokeStyle.getColor();\n    const strokeWidth = strokeStyle.getWidth();\n    const dash = strokeStyle.getLineDash();\n    return {\n      fillColor: this.getRGBAString(fillColor),\n      strokeColor: this.getRGBAString(strokeColor),\n      strokeWidth,\n      dash,\n    };\n  };\n\n  // Extracts and returns information about the feature style.\n  extractFeatureStyleInfo = (feature) => {\n    // Let's run this in a try-catch since we cannot be sure that a\n    // real feature is supplied. (I.e. getStyle() etc. might not exist).\n    try {\n      const featureStyle = feature?.getStyle();\n      // If no feature was supplied, or if we're unable to extract the style,\n      // we return null.\n      if (!featureStyle) {\n        return { fillStyle: null, strokeStyle: null, imageStyle: null };\n      }\n      // If we were able to extract the style we can continue by extracting\n      // the fill- and stroke-style.\n      const fillStyle = this.#getFillStyleInfo(featureStyle);\n      const strokeStyle = this.#getStrokeStyleInfo(featureStyle);\n      const imageStyle = this.#getImageStyleInfo(featureStyle);\n\n      const zIndex = (\n        Array.isArray(featureStyle) ? featureStyle[0] : featureStyle\n      ).getZIndex();\n\n      // And return an object containing them\n      return { fillStyle, strokeStyle, imageStyle, zIndex };\n    } catch (error) {\n      console.error(`Failed to extract feature-style. Error: ${error}`);\n      return {\n        fillStyle: null,\n        strokeStyle: null,\n        imageStyle: null,\n        zIndex: 0,\n      };\n    }\n  };\n\n  // Updates the text-style on all drawn features. Used when toggling\n  // if the measurement-label should be shown or not for example.\n  #refreshFeaturesTextStyle = () => {\n    // Get all the drawn features (Except for arrows, these doesn't have any text\n    // and shouldn't be refreshed)...\n    const drawnFeatures = this.getAllDrawnFeatures().filter(\n      (f) => f.get(\"DRAW_METHOD\") !== \"Arrow\"\n    );\n    // Iterate the drawn features...\n    drawnFeatures.forEach((feature) => {\n      // Get the current style.\n      const featureStyle = feature.getStyle();\n      // Get an updated text-style (which depends on the #measurementSettings).\n      const textStyle = this.#getFeatureTextStyle(feature);\n      // Set the updated text-style on the base-style.\n      Array.isArray(featureStyle)\n        ? featureStyle[0].setText(textStyle)\n        : featureStyle.setText(textStyle);\n      // Then update the feature style.\n      feature.setStyle(featureStyle);\n    });\n  };\n\n  // Returns a new vector source.\n  #getNewVectorSource = () => {\n    return new VectorSource({ wrapX: false });\n  };\n\n  // Returns a new vector layer connected to the supplied source.\n  #getNewVectorLayer = (source) => {\n    return new VectorLayer({\n      source: source,\n      layerType: \"system\",\n      ignoreInFeatureInfo: true,\n      zIndex: 5000,\n      caption: this.#layerCaption || \"Draw layer\",\n    });\n  };\n\n  // Returns all user drawn features from the draw-source\n  getAllDrawnFeatures = () => {\n    return this.#drawSource.getFeatures().filter((feature) => {\n      return feature.get(\"USER_DRAWN\") === true;\n    });\n  };\n\n  // Fits the map to the current extent of the draw-source (with some padding).\n  #fitMapToExtent = () => {\n    this.#map.getView().fit(this.#currentExtent, {\n      size: this.#map.getSize(),\n      padding: [20, 20, 20, 20],\n      maxZoom: 7,\n    });\n  };\n\n  // Removes all event-listeners that have been set when initiating the\n  // draw interaction.\n  #removeEventListeners = () => {\n    // Remove the \"ordinary\" listeners\n    this.#drawInteraction.un(\"drawstart\", this.#handleDrawStart);\n    this.#drawInteraction.un(\"drawend\", this.#handleDrawEnd);\n    this.#drawInteraction.un(\"drawabort\", this.#handleDrawAbort);\n    this.#map.un(\"pointermove\", this.#handlePointerMove);\n    this.#drawSource.un(\"addfeature\", this.#handleDrawFeatureAdded);\n    document.removeEventListener(\"keydown\", this.#handleKeyDown);\n    // Then we'll remove the custom listeners\n    this.#removeCustomEventListeners();\n  };\n\n  // Adds all event-listeners needed for the the draw interaction.\n  #addEventListeners = (settings) => {\n    // The initiator of the draw interaction might have passed some custom functions\n    // that should be called when the appropriate event fires. We have to make sure\n    // to bind those if they exist.\n    settings && this.#addCustomEventListeners(settings);\n    // Add a listener for the draw-start-event\n    this.#drawInteraction.on(\"drawstart\", this.#handleDrawStart);\n    // Add a listener for the draw-end-event\n    this.#drawInteraction.on(\"drawend\", this.#handleDrawEnd);\n    // Add a listener for when drawing is aborted (e.g. if all points are\n    // removed by pressing esc several times).\n    this.#drawInteraction.on(\"drawabort\", this.#handleDrawAbort);\n    // We need a listener for when a feature is added to the source.\n    this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n    // We need a listener for keyboard input. For example, pressing the escape\n    // key will allow the users to remove the last point.\n    document.addEventListener(\"keydown\", this.#handleKeyDown);\n  };\n\n  // Adds listeners that might have been passed in the settings when\n  // initiating the draw interaction.\n  #addCustomEventListeners = (settings) => {\n    // Let's update all internal fields so that we can keep track of the\n    // custom handlers.\n    this.#customHandleDrawStart = settings.handleDrawStart || null;\n    this.#customHandleDrawEnd = settings.handleDrawEnd || null;\n    this.#customHandlePointerMove = settings.handlePointerMove || null;\n    this.#customHandleAddFeature = settings.handleAddFeature || null;\n    // Then we'll add the listeners if the corresponding handler exists\n    this.#customHandleDrawStart &&\n      this.#drawInteraction.on(\"drawstart\", this.#customHandleDrawStart);\n    this.#customHandleDrawEnd &&\n      this.#drawInteraction.on(\"drawend\", this.#customHandleDrawEnd);\n    this.#customHandlePointerMove &&\n      this.#map.on(\"pointermove\", this.#customHandlePointerMove);\n    this.#customHandleAddFeature &&\n      this.#drawSource.on(\"addfeature\", this.#customHandleAddFeature);\n  };\n\n  // Removes listeners that might have been passed in the settings when\n  // initiating the draw interaction.\n  #removeCustomEventListeners = () => {\n    // Let's unbind the listers if they ever existed\n    this.#customHandleDrawStart &&\n      this.#drawInteraction.un(\"drawstart\", this.#customHandleDrawStart);\n    this.#customHandleDrawEnd &&\n      this.#drawInteraction.un(\"drawend\", this.#customHandleDrawEnd);\n    this.#customHandlePointerMove &&\n      this.#map.on(\"pointermove\", this.#customHandlePointerMove);\n    this.#customHandleAddFeature &&\n      this.#drawSource.un(\"addfeature\", this.#customHandleAddFeature);\n    // Then we have to make sure to remove the reference to the handlers.\n    this.#customHandleDrawStart = null;\n    this.#customHandleDrawEnd = null;\n    this.#customHandlePointerMove = null;\n    this.#customHandleAddFeature = null;\n  };\n\n  // This handler has a couple of jobs; add a change listener to the feature\n  // currently being drawn, and register an event-handler for pointer moves.\n  #handleDrawStart = (e) => {\n    // Let's add a handler for the pointer event to keep\n    // track of where the users pointer is located.\n    this.#map.on(\"pointermove\", this.#handlePointerMove);\n    // Then we'll add a handler handling feature changes.\n    const feature = e.feature;\n    feature.on(\"change\", this.#handleFeatureChange);\n    // Finally, we'll make sure the feature being drawn has the correct style:\n    feature.setStyle(this.#getDrawStyle());\n  };\n\n  // This handler will make sure that the overlay will be removed\n  // when the feature drawing is done.\n  #handleDrawEnd = (e) => {\n    // Let's make sure to reset the draw tooltip\n    this.#resetDrawTooltip();\n    const { feature } = e;\n    // We set the USER_DRAWN prop to true so that we can keep track\n    // of the user drawn features. We also set \"DRAW_TYPE\" so that we can\n    // handle special features, such as arrows.\n    feature.set(\"USER_DRAWN\", true);\n    feature.set(\"DRAW_METHOD\", this.#drawInteraction?.get(\"DRAW_METHOD\"));\n    feature.set(\"TEXT_SETTINGS\", this.#textStyleSettings);\n    // And set a nice style on the feature to be added.\n    feature.setStyle(this.#getFeatureStyle(feature));\n    // Make sure to remove the event-listener for the pointer-moves.\n    // (We don't want the pointer to keep updating while we're not drawing).\n    this.#map.un(\"pointermove\", this.#handlePointerMove);\n  };\n\n  // Handler that will fire when features has been modified with the modify-interaction.\n  // Makes sure to update the text-styling so that eventual measurement-label is up-to-date.\n  #handleModifyEnd = (e) => {\n    e.features.forEach((f) => {\n      // If we're dealing with arrows, we have to make sure to\n      // update the whole style, so that the arrow-head is moved.\n      if (f.get(\"DRAW_METHOD\") === \"Arrow\") {\n        this.#refreshArrowStyle(f);\n      }\n    });\n    this.#refreshFeaturesTextStyle();\n  };\n\n  // Re-calculates and re-applies the arrow style. For ordinary features this is\n  // not required, but since the arrows consists of an svg, we have to re-calculate\n  // the style to make sure the svg gets the correct color.\n  #refreshArrowStyle = (f) => {\n    try {\n      const strokeStyle = f.getStyle()[0].getStroke();\n      f.setStyle(\n        this.#getArrowStyle(f, {\n          strokeStyle: {\n            color: strokeStyle.getColor(),\n          },\n          fillStyle: { color: strokeStyle.getColor() },\n        })\n      );\n    } catch (error) {\n      console.error(`Failed to set arrow style. Error: ${error}`);\n    }\n  };\n\n  // Cleans up if the drawing is aborted.\n  #handleDrawAbort = () => {\n    this.#resetDrawTooltip();\n  };\n\n  #resetDrawTooltip = () => {\n    this.#drawTooltipElement.innerHTML = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // This handler will make sure that we keep the measurement calculation\n  // updated during the feature changes.\n  #handleFeatureChange = (e) => {\n    // Make the measurement calculations and update the tooltip\n    const feature = e.target;\n    const toolTipText = this.#getFeatureMeasurementLabel(feature, \"TOOLTIP\");\n    this.#drawTooltipElement.innerHTML = this.#showDrawTooltip\n      ? toolTipText\n      : null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // This handler has one job; get the coordinate from the event,\n  // and store it for later use. *But only if the draw tooltip should be active! If\n  // the draw tooltip is disabled, we set the coordinate to null*\n  #handlePointerMove = (e) => {\n    this.#currentPointerCoordinate = this.#showDrawTooltip\n      ? e.coordinate\n      : null;\n  };\n\n  // We're probably going to need a handler for when a feature is added.\n  // For now, let's publish an event on the observer.\n  #handleDrawFeatureAdded = (e) => {\n    this.#publishInformation({\n      subject: \"drawModel.featureAdded\",\n      payLoad: e.feature,\n    });\n  };\n\n  // We want to handle key-up events so that we can let the user\n  // remove the last drawn point by pressing the escape key. (And perhaps more...?)\n  #handleKeyDown = (e) => {\n    if (!this.#drawInteraction) return;\n    const { keyCode, ctrlKey, metaKey } = e;\n    if (keyCode === 27 || keyCode === 13) {\n      // escape or enter finishes drawing\n      this.finishDraw();\n    } else if ((ctrlKey === true || metaKey === true) && keyCode === 90) {\n      // Ctrl+Z or Cmd+Z removes last draw point\n      this.#drawInteraction.removeLastPoint();\n    }\n  };\n\n  // Disables the current draw interaction\n  #disablePotentialInteraction = () => {\n    // First we check if any of the \"special\" interactions are active, and if they\n    // are, we disable them.\n    if (this.#removeInteractionActive) {\n      return this.#disableRemoveInteraction();\n    }\n    if (this.#editInteractionActive) {\n      return this.#disableEditInteraction();\n    }\n    if (this.#moveInteractionActive) {\n      return this.#disableMoveInteraction();\n    }\n    if (this.#selectInteractionActive) {\n      this.#disableSelectInteraction();\n    }\n    if (this.#circleInteractionActive) {\n      this.#disableCircleInteraction();\n    }\n    // If there isn't an active draw interaction currently, we just return.\n    if (!this.#drawInteraction) return;\n    // Otherwise, we remove the interaction from the map.\n    this.#map.removeInteraction(this.#drawInteraction);\n    // Then we'll make sure to remove all event-listeners\n    this.#removeEventListeners();\n    // We're also making sure to set the private field to null\n    this.#drawInteraction = null;\n    // And remove the click-lock and the snap-helper\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n  };\n\n  // Creates an object that can be returned to the initiator of a\n  // set:er if the set:er fails due to a bad value provided.\n  #getSetFailedObject = (field, providedValue) => {\n    return {\n      status: \"FAILED\",\n      message: `Set:er failed. The set:er only accepts ${typeof field}, and was provided ${typeof providedValue}`,\n    };\n  };\n\n  // Removes the first feature that is present at the supplied\n  // pixel from the click-event.\n  #removeClickedFeature = (e) => {\n    // Get features present at the clicked feature.\n    const clickedFeatures = this.#map.getFeaturesAtPixel(e.pixel);\n    // We only care about features that have been drawn by a user.\n    const userDrawnFeatures = clickedFeatures.filter((f) =>\n      f.get(\"USER_DRAWN\")\n    );\n    // Let's make sure we found some feature(s) to remove. We're only removing\n    // the first one.\n    if (userDrawnFeatures.length > 0) {\n      // Let's get the first user-drawn feature\n      const feature = userDrawnFeatures[0];\n      // Then we remove it from the draw-source\n      this.removeFeature(feature);\n    }\n  };\n\n  // Publishes a modify-message with the clicked feature in the payload.\n  #editClickedFeature = (e) => {\n    // Get features present at the clicked feature.\n    const clickedFeatures = this.#map.getFeaturesAtPixel(e.pixel);\n    // We only care about features that have been drawn by a user.\n    const userDrawnFeatures = clickedFeatures.filter((f) =>\n      f.get(\"USER_DRAWN\")\n    );\n    // Let's get the (potential) first user-drawn feature, otherwise null.\n    const feature = userDrawnFeatures.length > 0 ? userDrawnFeatures[0] : null;\n    // Then we'll update the private field holding the feature currently chosen for editing.\n    this.#updateChosenEditFeature(feature);\n    // Then we'll publish a modify-message with the clicked feature in the payload (or null).\n    this.#publishInformation({\n      subject: \"drawModel.modify.mapClick\",\n      payLoad: feature,\n    });\n  };\n\n  // Updates the private field holding the feature which is currently chosen\n  // for edit. Also makes sure to set the \"EDIT_ACTIVE\" prop to false on the\n  // feature that is no longer chosen, and to true on the chosen feature.\n  // The \"EDIT_ACTIVE\" prop is used to style the chosen feature.\n  #updateChosenEditFeature = (feature) => {\n    this.#featureChosenForEdit &&\n      this.#featureChosenForEdit.set(\"EDIT_ACTIVE\", false);\n    // If we have a new feature clicked, and if the feature is not already\n    // marked as \"EDIT_ACTIVE\" (selected for edit), we set \"EDIT_ACTIVE\" to true.\n    feature && !feature.get(\"EDIT_ACTIVE\") && feature.set(\"EDIT_ACTIVE\", true);\n    // Let's update the chosen feature with whatever was clicked (might be null).\n    this.#featureChosenForEdit = feature;\n  };\n\n  // Refreshes the snap-helper by removing it and then adding it again.\n  #refreshSnapHelper = () => {\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Enables a remove-interaction which allows the user to remove drawn features by clicking on them.\n  // We're also making sure to enable the click-lock so that the feature-info does not infer.\n  #enableRemoveInteraction = () => {\n    // We have to make sure to set a field so that the handlers responsible for deleting\n    // all active interactions knows that there is a remove-interaction to delete.\n    this.#removeInteractionActive = true;\n    // Let's add the clickLock to avoid the featureInfo etc.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    // Then we'll add the event-handler responsible for removing clicked features.\n    this.#map.on(\"singleclick\", this.#removeClickedFeature);\n  };\n\n  // Disables the remove-interaction by removing the event-listener and disabling\n  // the click-lock.\n  #disableRemoveInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#removeClickedFeature);\n    this.#removeInteractionActive = false;\n  };\n\n  // Enables an edit-interaction which allows the user to edit the shape of user-drawn\n  // features. The draw-model also makes sure to enable an on-click handler that publish\n  // an event when a feature is clicked (i.e. chosen for editing).\n  #enableEditInteraction = (settings) => {\n    // Let's set a field so that we know that edit is enabled.\n    this.#editInteractionActive = true;\n    // We're gonna need a handler that can update the feature-style when\n    // the modification is completed.\n    this.#map.on(\"singleclick\", this.#editClickedFeature);\n    // We also need a listener which listens for property-changes on the features.\n    // (We use a property on the feature to show that it is currently being edited).\n    this.#bindFeaturePropertyListener();\n    // Let's add the clickLock to avoid the featureInfo etc.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    // Usually, the modify interaction is enabled at the same time as the edit-interaction,\n    // allowing the user to change the feature geometry.\n    // The user might pass \"modifyEnabled: false\" in the toggle-draw-settings, and in that case\n    // we do not enable the modify-interaction. Otherwise we check the \"keepModifyActive\" field,\n    // which keeps track of if the user had modify enabled the last time they enabled the edit-interaction.\n    (settings.modifyEnabled ?? this.#keepModifyActive) &&\n      this.#enableModifyInteraction();\n  };\n\n  // Disables the edit-interaction by removing the event-listener and disabling\n  // the click-lock.\n  #disableEditInteraction = () => {\n    // Remove the click-lock so that the feature-info works again,\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    // Remove the event-listener\n    this.#map.un(\"singleclick\", this.#editClickedFeature);\n    // We also have to make sure to de-select the eventual features which might be selected for editing.\n    this.#removeFeatureEditSelection();\n    // Remove the feature-property-change-listener\n    this.#unBindFeaturePropertyListener();\n    // Disable the potential modify-interaction (it should only be active when the edit-interaction\n    // is active).\n    this.#disableModifyInteraction();\n    // Finally, we reset the field so we know that the interaction is no longer active.\n    this.#editInteractionActive = false;\n  };\n\n  #enableModifyInteraction = () => {\n    // If the edit-interaction is not active, we shouldn't enable the modify-interaction.\n    // The modify-interaction is an interaction that should be used on-top of the edit-interaction.\n    if (!this.#editInteractionActive) {\n      return {\n        status: \"FAILED\",\n        message:\n          \"Modify-interaction could not be enabled. Edit has to be enabled before enabling.\",\n      };\n    }\n    // Let's disable potential interaction that might be enabled already\n    this.#disableModifyInteraction();\n    // We have to make sure to set a field so that the handlers responsible for deleting\n    // all active interactions knows that there is an edit-interaction to delete.\n    this.#modifyInteraction = new Modify({ source: this.#drawSource });\n    // We're gonna need a handler that can update the feature-style when\n    // the modification is completed.\n    this.#modifyInteraction.on(\"modifyend\", this.#handleModifyEnd);\n    // Then we'll add the interaction to the map.\n    this.#map.addInteraction(this.#modifyInteraction);\n    // Let's add the clickLock to avoid the featureInfo etc...\n    this.#map.clickLock.add(\"coreDrawModel\");\n    //  ...and snap-helper for the snap-functionality.\n    this.#map.snapHelper.add(\"coreDrawModel\");\n    // Finally we return something so that the enabler knows that we've enabled.\n    return {\n      status: \"SUCCESS\",\n      message: \"Modify-interaction enabled.\",\n    };\n  };\n\n  // Disables and removes the Modify-interaction if there is one active currently.\n  #disableModifyInteraction = () => {\n    // If the modify-interaction is not active, we can abort.\n    if (!this.#modifyInteraction) {\n      return;\n    }\n    // Otherwise, let's disable it. First remove the interaction.\n    this.#map.removeInteraction(this.#modifyInteraction);\n    // Then we'll remove the event-listener\n    this.#modifyInteraction.un(\"modifyend\", this.#handleModifyEnd);\n    // And remove the snap-helper.\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    // Then we'll reset the field referring to the interaction\n    this.#modifyInteraction = null;\n  };\n\n  // Enables the Move-interaction (An interaction allowing the user to move features by selecting\n  // amount of meters and degrees the selected features should be moved). It is also possible to\n  // add a Translate-interaction on top, allowing the user to move features in the map by dragging them.\n  // The Translate-interaction is added by default if the draw-model is initiated with keepTranslateActive: true,\n  // and can be added afterwards calling setTranslateActive or by providing translateEnabled: true when enabling the\n  // Move-interaction.\n  #enableMoveInteraction = (settings) => {\n    // The Move-interaction will obviously need a Select-interaction so that the features to\n    // move can be selected. We provide `null` as style - this will cancel the default OL Select\n    // interaction (which was problematic in some situations, see #1225).\n    this.#selectInteraction = new Select({\n      layers: [this.#drawLayer],\n      style: null,\n    });\n\n    // We need a handler catching the \"select\"-events so that we can keep track of if any\n    // features has been selected or not.\n    this.#selectInteraction.on(\"select\", this.#handleFeatureSelect);\n    // Then we'll add the interaction to the map...\n    this.#map.addInteraction(this.#selectInteraction);\n    // When this is done, we can set the private field keeping track of\n    // if the Move-interaction is active or not.\n    this.#moveInteractionActive = true;\n    // If we should enable the Translate-interaction, we do that as well.\n    (settings.translateEnabled ?? this.#keepTranslateActive) &&\n      this.#enableTranslateInteraction();\n    // ...finally we'll add the snap- and clickLock-helpers.\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Enables a Translate-interaction, allowing users to move features by dragging them\n  // in the map.\n  #enableTranslateInteraction = () => {\n    // If the base Move-interaction is not active, the Translate-interaction cannot be enabled.\n    if (!this.#moveInteractionActive) {\n      return {\n        status: \"FAILED\",\n        message:\n          \"Translate-interaction could not be enabled. Move has to be enabled before enabling.\",\n      };\n    }\n    // Otherwise, we can create a new Translate-interaction...\n    this.#translateInteraction = new Translate({\n      features: this.#selectInteraction.getFeatures(),\n    });\n    // ...and add it to the map!\n    this.#map.addInteraction(this.#translateInteraction);\n    // We also have to make sure to refresh the snap-helper, otherwise\n    // the snap won't work on the translate-features.\n    this.#refreshSnapHelper();\n  };\n\n  // Disabled the Move-interaction and removed it from the map.\n  #disableMoveInteraction = () => {\n    // First, we'll remove the Move-interaction from the map\n    this.#map.removeInteraction(this.#selectInteraction);\n    // Then we'll remove the \"select\"-event-listener\n    this.#selectInteraction.un(\"select\", this.#handleFeatureSelect);\n    // Then we'll remove (potentially, there might not be any) the Translate-interaction.\n    this.#disableTranslateInteraction();\n    // Let's update the private fields so that we know that the Select- and Move-interactions\n    // are disabled.\n    this.#selectInteraction = null;\n    this.#moveInteractionActive = false;\n    // And remove the clickLock- and snap-helpers.\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.snapHelper.delete(\"coreDrawModel\");\n    // We also have to make sure to refresh all the feature-styles so that\n    // they are up-to-date with any potential moves.\n    this.refreshDrawLayer();\n  };\n\n  // Disabled the Translate-interaction if there is one active.\n  #disableTranslateInteraction = () => {\n    if (this.#translateInteraction) {\n      this.#map.removeInteraction(this.#translateInteraction);\n      this.#translateInteraction = null;\n    }\n  };\n\n  // Enables possibility to draw a circle with fixed radius by 'single-click'\n  #enableCircleInteraction = () => {\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#circleInteractionActive = true;\n    this.#map.on(\"singleclick\", this.#createRadiusOnClick);\n  };\n\n  // Disables possibility to draw a circle with fixed radius by 'single-click'\n  #disableCircleInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#createRadiusOnClick);\n    this.#circleInteractionActive = false;\n  };\n\n  // Enables functionality so that the user can select features from the map and\n  // create a \"copy\" of that feature.\n  #enableSelectInteraction = () => {\n    this.#map.clickLock.add(\"coreDrawModel\");\n    this.#map.on(\"singleclick\", this.#handleOnSelectClick);\n    this.#selectInteractionActive = true;\n  };\n\n  #disableSelectInteraction = () => {\n    this.#map.clickLock.delete(\"coreDrawModel\");\n    this.#map.un(\"singleclick\", this.#handleOnSelectClick);\n    this.#selectInteractionActive = true;\n  };\n\n  drawSelectedFeature = (feature) => {\n    try {\n      // We create a new feature with the same geometry as the supplied one. This way\n      // we ensure that the copy and the original feature are not connected.\n      const featureCopy = new Feature({\n        geometry: feature.getGeometry().clone(),\n      });\n      // We're gonna need to set some properties on the new feature... First, we'll set an ID.\n      featureCopy.setId(Math.random().toString(36).substring(2, 15));\n      // Then we'll set some draw-properties from the original feature.\n      featureCopy.set(\"USER_DRAWN\", true);\n      featureCopy.set(\"DRAW_METHOD\", feature.get(\"DRAW_METHOD\"));\n      featureCopy.set(\"TEXT_SETTINGS\", feature.get(\"TEXT_SETTINGS\"));\n      // We're gonna need to set some styling on the feature as-well. Let's use the same\n      // styling as on the supplied feature.\n      featureCopy.setStyle(this.#getFeatureStyle(featureCopy));\n      // Then we can add the feature to the draw-layer!\n      this.#drawSource.addFeature(featureCopy);\n    } catch (error) {\n      console.error(`Failed to add selected feature. Error: ${error}`);\n    }\n  };\n\n  #handleOnSelectClick = async (event) => {\n    try {\n      // Try to fetch features from WMS-layers etc. (Also from all vector-layers).\n      const clickResult = await new Promise((resolve) =>\n        handleClick(event, event.map, resolve)\n      );\n      // The response should contain an array of features\n      const { features } = clickResult;\n      // Which might contain features without geometry. We have to make sure we remove those.\n      const featuresWithGeom = features.filter((feature) =>\n        feature.getGeometry()\n      );\n      // If we've fetched exactly one feature, we can add it straight away...\n      featuresWithGeom.length === 1 &&\n        this.drawSelectedFeature(featuresWithGeom[0]);\n      // If we have more than one feature, we'll have to let the user\n      // pick which features they want to add. Let's publish an event that the view can catch...\n      if (featuresWithGeom.length > 1) {\n        return this.#publishInformation({\n          subject: \"drawModel.select.click\",\n          payLoad: featuresWithGeom,\n        });\n      }\n    } catch (error) {\n      console.error(\n        `Failed to select features in drawModel... Error: ${error}`\n      );\n    }\n  };\n\n  // Creates a Feature with a circle geometry with fixed radius\n  // (If the radius is bigger than 0).\n  #createRadiusOnClick = (e) => {\n    // If the radius is zero we don't want to add a circle...\n    if (this.#circleRadius === 0) {\n      return;\n    }\n    // Create the feature\n    const feature = new Feature({\n      geometry: new CircleGeometry(e.coordinate, this.#circleRadius),\n    });\n    // Add the feature to the draw-source\n    this.#drawSource.addFeature(feature);\n    // Make sure to trigger the draw-end event so that all props etc. are\n    // set on the feature.\n    this.#handleDrawEnd({ feature });\n  };\n\n  // Handles the \"select\"-event that fires from the event-listener added when adding\n  // the Move-interaction.\n  #handleFeatureSelect = (e) => {\n    // Let's just publish the currently selected features on the observer so that\n    // the views can keep track of them if they want to.\n    this.#publishInformation({\n      subject: \"drawModel.move.select\",\n      payLoad: e.selected,\n    });\n    // We also has to refresh the draw-layer to make sure all the styling is updated.\n    // For example: If an arrow is moved, we have to refresh the style so that the arrow\n    // head is in the correct location.\n    e.deselected.forEach((f) => {\n      f.setStyle(this.#getFeatureStyle(f));\n    });\n  };\n\n  // Binds a listener to each feature which fires on property-change\n  #bindFeaturePropertyListener = () => {\n    this.#drawSource.forEachFeature((f) => {\n      f.on(\"propertychange\", this.#handleFeaturePropertyChange);\n    });\n  };\n\n  // Un-binds the property-change-listeners\n  #unBindFeaturePropertyListener = () => {\n    this.#drawSource.forEachFeature((f) => {\n      f.un(\"propertychange\", this.#handleFeaturePropertyChange);\n    });\n  };\n\n  // Handler targeted when any feature property has changed. If any property change, we have\n  // to make sure to refresh the draw-layer (since some properties affect the feature-styling!)\n  #handleFeaturePropertyChange = (e) => {\n    return this.refreshDrawLayer();\n  };\n\n  // Sets the \"EDIT_ACTIVE\" prop to false on all features in the draw-source.\n  // Used when disabling the edit-interaction, since we don't want any features\n  // selected for editing after the edit-interaction is removed.\n  #removeFeatureEditSelection = () => {\n    this.#drawSource.forEachFeature((f) => {\n      if (f.get(\"EDIT_ACTIVE\")) {\n        f.set(\"EDIT_ACTIVE\", false);\n      }\n    });\n  };\n\n  // Toggles the draw-interaction on and off if it is currently on.\n  // This refresh makes sure new settings are applied.\n  #refreshDrawInteraction = () => {\n    if (this.#drawInteraction) {\n      this.toggleDrawInteraction(this.#drawInteraction.get(\"DRAW_METHOD\"));\n    }\n  };\n\n  // Returns a valid draw-interaction-type from the supplied\n  // draw-method. For example, if the user wants to create a rectangle,\n  // the draw-interaction-type should apparently be \"Circle\".\n  #getDrawInteractionType = (method) => {\n    switch (method) {\n      case \"Arrow\":\n        return \"LineString\";\n      case \"Rectangle\":\n        return \"Circle\";\n      case \"Text\":\n        return \"Point\";\n      default:\n        return method;\n    }\n  };\n\n  // Returns wether we should be free-hand-drawing or not.\n  // Circles and Rectangles are always drawn with free-hand set to true.\n  #isFreeHandDrawing = (drawMethod, settings) => {\n    return [\"Circle\", \"Rectangle\"].includes(drawMethod)\n      ? true\n      : settings.freehand ?? false;\n  };\n\n  // Accepts a feature with \"CIRCLE_RADIUS\" and \"CIRCLE_CENTER\" properties.\n  // Updates the feature-geometry to a Circle-geometry with the supplied center and radius.\n  #createRealCircleGeometry = (feature) => {\n    try {\n      const center = JSON.parse(feature.get(\"CIRCLE_CENTER\"));\n      const radius = parseFloat(feature.get(\"CIRCLE_RADIUS\"));\n      feature.setGeometry(new CircleGeometry(center, radius));\n    } catch (error) {\n      console.error(\n        `Failed to create 'real' Circle geometry from supplied feature, error: ${error}`\n      );\n    }\n  };\n\n  // Creates an OpenLayers Circle geometry from a simplified circle geometry (polygon).\n  // Since the calculation from the extent does not seem to result in the exact radius,\n  // we allow for a optional radius to be passed.\n  #creteCircleGeomFromSimplified = (simplified, opt_radius) => {\n    // First we'll have to get the extent of the simplified circle\n    const simplifiedExtent = simplified.getExtent();\n    // Then we'll calculate the center and radius\n    const center = getCenter(simplifiedExtent);\n    const radius = opt_radius ?? getWidth(simplifiedExtent) / 2;\n    // Finally we'll return a circle geometry based on those:\n    return new CircleGeometry(center, radius);\n  };\n\n  // Removes the property-change-listeners from all features and then adds\n  // them again. Useful if a new feature is added to the draw-source, and you\n  // have to make sure the new feature has a listener.\n  reBindFeaturePropertyListener = () => {\n    this.#unBindFeaturePropertyListener();\n    this.#bindFeaturePropertyListener();\n  };\n\n  // Refreshes the text-style on the features in the draw-source. Useful for when a feature-prop\n  // has been changed and the text-style has to be updated.\n  refreshFeaturesTextStyle = () => {\n    this.#refreshFeaturesTextStyle();\n  };\n\n  // CUSTOM ADDER: Adds the supplied feature to the draw-source\n  // On top of just adding the feature to the draw-source, it makes sure\n  // to create some proper styling and emit events on the observer.\n  // If you want to use the adder without emitting events, you can pass\n  // silent: true in the settings.\n  addFeature = (feature, settings) => {\n    // The initiator might have supplied some settings, for example \"silent\",\n    // which states if we should avoid firing events when adding the feature.\n    // If the silent-property is not supplied, we will fire events.\n    const silent = settings?.silent ?? false;\n    try {\n      // The supplied feature might contain a property with information regarding\n      // circle-radius. If that is the case, we have to replace the Point-geometry\n      // with a Circle-geometry with the supplied radius. This case appears when circles\n      // has been saved in LS, since geoJSON does not support Circles.\n      feature.get(\"CIRCLE_RADIUS\") && this.#createRealCircleGeometry(feature);\n      // The supplied feature might contain a property with style-information\n      // that has been set in an earlier session. Let's apply that style (if present)\n      // before we add the feature to the source.\n      const extractedStyle = feature.get(\"EXTRACTED_STYLE\");\n\n      if (extractedStyle) {\n        // apply style\n        let style = this.#getFeatureStyle(feature, extractedStyle);\n        if (!style.getZIndex()) {\n          // getZIndex() returns 0 if not set\n          // force a zIndex if missing, for later use.\n          style.setZIndex(this.#lastZIndex);\n          this.#lastZIndex++;\n        }\n        feature.setStyle(style);\n      }\n\n      // When we're done styling we can add the feature.\n      this.#drawSource.addFeature(feature);\n      // Then we'll publish some information about the addition. (If we're not supposed to be silent).\n      !silent &&\n        this.#publishInformation({\n          subject: \"drawModel.featureAdded\",\n          payLoad: feature,\n        });\n    } catch (error) {\n      console.error(`Error while adding feature: ${error}`);\n      this.#publishInformation({\n        subject: \"drawModel.addFeature.error\",\n        payLoad: error,\n      });\n    }\n  };\n\n  // Method used when adding features that has been parsed using the kmlModel-parser.\n  // The method makes sure to extract and parse eventual style- and text-settings that\n  // has been stored in the kml-features.\n  addKmlFeatures = (features) => {\n    // Let's check what the current draw-interaction is. If we have a draw-interaction\n    // active, we have to make sure to disable it so that any active event-listeners doesn't\n    // fire when adding the kml-features.\n    const currentInteraction = this.#drawInteraction\n      ? this.#drawInteraction.get(\"DRAW_METHOD\")\n      : null;\n    // If the interaction isn't null, let's toggle the current interaction off.\n    currentInteraction && this.toggleDrawInteraction(\"\");\n    features.forEach((f) => {\n      // If a draw-method-property is missing from the imported features, we have to add it.\n      // Why? Well, in the sketch-tool (which is using the draw-model) we rely on the fact that\n      // the draw-method is set so that we can present proper styling menus (polygons and lines have\n      // different menus for example). The imported kml-features might not have been created with\n      // the hajk-drawModel, and therefore lacks this property. We'll set it to the geometry-type\n      // which should be sufficient.\n      !f.get(\"DRAW_METHOD\") &&\n        f.set(\n          \"DRAW_METHOD\",\n          f.get(\"geometryType\") || f.getGeometry().getType()\n        );\n      // Let's grab the style- and text-settings. (At this point they will\n      // can be undefined, a string, or the actual objects). We also have to grab the userDrawn-prop\n      // (which should be a boolean, but since we're dealing with kml, it might be a string...).\n      const extractedStyle = f.get(\"EXTRACTED_STYLE\");\n      const textSettings = f.get(\"TEXT_SETTINGS\");\n      const userDrawn = f.get(\"USER_DRAWN\");\n      // If the setting exist, and they are strings, we parse them and apply the parsed setting.\n      typeof extractedStyle === \"string\" &&\n        f.set(\"EXTRACTED_STYLE\", JSON.parse(extractedStyle));\n      typeof textSettings === \"string\" &&\n        f.set(\"TEXT_SETTINGS\", JSON.parse(textSettings));\n      typeof userDrawn === \"string\" &&\n        f.set(\"USER_DRAWN\", JSON.parse(userDrawn));\n      // Then we can add the feature to the map. We'll provide \"silent\" as well,\n      // since we don't want any events to trigger when adding kml-features. (For example\n      // when adding a text-feature, normally an event would fire, allowing the user to enter\n      // the text they want. Now we do not want that behavior).\n      this.addFeature(f, { silent: true });\n    });\n    // Let's make sure to refresh all features text-style to make sure they are up-to-date\n    this.#refreshFeaturesTextStyle();\n    // If we had a draw-interaction active before the kml-import, we have to enable it again.\n    currentInteraction && this.toggleDrawInteraction(currentInteraction);\n  };\n\n  // Toggles the hidden-property of all features connected to a kml-import\n  // with the supplied id.\n  toggleKmlFeaturesVisibility = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        const featureHidden = f.get(\"HIDDEN\") ?? false;\n        f.set(\"HIDDEN\", !featureHidden);\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Toggles the show-text-property of all features connected to a kml-import\n  // with the supplied id.\n  toggleKmlFeaturesTextVisibility = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        const featureTextShown = f.get(\"SHOW_TEXT\") ?? true;\n        f.set(\"SHOW_TEXT\", !featureTextShown);\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Removes all features with the supplied kml-id.\n  removeKmlFeaturesById = (id) => {\n    this.#drawSource.getFeatures().forEach((f) => {\n      if (f.get(\"KML_ID\") === id) {\n        this.#drawSource.removeFeature(f);\n      }\n    });\n  };\n\n  // Clones the supplied ol-feature and adds it to the map (the added clone\n  // will be offset just a tad to the east of the supplied feature).\n  duplicateFeature = (feature) => {\n    try {\n      // First we'll have to get a clone of the supplied feature\n      const duplicate = this.#createDuplicateFeature(feature);\n      // Then we'll have to check if we're dealing with a circle-geometry.\n      const isCircle = duplicate.getGeometry() instanceof CircleGeometry;\n      // We also have to make sure to store the eventual radius so that we can use\n      // that to create a 'real' circle later.\n      const radius = isCircle ? duplicate.getGeometry().getRadius() : 0;\n      // If we are dealing with a circle, we have to create a simplified geometry (since\n      // geoJSON does not like OpenLayers circles). Let's update the geometry if we are:\n      if (isCircle) {\n        duplicate.setGeometry(fromCircle(duplicate.getGeometry()));\n      }\n      // Then we'll have to create a GeoJSON-feature from the ol-feature (since turf only accepts geoJSON).\n      const gjFeature = this.#geoJSONParser.writeFeatureObject(duplicate);\n      // We want to add the cloned feature with an offset to the east. First, we'll\n      // have to get the offset-amount.\n      const offset = this.#getDuplicateOffsetAmount();\n      // Then we'll translate (move) the geoJSON-feature slightly to the east.\n      const translated = transformTranslate(gjFeature, offset, 140);\n      // Then we have to read the geometry from the translated geoJSON\n      const translatedGeom = this.#geoJSONParser.readGeometry(\n        translated.geometry\n      );\n      // When thats done, we'll update the duplicates geometry. If we are dealing\n      // with a circle, we have to create a \"real\" circle:\n      if (isCircle) {\n        duplicate.setGeometry(\n          this.#creteCircleGeomFromSimplified(translatedGeom, radius)\n        );\n      } else {\n        // Otherwise we can just set the geometry.\n        duplicate.setGeometry(translatedGeom);\n      }\n      // Since the feature we are duplicating is probably selected for edit, we have to\n      // make sure to toggle the edit-flag on the new feature to false.\n      duplicate.set(\"EDIT_ACTIVE\", false);\n      // Then we'll add the cloned feature to the map!\n      this.addFeature(duplicate);\n      // Finally, we'll refresh the draw-layer so that the feature styles are\n      // up to date.\n      this.refreshDrawLayer();\n    } catch (error) {\n      console.error(\n        `Could not duplicate the supplied feature. Error: ${error}`\n      );\n    }\n  };\n\n  // Moves the features currently selected via the Move-interaction.\n  // The features are moved the supplied length (in meters) in the supplied\n  // direction (in degrees, where north is 0 and east is 90 and so on).\n  translateSelectedFeatures = (length, angle) => {\n    this.#selectInteraction.getFeatures().forEach((f) => {\n      try {\n        // Since geoJSON cannot handle OL's circle-geometries, we'll have to check\n        // if we're dealing with a circle before creating the geoJSON-feature...\n        const isCircle = f.getGeometry() instanceof CircleGeometry;\n        // We also have to make sure to store the eventual radius so that we can use that to create a 'real' circle later.\n        const radius = isCircle ? f.getGeometry().getRadius() : 0;\n        // If we are dealing with a circle, we have to set the feature-geometry to a\n        // simplified circle (Don't worry, we'll create a \"real\" circle again later).\n        if (isCircle) {\n          f.setGeometry(fromCircle(f.getGeometry()));\n        }\n        // Then we'll create a GeoJSON-feature from the ol-feature (since turf only accepts geoJSON).\n        const gjFeature = this.#geoJSONParser.writeFeatureObject(f);\n        // Then we'll translate the feature according to the supplied parameters\n        const translated = transformTranslate(gjFeature, length / 1000, angle);\n        // When thats done, we'll read the geometry from the translated geoJSON\n        const translatedGeometry = this.#geoJSONParser.readGeometry(\n          translated.geometry\n        );\n        // When thats done, we'll update the feature geometry to the translated one. If we are dealing\n        // with a circle, we have to create a \"real\" circle:\n        if (isCircle) {\n          f.setGeometry(\n            this.#creteCircleGeomFromSimplified(translatedGeometry, radius)\n          );\n        } else {\n          // Otherwise we can just set the geometry.\n          f.setGeometry(translatedGeometry);\n        }\n      } catch (error) {\n        console.error(`Failed to translate selected features. Error: ${error}`);\n      }\n    });\n  };\n\n  // Returns a clone of the supplied feature. Makes sure to clone both\n  // the feature and its style.\n  #createDuplicateFeature = (feature) => {\n    // First we'll clone the supplied feature.\n    const duplicate = feature.clone();\n    // Then we'll have to clone the style (so that the feature-styles are not connected).\n    // We only want the first style-object from the style array (since the rest are highlight-styles).\n    // The above applied to all features except for Arrows, which aren't highlighted.\n    const style =\n      feature.get(\"DRAW_METHOD\") === \"Arrow\"\n        ? feature.getStyle().map((style) => style.clone())\n        : Array.isArray(feature.getStyle())\n        ? feature.getStyle()[0].clone()\n        : feature.getStyle().clone();\n    // Then we'll apply the cloned-style.\n    duplicate.setStyle(style);\n    // Finally we'll return the cloned feature.\n    return duplicate;\n  };\n\n  // Cloned features are going to be placed offset from the original feature when\n  // added to the map. This function returns an offset-amount that depends on the current\n  // zoom-level. This is done by calculating the area of the current map-extent, and then\n  // take a fraction of that number. (The returned number is the offset from the feature in\n  // kilometers).\n  #getDuplicateOffsetAmount = () => {\n    // First we'll get the current map-extent.\n    const mapExtent = this.#map.getView().calculateExtent(this.#map.getSize());\n    // Then we'll:\n    // 1: Get the extent-area\n    // 2: Take the square-root of the area (to get approximately the length of one map-side).\n    // 3: Take a fraction of one side of the map, and return that as the offset-amount.\n    return Math.sqrt(getExtentArea(mapExtent)) * 0.00005;\n  };\n\n  // CUSTOM REMOVER: Removes the supplied feature from the draw-source\n  // Also makes sure to emit an event on the observer.\n  removeFeature = (feature) => {\n    // Let's start by removing the supplied feature from the draw-source\n    // We won't remove if it set as hidden currently (otherwise we might confuse the users\n    // by removing stuff they're not seeing at the time of removal).\n    if (feature.get(\"HIDDEN\") !== true) {\n      this.#drawSource.removeFeature(feature);\n      // Then we (potentially) publish that we've removed a feature.\n      this.#publishInformation({\n        subject: \"drawModel.featureRemoved\",\n        payLoad: feature,\n      });\n    }\n  };\n\n  // Accepts an RGBA-object containing r-, g-, b-, and a-properties, or an array\n  // with four elements (r, g, b, and a in that order)...\n  // Returns the string representation of the supplied object (or array).\n  getRGBAString = (o) => {\n    // If nothing was supplied, return an empty string\n    if (!o) {\n      return null;\n    }\n    // Otherwise we check the type and return an rgba-string.\n    return Array.isArray(o)\n      ? `rgba(${o[0]},${o[1]},${o[2]},${o[3]})`\n      : typeof o === \"object\"\n      ? `rgba(${o.r},${o.g},${o.b},${o.a})`\n      : o;\n  };\n\n  // Accepts a color-string (hex or rgba) and returns an object containing r-, g-, b-, and a-properties.\n  parseColorString = (s) => {\n    try {\n      // First, we make sure we're dealing with a string with proper length. If not, return an empty object.\n      if (typeof s !== \"string\" || s.length < 7) {\n        return {};\n      }\n      // Then we'll check if the supplied string is an hex-string (must start with hash and be 7 chars).\n      // Cannot handle hex-shorthands such as #fff obviously.\n      if (s.length === 7 && s.startsWith(\"#\")) {\n        // If it is, we parse the hex-string and return an object containing the\n        // corresponding values.\n        const [r, g, b] = s.match(/\\w\\w/g).map((c) => parseInt(c, 16));\n        return { r, g, b, a: 1 };\n      }\n      // Otherwise, some regex-magic.\n      // 1. RegEx that matches stuff between a set of parentheses\n      // 2. Execute that regex on the input string, but first remove any whitespace it may contain\n      // 3. RegEx exec returns an array. Grab the second element, which will contain the value.\n      // 4. Split the value to extract individual rgba values\n      const o = /\\(([^)]+)\\)/.exec(s.replace(/\\s/g, \"\"))[1].split(\",\");\n      return {\n        r: parseFloat(o[0]),\n        g: parseFloat(o[1]),\n        b: parseFloat(o[2]),\n        a: parseFloat(o[3]),\n      };\n    } catch (error) {\n      console.error(`Color-string parsing failed: ${error}`);\n      return null;\n    }\n  };\n\n  // Toggles the current draw interaction. To enable the draw interaction,\n  // pass one of the allowed draw-interactions: \"Polygon\", \"Rectangle\", \"Circle\", or \"Delete\"\n  // as the first parameter. To disable the draw-interaction, pass nothing, or an empty string.\n  toggleDrawInteraction = (drawMethod = \"\", settings = {}) => {\n    // If this method is fired, the first thing we have to do is to remove the (potentially)\n    // already active interaction. (We never want two interactions active at the same time...)\n    this.#disablePotentialInteraction();\n    // Check if we are supposed to be toggling the draw interaction off. If we're toggling off,\n    // we make sure to abort so that we're not activating anything.\n    if (!drawMethod || drawMethod === \"\") {\n      return;\n    }\n    // Check if the supplied method is set to \"Delete\", \"Edit\", or \"Move\", if it is, we activate the remove, edit, or move\n    // interaction. Since these are special interactions, (not real ol-draw-interactions) we make sure not to continue executing.\n    if (drawMethod === \"Delete\") {\n      return this.#enableRemoveInteraction(settings);\n    }\n    if (drawMethod === \"Edit\") {\n      return this.#enableEditInteraction(settings);\n    }\n    if (drawMethod === \"Move\") {\n      return this.#enableMoveInteraction(settings);\n    }\n    if (drawMethod === \"Select\") {\n      return this.#enableSelectInteraction(settings);\n    }\n    if (drawMethod === \"Circle\") {\n      this.#enableCircleInteraction();\n    }\n    // If we've made it this far it's time to enable a new draw interaction!\n    // First we must make sure to gather some settings and defaults.\n    const type = this.#getDrawInteractionType(drawMethod);\n    // Are we going to be free-hand drawing?\n    const freehand = this.#isFreeHandDrawing(drawMethod, settings);\n    // Then we'll add the interaction!\n    this.#drawInteraction = new Draw({\n      source: this.#drawSource,\n      type: type,\n      freehand: freehand,\n      stopClick: true,\n      geometryFunction: drawMethod === \"Rectangle\" ? createBox() : null,\n      style: this.#getDrawStyle(),\n    });\n    // Let's set the supplied draw-method as a property on the draw-interaction\n    // so that we can keep track of if we're creating special features (arrows etc).\n    this.#drawInteraction.set(\"DRAW_METHOD\", drawMethod);\n    // Then we'll add all draw listeners\n    this.#addEventListeners(settings);\n    // Then we'll add the interaction to the map!\n    this.#map.addInteraction(this.#drawInteraction);\n    // Finally we'll add the clickLock to avoid the featureInfo etc...\n    this.#map.clickLock.add(\"coreDrawModel\");\n    //  ...and snap-helper for the snap-functionality.\n    this.#map.snapHelper.add(\"coreDrawModel\");\n  };\n\n  // Finishes the currently active draw interaction.\n  finishDraw = () => {\n    if (this.#drawInteraction) {\n      this.#drawInteraction.finishDrawing();\n    }\n  };\n\n  // Fits the map to the extent of the drawn features in the draw-source\n  zoomToCurrentExtent = () => {\n    // Let's make sure that the current extent is not null.\n    if (this.#currentExtent === null) {\n      return;\n    }\n    // If the extent is not null, we'll check that the current extent is finite\n    if (this.#currentExtent.map(Number.isFinite).includes(false) === false) {\n      // If it is, we can fit the map to that extent!\n      this.#fitMapToExtent(this.#currentExtent);\n    }\n  };\n\n  // We will need a way to remove all drawn features from the draw-source.\n  // Why aren't we using a simple \"clear()\" one might ask =>  simply because\n  // the draw-source might be connected to the search-source for example, and we\n  // don't want to remove all search features, only the user drawn ones.\n  removeDrawnFeatures = () => {\n    // Let's get all the features in the draw-source that have been drawn\n    const drawnFeatures = this.getAllDrawnFeatures();\n    // Since OL does not supply a \"removeFeatures\" method, we have to map\n    // over the array, and remove every single feature one by one... (Remember\n    // that currently hidden features should be ignored).\n    drawnFeatures\n      .filter((f) => f.get(\"HIDDEN\") !== true)\n      .forEach((feature) => {\n        this.#drawSource.removeFeature(feature);\n      });\n\n    // reset lastZIndex\n    this.#lastZIndex = 1;\n\n    // When the drawn features has been removed, we have to make sure\n    // to update the current extent.\n    this.#currentExtent = this.#drawSource.getExtent();\n    // Then we (potentially) publish that we've removed a bunch of features.\n    this.#publishInformation({\n      subject: \"drawModel.featuresRemoved\",\n      payLoad: drawnFeatures,\n    });\n    return { status: \"SUCCESS\", removedFeatures: drawnFeatures };\n  };\n\n  // Set:er allowing us to change which layer the draw-model will interact with\n  setLayer = (layerName) => {\n    // We're not allowing the layer to be changed while the draw interaction is active...\n    if (this.#drawInteraction !== null) {\n      console.warn(\n        \"The layer cannot be changed. The draw interaction is currently active. Disable the draw interaction before changing layer.\"\n      );\n      return { status: \"FAILED\", message: \"Disable draw to change layer.\" };\n    }\n    // First we must update the private field holding the current layer name\n    this.#layerName = layerName;\n    // Then we must initiate the draw-layer. This will either get the layer\n    // corresponding to the supplied name, or create a new one.\n    this.#initiateDrawLayer();\n    // When the current layer changes, the current extent will obviously\n    // change as well.\n    this.#currentExtent = this.#drawSource.getExtent();\n    return { status: \"SUCCESS\", message: `Layer changed to ${layerName}` };\n  };\n\n  // Set:er allowing us to change if a tooltip should be shown when drawing\n  setShowDrawTooltip = (drawTooltipActive) => {\n    // Let's make sure we're provided proper input before we set anything\n    if (typeof drawTooltipActive !== \"boolean\") {\n      // If we were not, let's return a fail message\n      return this.#getSetFailedObject(this.#showDrawTooltip, drawTooltipActive);\n    }\n    // If we've made it this far, we can go ahead and set the internal value.\n    this.#showDrawTooltip = drawTooltipActive;\n    // And return a success-message\n    return {\n      status: \"SUCCESS\",\n      message: `Draw tooltip is now ${drawTooltipActive ? \"shown\" : \"hidden\"}`,\n    };\n  };\n\n  // Set:er allowing us to change the style settings used in the draw-layer\n  // The fill- and strokeColor passed might be either a string, or an object containing\n  // r-, g-, b-, and a-properties. If they are objects, we have to make sure to parse them\n  // to strings before setting the new style-settings.\n  setDrawStyleSettings = (newStyleSettings) => {\n    // The fill- and strokeColor might have to be parsed to strings, let's\n    // destruct them and parse them if we have to.\n    const { fillColor, strokeColor } = newStyleSettings;\n    // Create a new object containing the potentially parsed objects.\n    const parsedStyle = {\n      // We still want to pass all the other settings...\n      ...newStyleSettings,\n      //... and the potentially parsed colors.\n      fillColor:\n        typeof fillColor !== \"string\"\n          ? this.getRGBAString(fillColor)\n          : fillColor,\n      strokeColor:\n        typeof strokeColor !== \"string\"\n          ? this.getRGBAString(strokeColor)\n          : strokeColor,\n    };\n    // Then we'll update the style.\n    this.#drawStyleSettings = parsedStyle;\n    // To make sure the new style is shown in the draw-interaction, we have\n    // to refresh the interaction if it is currently active.\n    this.#refreshDrawInteraction();\n  };\n\n  // Makes sure all features are re-drawn to make sure the latest style is applied.\n  // The arrows are handled separately since they need some special styling...\n  refreshDrawLayer = () => {\n    this.#drawSource.forEachFeature((f) => {\n      if (f.get(\"DRAW_METHOD\") === \"Arrow\") {\n        this.#refreshArrowStyle(f);\n      } else {\n        f.setStyle(this.#getFeatureStyle(f));\n      }\n    });\n  };\n\n  // Updates the supplied features' <attribute> with the supplied <value>.\n  // When the attribute has been updated, the style is refreshed.\n  setFeatureAttribute = (feature, attribute, value) => {\n    // If no feature was supplied, or if the supplied 'feature' is not\n    // a feature, we'll abort.\n    if (!(feature instanceof Feature)) {\n      return;\n    }\n    // Otherwise we'll update the attribute.\n    feature.set(attribute, value);\n  };\n\n  // Updates the Text-style-settings.\n  setTextStyleSettings = (newStyleSettings) => {\n    this.#textStyleSettings = newStyleSettings;\n  };\n\n  // Enabled the Modify-interaction\n  setModifyActive = (active) => {\n    this.#keepModifyActive = active;\n    active ? this.#enableModifyInteraction() : this.#disableModifyInteraction();\n  };\n\n  // Enabled the Translate-interaction\n  setTranslateActive = (active) => {\n    this.#keepTranslateActive = active;\n    active\n      ? this.#enableTranslateInteraction()\n      : this.#disableTranslateInteraction();\n  };\n\n  setMeasurementSettings = (settings) => {\n    // First we'll update the private field\n    this.#measurementSettings = settings;\n    // Then we have to refresh the style so that the change is shown.\n    this.#refreshFeaturesTextStyle();\n  };\n\n  setCircleRadius = (radius) => {\n    this.#circleRadius = parseInt(radius);\n    // Ensure is not NaN\n    if (Number.isNaN(this.#circleRadius)) {\n      this.#circleRadius = 0;\n    }\n  };\n\n  getMeasurementSettings = () => {\n    return this.#measurementSettings;\n  };\n\n  // Get:er returning the name of the draw-layer.\n  getCurrentLayerName = () => {\n    return this.#layerName;\n  };\n\n  // Get:er returning the currently connected Vector-source\n  getCurrentVectorSource = () => {\n    return this.#drawSource;\n  };\n\n  // Get:er returning the current extent of the draw-source.\n  getCurrentExtent = () => {\n    return this.#currentExtent;\n  };\n\n  // Get:er returning if the modify-interaction is active.\n  getModifyActive = () => {\n    return this.#modifyInteraction ? true : false;\n  };\n\n  // Get:er returning if the modify-interaction is active.\n  getTranslateActive = () => {\n    return this.#translateInteraction ? true : false;\n  };\n\n  // Get:er returning the state of the showDrawTooltip\n  getShowDrawTooltip = () => {\n    return this.#showDrawTooltip;\n  };\n\n  // Get:er returning the current draw-style settings\n  getDrawStyleSettings = () => {\n    return this.#drawStyleSettings;\n  };\n\n  // Get:er returning the current text-style settings\n  getTextStyleSettings = () => {\n    return this.#textStyleSettings;\n  };\n\n  // Get:er returning circle radius\n  getCircleRadius = () => {\n    return this.#circleRadius;\n  };\n}\nexport default DrawModel;\n"],"names":["constructor","settings","observerPrefix","subject","payLoad","this","prefixedSubject","publish","strokeColor","lineDash","strokeWidth","fillColor","showText","showArea","showPerimeter","areaUnit","lengthUnit","precision","foregroundColor","backgroundColor","size","Error","some","layer","getLayers","getArray","get","VectorLayer","connectedLayer","find","getSource","set","addLayer","document","createElement","setAttribute","Overlay","element","offset","positioning","addOverlay","parentNode","removeElement","moveFeatureZIndexToTop","feature","indexes","topIndex","Math","max","isFinite","moveFeatureZIndexUp","zIndex","moveFeatureZIndexToBottom","bottomIndex","min","moveFeatureZIndexDown","getFeatures","sort","a","b","forEach","f","push","up","filter","index","closest","style","getStyle","Array","isArray","setZIndex","setStyle","getZIndex","settingsOverride","Style","currentStyle","baseLineStyle","setImage","textStyle","setText","console","warn","featureDrawMethod","featureIsPoint","getGeometry","Point","featureIsTextType","Text","textAlign","textBaseline","font","fill","Fill","color","text","overflow","stroke","Stroke","width","offsetX","offsetY","rotation","scale","baseStyle","baseStroke","getStroke","setWidth","setLineDash","svgString","window","btoa","baseColor","getColor","styles","forEachSegment","start","end","dx","dy","atan2","geometry","image","Icon","src","strokeStyle","anchor","rotateWithView","Circle","radius","coordinates","MultiPoint","error","getType","fromCircle","getCoordinates","labelType","reduce","acc","curr","type","round","value","measurement","prefix","showLength","formatted","featureTitle","measurementLabel","length","featureMeasure","Number","toFixed","toLocaleString","showAreaPrefix","CircleGeometry","getRadius","pow","PI","LineString","getLength","getArea","linearRingCoords","getLinearRing","dash","fillStyle","storedSettings","featureStyle","getFill","getRGBAString","message","s","getLineDash","getWidth","getImage","extractFeatureStyleInfo","imageStyle","getAllDrawnFeatures","VectorSource","wrapX","source","layerType","ignoreInFeatureInfo","caption","getView","fit","getSize","padding","maxZoom","un","removeEventListener","on","addEventListener","handleDrawStart","handleDrawEnd","handlePointerMove","handleAddFeature","e","features","innerHTML","setPosition","target","toolTipText","coordinate","keyCode","ctrlKey","metaKey","finishDraw","removeLastPoint","removeInteraction","clickLock","delete","snapHelper","field","providedValue","status","userDrawnFeatures","getFeaturesAtPixel","pixel","removeFeature","add","modifyEnabled","Modify","addInteraction","Select","layers","translateEnabled","Translate","refreshDrawLayer","drawSelectedFeature","featureCopy","Feature","clone","setId","random","toString","substring","addFeature","async","clickResult","Promise","resolve","handleClick","event","map","featuresWithGeom","selected","deselected","forEachFeature","toggleDrawInteraction","method","drawMethod","includes","freehand","center","JSON","parse","parseFloat","setGeometry","simplified","opt_radius","simplifiedExtent","getExtent","getCenter","reBindFeaturePropertyListener","refreshFeaturesTextStyle","silent","extractedStyle","addKmlFeatures","currentInteraction","textSettings","userDrawn","toggleKmlFeaturesVisibility","id","featureHidden","toggleKmlFeaturesTextVisibility","featureTextShown","removeKmlFeaturesById","duplicateFeature","duplicate","isCircle","gjFeature","writeFeatureObject","translated","transformTranslate","translatedGeom","readGeometry","translateSelectedFeatures","angle","translatedGeometry","mapExtent","calculateExtent","sqrt","getExtentArea","o","r","g","parseColorString","startsWith","match","c","parseInt","exec","replace","split","Draw","stopClick","geometryFunction","createBox","finishDrawing","zoomToCurrentExtent","removeDrawnFeatures","drawnFeatures","removedFeatures","setLayer","layerName","setShowDrawTooltip","drawTooltipActive","setDrawStyleSettings","newStyleSettings","parsedStyle","setFeatureAttribute","attribute","setTextStyleSettings","setModifyActive","active","setTranslateActive","setMeasurementSettings","setCircleRadius","isNaN","getMeasurementSettings","getCurrentLayerName","getCurrentVectorSource","getCurrentExtent","getModifyActive","getTranslateActive","getShowDrawTooltip","getDrawStyleSettings","getTextStyleSettings","getCircleRadius","layerCaption","GeoJSON","featureProjection","getProjection","observer","customGetDrawImageStyle","measurementSettings","drawStyleSettings","textStyleSettings","modifyDefaultEnabled","translateDefaultEnabled","showDrawTooltip"],"sourceRoot":""}