{"version":3,"file":"static/js/9724.ca1e3dbd.chunk.js","mappings":"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","sources":["../node_modules/ol/interaction/Translate.js","../node_modules/ol/source/TileArcGISRest.js"],"sourcesContent":["/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport {TRUE} from '../functions.js';\nimport {always} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(Feature, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<Feature>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<Feature>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<Feature>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.lastFeature_ = null;\n\n    this.addChangeListener(\n      InteractionProperty.ACTIVE,\n      this.handleActiveChanged_\n    );\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATESTART,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATEEND,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n\n      this.lastCoordinate_ = newCoordinate;\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATING,\n          features,\n          newCoordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {Feature} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(\n      pixel,\n      (feature, layer) => {\n        if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n          return undefined;\n        }\n        if (this.features_ && !this.features_.getArray().includes(feature)) {\n          return undefined;\n        }\n        return feature;\n      },\n      {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_,\n      }\n    );\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\n\nexport default Translate;\n","/**\n * @module ol/source/TileArcGISRest\n */\n\nimport TileImage from './TileImage.js';\nimport {appendParams} from '../uri.js';\nimport {createEmpty} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {scale as scaleSize, toSize} from '../size.js';\nimport {hash as tileCoordHash} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be\n * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by\n * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,\n * and `IMAGESR` will be set dynamically. Set `LAYERS` to\n * override the default service layer visibility. See\n * https://developers.arcgis.com/rest/services-reference/export-map.htm\n * for further reference.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\n * tilesize and extent supported by the server.\n * If this is not defined, a default grid will be used: if there is a projection\n * extent, the grid will be based on that; if not, a grid based on a global\n * extent with origin at 0,0 will be used.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * The projection code must contain a numeric end portion separated by :\n * or the entire code must form a valid ArcGIS SpatialReference definition.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.\n * The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The\n * url should include /MapServer or /ImageServer.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity\n * transition, pass `transition: 0`.\n * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS\n * Service supports multiple urls for export requests.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from ArcGIS Rest services. Map and Image\n * Services are supported.\n *\n * For cached ArcGIS services, better performance is available using the\n * {@link module:ol/source/XYZ~XYZ} data source.\n * @api\n */\nclass TileArcGISRest extends TileImage {\n  /**\n   * @param {Options} [options] Tile ArcGIS Rest options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = options.params || {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = createEmpty();\n\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  getKeyForParams_() {\n    let i = 0;\n    const res = [];\n    for (const key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../size.js\").Size} tileSize Tile size.\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  getRequestUrl_(\n    tileCoord,\n    tileSize,\n    tileExtent,\n    pixelRatio,\n    projection,\n    params\n  ) {\n    const urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n\n    // ArcGIS Server only wants the numeric portion of the projection ID.\n    // (if there is no numeric portion the entire projection code must\n    // form a valid ArcGIS SpatialReference definition).\n    const srid = projection\n      .getCode()\n      .split(/:(?=\\d+$)/)\n      .pop();\n\n    params['SIZE'] = tileSize[0] + ',' + tileSize[1];\n    params['BBOX'] = tileExtent.join(',');\n    params['BBOXSR'] = srid;\n    params['IMAGESR'] = srid;\n    params['DPI'] = Math.round(\n      params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio\n    );\n\n    let url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\n      url = urls[index];\n    }\n\n    const modifiedUrl = url\n      .replace(/MapServer\\/?$/, 'MapServer/export')\n      .replace(/ImageServer\\/?$/, 'ImageServer/exportImage');\n    return appendParams(modifiedUrl, params);\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.hidpi_ ? pixelRatio : 1;\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\n   * @param {number} pixelRatio The pixel ratio\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\n   * @return {string|undefined} The tile URL\n   * @override\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    if (pixelRatio != 1 && !this.hidpi_) {\n      pixelRatio = 1;\n    }\n\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    let tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n\n    if (pixelRatio != 1) {\n      tileSize = scaleSize(tileSize, pixelRatio, this.tmpSize);\n    }\n\n    // Apply default params and override with user specified values.\n    const baseParams = {\n      'F': 'image',\n      'FORMAT': 'PNG32',\n      'TRANSPARENT': true,\n    };\n    Object.assign(baseParams, this.params_);\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileSize,\n      tileExtent,\n      pixelRatio,\n      projection,\n      baseParams\n    );\n  }\n}\n\nexport default TileArcGISRest;\n"],"names":["TranslateEventType","TranslateEvent","Event","constructor","type","features","coordinate","startCoordinate","mapBrowserEvent","super","this","Translate","PointerInteraction","options","layerFilter","on","once","un","lastCoordinate_","startCoordinate_","features_","undefined","layers","layer","includes","TRUE","layerFilter_","filter_","filter","hitTolerance_","hitTolerance","condition_","condition","always","lastFeature_","addChangeListener","InteractionProperty","handleActiveChanged_","handleDownEvent","event","originalEvent","featuresAtPixel_","pixel","map","handleMoveEvent","Collection","dispatchEvent","handleUpEvent","handleDragEvent","newCoordinate","deltaX","deltaY","forEach","feature","geom","getGeometry","translate","setGeometry","elem","getViewport","classList","remove","add","forEachFeatureAtPixel","Feature","getArray","getHitTolerance","setHitTolerance","setMap","oldMap","getMap","updateState_","active","getActive","TileArcGISRest","TileImage","attributions","cacheSize","crossOrigin","interpolate","projection","reprojectionErrorThreshold","tileGrid","tileLoadFunction","url","urls","wrapX","transition","zDirection","params_","params","hidpi_","hidpi","tmpExtent_","createEmpty","setKey","getKeyForParams_","i","res","key","join","getParams","getRequestUrl_","tileCoord","tileSize","tileExtent","pixelRatio","srid","getCode","split","pop","Math","round","length","modulo","tileCoordHash","modifiedUrl","replace","appendParams","getTilePixelRatio","updateParams","Object","assign","tileUrlFunction","getTileGrid","getTileGridForProjection","getResolutions","getTileCoordExtent","toSize","getTileSize","tmpSize","scaleSize","baseParams"],"sourceRoot":""}