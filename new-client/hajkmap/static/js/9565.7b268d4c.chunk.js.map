{"version":3,"file":"static/js/9565.7b268d4c.chunk.js","mappings":"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","sources":["plugins/Measure/MeasureModel.js","../node_modules/ol/Overlay.js"],"sourcesContent":["import { Circle as CircleStyle, Fill, Stroke, Style, Text } from \"ol/style.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\nimport { LineString, Polygon, Circle } from \"ol/geom.js\";\nimport Draw from \"ol/interaction/Draw.js\";\n\nimport Overlay from \"ol/Overlay\";\n\nclass MeasureModel {\n  constructor(settings) {\n    this.map = settings.map;\n    this.app = settings.app;\n    this.localObserver = settings.localObserver;\n    this.source = new VectorSource();\n    this.vector = new VectorLayer({\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginMeasure\",\n      caption: \"Measure layer\",\n      source: this.source,\n      style: this.createStyle,\n    });\n    this.map.addLayer(this.vector);\n    this.type = \"LineString\";\n    this.createMeasureTooltip();\n  }\n\n  createStyle = (feature, resolution) => {\n    const fillColor = \"rgba(255, 255, 255, 0.3)\";\n    const strokeColor = \"rgba(0, 0, 0, 0.5)\";\n    return [\n      new Style({\n        fill: new Fill({\n          color: fillColor,\n        }),\n        stroke: new Stroke({\n          color: strokeColor,\n          width: 3,\n        }),\n        image: new CircleStyle({\n          radius: 5,\n          stroke: new Stroke({\n            color: strokeColor,\n          }),\n          fill: new Fill({\n            color: fillColor,\n          }),\n        }),\n        text: new Text({\n          textAlign: \"center\",\n          textBaseline: \"middle\",\n          font: \"12pt sans-serif\",\n          fill: new Fill({ color: \"#FFF\" }),\n          text: this.getLabelText(feature),\n          overflow: true,\n          stroke: new Stroke({\n            color: strokeColor,\n            width: 3,\n          }),\n          offsetX: 0,\n          offsetY: -10,\n          rotation: 0,\n          scale: 1,\n        }),\n      }),\n    ];\n  };\n\n  clear = () => {\n    this.source.clear();\n    this.measureTooltip.setPosition(undefined);\n  };\n\n  handleDrawStart = (e) => {\n    e.feature.getGeometry().on(\"change\", (e) => {\n      var toolTip = \"\",\n        coord = undefined,\n        pointerCoord;\n\n      if (this.active) {\n        if (this.pointerPosition) {\n          pointerCoord = this.pointerPosition.coordinate;\n        }\n\n        if (e.target instanceof LineString) {\n          toolTip = this.formatLabel(\"length\", e.target.getLength());\n          coord = e.target.getLastCoordinate();\n        }\n\n        if (e.target instanceof Polygon) {\n          toolTip = this.formatLabel(\"area\", e.target.getArea());\n          coord = pointerCoord || e.target.getFirstCoordinate();\n        }\n\n        if (e.target instanceof Circle) {\n          toolTip = this.formatLabel(\"circle\", e.target.getRadius());\n          coord = pointerCoord || e.target.getFirstCoordinate();\n        }\n\n        this.measureTooltipElement.innerHTML = toolTip;\n        this.measureTooltip.setPosition(coord);\n      }\n    });\n  };\n\n  handleDrawEnd = (e) => {\n    this.setFeaturePropertiesFromGeometry(e.feature);\n    this.measureTooltip.setPosition(undefined);\n  };\n\n  setType(type) {\n    this.type = type;\n    this.removeInteraction();\n    this.addInteraction();\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  setFeaturePropertiesFromGeometry(feature) {\n    if (!feature) return;\n    var geom,\n      type = \"\",\n      length = 0,\n      radius = 0,\n      area = 0,\n      position = {\n        n: 0,\n        e: 0,\n      };\n    geom = feature.getGeometry();\n    type = geom.getType();\n    switch (type) {\n      case \"Point\":\n        position = {\n          n: Math.round(geom.getCoordinates()[1]),\n          e: Math.round(geom.getCoordinates()[0]),\n        };\n        break;\n      case \"LineString\":\n        if (geom.getLength() < 1000) {\n          length = Math.round(geom.getLength() * 10) / 10;\n        } else {\n          length = Math.round(geom.getLength());\n        }\n        break;\n      case \"Polygon\":\n        area = Math.round(geom.getArea());\n        break;\n      case \"Circle\":\n        radius = Math.round(geom.getRadius());\n        break;\n      default:\n        break;\n    }\n    feature.setProperties({\n      type: type,\n      length: length,\n      area: area,\n      radius: radius,\n      position: position,\n    });\n  }\n\n  formatLabel(type, value) {\n    let label;\n\n    if (type === \"point\") {\n      label = \"Nord: \" + value.n + \" Öst: \" + value.e;\n    }\n\n    if (typeof value === \"number\") {\n      if (type === \"length\" && value < 1000) {\n        value = Math.round(value * 10) / 10;\n      } else {\n        value = Math.round(value);\n      }\n    }\n\n    if (type === \"circle\") {\n      let unit = \" m\";\n      let squareUnit = \" m²\";\n      if (value >= 1000) {\n        unit = \" km\";\n        value = value / 1000;\n      }\n      label =\n        \"R = \" +\n        Number(value).toLocaleString() +\n        unit +\n        \" \\nA = \" +\n        (Math.round(value * value * Math.PI * 1000) / 1000).toLocaleString() +\n        squareUnit;\n    }\n\n    if (type === \"area\") {\n      if (value > 100000) {\n        label =\n          Number(Math.round((value / 1000000) * 100) / 100).toLocaleString() +\n          \" km²\";\n      } else {\n        label = Number(Math.round(value * 100) / 100).toLocaleString() + \" m²\";\n      }\n    }\n\n    if (type === \"length\") {\n      let unit = \" m\";\n      if (value >= 1000) {\n        unit = \" km\";\n        value = value / 1000;\n      }\n      label = Number(value).toLocaleString() + unit;\n    }\n\n    return label;\n  }\n\n  createMeasureTooltip() {\n    if (this.measureTooltipElement) {\n      this.measureTooltipElement.parentNode.removeChild(\n        this.measureTooltipElement\n      );\n    }\n    this.measureTooltipElement = document.createElement(\"div\");\n    this.measureTooltipElement.className = \"tooltip-draw tooltip-measure\";\n    this.measureTooltip = new Overlay({\n      element: this.measureTooltipElement,\n      offset: [0, -15],\n      positioning: \"bottom-center\",\n    });\n    this.map.addOverlay(this.measureTooltip);\n  }\n\n  getLabelText(feature) {\n    const props = feature.getProperties();\n    const type = feature.getProperties().type;\n    switch (type) {\n      case \"Point\":\n        return this.formatLabel(\"point\", props.position);\n      case \"LineString\":\n        return this.formatLabel(\"length\", props.length);\n      case \"Circle\":\n        return this.formatLabel(\"circle\", props.radius);\n      case \"Polygon\":\n        return this.formatLabel(\"area\", props.area);\n      default:\n        return \"\";\n    }\n  }\n\n  addInteraction() {\n    this.draw = new Draw({\n      source: this.source,\n      type: this.type,\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 255, 255, 0.2)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.5)\",\n          lineDash: [10, 10],\n          width: 2,\n        }),\n        image: new CircleStyle({\n          radius: 5,\n          stroke: new Stroke({\n            color: \"rgba(0, 0, 0, 0.7)\",\n          }),\n          fill: new Fill({\n            color: \"rgba(255, 255, 255, 0.2)\",\n          }),\n        }),\n      }),\n    });\n    this.draw.on(\"drawstart\", this.handleDrawStart);\n    this.draw.on(\"drawend\", this.handleDrawEnd);\n    this.map.addInteraction(this.draw);\n\n    // Add snap interactions AFTER measure source has been added\n    // this will allow us to snap to the newly added source too\n    this.map.snapHelper.add(\"measure\");\n  }\n\n  removeInteraction() {\n    this.measureTooltip.setPosition(undefined);\n    this.map.snapHelper.delete(\"measure\");\n    this.map.removeInteraction(this.draw);\n  }\n\n  eventHandler = (event) => {\n    const key = event.key; // Or const {key} = event; in ES6+\n    if (key === \"Escape\") {\n      this.draw.finishDrawing();\n    }\n  };\n\n  setActive(active) {\n    if (active && !this.active) {\n      document.addEventListener(\"keydown\", this.eventHandler);\n      this.addInteraction();\n      this.map.clickLock.add(\"measure\");\n    }\n    if (active === false) {\n      document.removeEventListener(\"keydown\", this.eventHandler);\n      this.removeInteraction();\n      this.map.clickLock.delete(\"measure\");\n    }\n    this.active = active;\n  }\n\n  getMap() {\n    return this.map;\n  }\n}\n\nexport default MeasureModel;\n","/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport {CLASS_SELECTABLE} from './css.js';\nimport {containsExtent} from './extent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {outerHeight, outerWidth, removeChildren, removeNode} from './dom.js';\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nconst Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning',\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay.js';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nclass Overlay extends BaseObject {\n  /**\n   * @param {Options} options Overlay options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst =\n      options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = document.createElement('div');\n    this.element.className =\n      options.className !== undefined\n        ? options.className\n        : 'ol-overlay-container ' + CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      transform_: '',\n      visible: true,\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n\n    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);\n    this.addChangeListener(Property.MAP, this.handleMapChanged);\n    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);\n    this.addChangeListener(Property.POSITION, this.handlePositionChanged);\n    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n\n    this.setPositioning(options.positioning || 'top-left');\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  getElement() {\n    return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n  }\n\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id;\n  }\n\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./Map.js\").default|null} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n  getMap() {\n    return /** @type {import(\"./Map.js\").default|null} */ (\n      this.get(Property.MAP) || null\n    );\n  }\n\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n  getOffset() {\n    return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n  }\n\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the current positioning of this overlay.\n   * @return {Positioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  getPositioning() {\n    return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n  }\n\n  /**\n   * @protected\n   */\n  handleElementChanged() {\n    removeChildren(this.element);\n    const element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      removeNode(this.element);\n      unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    const map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = listen(\n        map,\n        MapEventType.POSTRENDER,\n        this.render,\n        this\n      );\n      this.updatePixelPosition();\n      const container = this.stopEvent\n        ? map.getOverlayContainerStopEvent()\n        : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handleOffsetChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositionChanged() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositioningChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  setElement(element) {\n    this.set(Property.ELEMENT, element);\n  }\n\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./Map.js\").default|null} map The map that the\n   * overlay is part of. Pass `null` to just remove the overlay from the current map.\n   * @observable\n   * @api\n   */\n  setMap(map) {\n    this.set(Property.MAP, map);\n  }\n\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  }\n\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  setPosition(position) {\n    this.set(Property.POSITION, position);\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary) using the configured autoPan parameters\n   * @protected\n   */\n  performAutoPan() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n   * @api\n   */\n  panIntoView(panIntoViewOptions) {\n    const map = this.getMap();\n\n    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n      return;\n    }\n\n    const mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    const element = this.getElement();\n    const overlayRect = this.getRect(element, [\n      outerWidth(element),\n      outerHeight(element),\n    ]);\n\n    panIntoViewOptions = panIntoViewOptions || {};\n\n    const myMargin =\n      panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n    if (!containsExtent(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      const offsetLeft = overlayRect[0] - mapRect[0];\n      const offsetRight = mapRect[2] - overlayRect[2];\n      const offsetTop = overlayRect[1] - mapRect[1];\n      const offsetBottom = mapRect[3] - overlayRect[3];\n\n      const delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        const center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n          map.getView().getCenterInternal()\n        );\n        const centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n\n        const panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement} element The element.\n   * @param {import(\"./size.js\").Size} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n  getRect(element, size) {\n    const box = element.getBoundingClientRect();\n    const offsetX = box.left + window.pageXOffset;\n    const offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  }\n\n  /**\n   * Set the positioning for this overlay.\n   * @param {Positioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  }\n\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  }\n\n  /**\n   * Update pixel position.\n   * @protected\n   */\n  updatePixelPosition() {\n    const map = this.getMap();\n    const position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    const pixel = map.getPixelFromCoordinate(position);\n    const mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  }\n\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n  updateRenderedPosition(pixel, mapSize) {\n    const style = this.element.style;\n    const offset = this.getOffset();\n\n    const positioning = this.getPositioning();\n\n    this.setVisible(true);\n\n    const x = Math.round(pixel[0] + offset[0]) + 'px';\n    const y = Math.round(pixel[1] + offset[1]) + 'px';\n    let posX = '0%';\n    let posY = '0%';\n    if (\n      positioning == 'bottom-right' ||\n      positioning == 'center-right' ||\n      positioning == 'top-right'\n    ) {\n      posX = '-100%';\n    } else if (\n      positioning == 'bottom-center' ||\n      positioning == 'center-center' ||\n      positioning == 'top-center'\n    ) {\n      posX = '-50%';\n    }\n    if (\n      positioning == 'bottom-left' ||\n      positioning == 'bottom-center' ||\n      positioning == 'bottom-right'\n    ) {\n      posY = '-100%';\n    } else if (\n      positioning == 'center-left' ||\n      positioning == 'center-center' ||\n      positioning == 'center-right'\n    ) {\n      posY = '-50%';\n    }\n    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;\n    if (this.rendered.transform_ != transform) {\n      this.rendered.transform_ = transform;\n      style.transform = transform;\n    }\n  }\n\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n  getOptions() {\n    return this.options;\n  }\n}\n\nexport default Overlay;\n"],"names":["constructor","settings","createStyle","feature","resolution","fillColor","strokeColor","Style","fill","Fill","color","stroke","Stroke","width","image","CircleStyle","radius","text","Text","textAlign","textBaseline","font","this","getLabelText","overflow","offsetX","offsetY","rotation","scale","clear","source","measureTooltip","setPosition","undefined","handleDrawStart","e","getGeometry","on","pointerCoord","toolTip","coord","active","pointerPosition","coordinate","target","LineString","formatLabel","getLength","getLastCoordinate","Polygon","getArea","getFirstCoordinate","Circle","getRadius","measureTooltipElement","innerHTML","handleDrawEnd","setFeaturePropertiesFromGeometry","eventHandler","event","key","draw","finishDrawing","map","app","localObserver","VectorSource","vector","VectorLayer","layerType","zIndex","name","caption","style","addLayer","type","createMeasureTooltip","setType","removeInteraction","addInteraction","getType","geom","length","area","position","n","Math","round","getCoordinates","setProperties","value","label","unit","squareUnit","Number","toLocaleString","PI","parentNode","removeChild","document","createElement","className","Overlay","element","offset","positioning","addOverlay","props","getProperties","Draw","lineDash","snapHelper","add","delete","setActive","addEventListener","clickLock","removeEventListener","getMap","Property","BaseObject","options","super","once","un","id","insertFirst","stopEvent","CLASS_SELECTABLE","pointerEvents","autoPan","rendered","transform_","visible","mapPostrenderListenerKey","addChangeListener","handleElementChanged","handleMapChanged","handleOffsetChanged","handlePositionChanged","handlePositioningChanged","setElement","setOffset","setPositioning","getElement","get","getId","getOffset","getPosition","getPositioning","removeChildren","appendChild","removeNode","unlistenByKey","listen","MapEventType","render","updatePixelPosition","container","getOverlayContainerStopEvent","getOverlayContainer","insertBefore","childNodes","performAutoPan","set","setMap","panIntoView","panIntoViewOptions","getTargetElement","mapRect","getRect","getSize","overlayRect","outerWidth","outerHeight","myMargin","margin","containsExtent","offsetLeft","offsetRight","offsetTop","offsetBottom","delta","abs","center","getView","getCenterInternal","centerPx","getPixelFromCoordinateInternal","newCenterPx","panOptions","animation","animateInternal","getCoordinateFromPixelInternal","duration","easing","size","box","getBoundingClientRect","left","window","pageXOffset","top","pageYOffset","setVisible","display","isRendered","pixel","getPixelFromCoordinate","mapSize","updateRenderedPosition","x","y","posX","posY","transform","getOptions"],"sourceRoot":""}