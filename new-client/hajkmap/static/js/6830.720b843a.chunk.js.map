{"version":3,"file":"static/js/6830.720b843a.chunk.js","mappings":"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","sources":["plugins/Print/PrintModel.js"],"sourcesContent":["import { delay } from \"../../utils/Delay\";\nimport { getPointResolution } from \"ol/proj\";\nimport { getCenter } from \"ol/extent\";\nimport jsPDF from \"jspdf\";\nimport { saveAs } from \"file-saver\";\n\nimport Vector from \"ol/layer/Vector.js\";\nimport View from \"ol/View\";\nimport VectorSource from \"ol/source/Vector.js\";\nimport Polygon from \"ol/geom/Polygon\";\nimport Feature from \"ol/Feature.js\";\nimport { Translate } from \"ol/interaction.js\";\nimport Collection from \"ol/Collection\";\nimport { Style, Stroke, Fill } from \"ol/style.js\";\n\nimport ImageLayer from \"ol/layer/Image\";\nimport TileLayer from \"ol/layer/Tile\";\nimport TileWMS from \"ol/source/TileWMS\";\nimport ImageWMS from \"ol/source/ImageWMS\";\n\nimport { ROBOTO_NORMAL } from \"./constants\";\nexport default class PrintModel {\n  constructor(settings) {\n    this.map = settings.map;\n    this.dims = settings.dims;\n    this.logoUrl = settings.options.logo || \"\";\n    this.northArrowUrl = settings.options.northArrow || \"\";\n    this.logoMaxWidth = settings.options.logoMaxWidth;\n    this.includeImageBorder = settings.options.includeImageBorder;\n    this.northArrowMaxWidth = settings.options.northArrowMaxWidth;\n    this.scales = settings.options.scales;\n    this.scaleMeters = settings.options.scaleMeters;\n    this.scaleBarLengths = this.calculateScaleBarLengths();\n    this.copyright = settings.options.copyright || \"\";\n    this.date = settings.options.date || \"\";\n    this.disclaimer = settings.options.disclaimer || \"\";\n    this.localObserver = settings.localObserver;\n    this.mapConfig = settings.mapConfig;\n    // If we want the printed tiles to have correct styling, we have to use\n    // custom loaders to make sure that the requests has all the required parameters.\n    // If for some reason these tile-loaders shouldn't be used, a setting is exposed.\n    this.useCustomTileLoaders = settings.options.useCustomTileLoaders ?? true;\n    // Since the WMS-servers cannot handle enormous requests, we have to\n    // limit Image-WMS requests. The size below is the maximum tile-size allowed.\n    // This max-size is only used if the custom-tile-loaders are used.\n    this.maxTileSize = settings.options.maxTileSize || 4096;\n    this.textColor = settings.options.mapTextColor;\n    // Let's keep track of the original view, since we're gonna change the view\n    // under the print-process. (And we want to be able to change back to the original one).\n    this.originalView = this.map.getView();\n    this.originalMapSize = null; // Needed to restore view. It is set when print().\n\n    // Since we will be hiding all tile-layers during the print-process, and add image-layers\n    // instead, we have to keep track of what we hide and show.\n    this.hiddenLayers = new Set(); // Contains all tile-layers that have been exchanged with image-layers.\n    this.addedLayers = new Set(); // Contains the tile-layer-replacements.\n\n    // We must initiate a \"print-view\" that includes potential \"hidden\" resolutions.\n    // These \"hidden\" resolutions allows the print-process to zoom more than what the\n    // users are allowed (which is required if we want to print in high resolutions).\n    this.printView = new View({\n      center: this.originalView.getCenter(),\n      constrainOnlyCenter: this.mapConfig.constrainOnlyCenter,\n      constrainResolution: false,\n      maxZoom: 24,\n      minZoom: 0,\n      projection: this.originalView.getProjection(),\n      resolutions: this.mapConfig.allResolutions, // allResolutions includes the \"hidden\" resolutions\n      zoom: this.originalView.getZoom(),\n    });\n  }\n\n  defaultScaleBarLengths = {\n    200: 10,\n    500: 50,\n    1000: 100,\n    2000: 200,\n    5000: 500,\n    10000: 1000,\n    20000: 2000,\n    50000: 5000,\n    100000: 10000,\n    200000: 20000,\n    300000: 20000,\n  };\n\n  previewLayer = null;\n  previewFeature = null;\n\n  // Used to calculate the margin around the map-image. Change this value to get\n  // more or less margin.\n  marginAmount = 0.03;\n\n  // Used to store the calculated margin.\n  margin = 0;\n  textIconsMargin = 0;\n\n  // A flag that's used in \"rendercomplete\" to ensure that user has not cancelled the request\n  pdfCreationCancelled = null;\n\n  calculateScaleBarLengths() {\n    if (this.scales.length === this.scaleMeters.length) {\n      return this.scales.reduce((acc, curr, index) => {\n        acc[curr] = this.scaleMeters[index];\n        return acc;\n      }, {});\n    } else {\n      return this.defaultScaleBarLengths;\n    }\n  }\n\n  addPreviewLayer() {\n    this.previewLayer = new Vector({\n      source: new VectorSource(),\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginPrint\",\n      caption: \"Print layer\",\n      style: new Style({\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.7)\",\n          width: 2,\n        }),\n        fill: new Fill({\n          color: \"rgba(255, 145, 20, 0.4)\",\n        }),\n      }),\n    });\n    this.map.addLayer(this.previewLayer);\n  }\n\n  getMapScale = () => {\n    // We have to make sure to get (and set on the printView) the current zoom\n    //  of the \"original\" view. Otherwise, the scale calculation could be wrong\n    // since it depends on the static zoom of the printView.\n    this.printView.setZoom(this.originalView.getZoom());\n    // When this is updated, we're ready to calculate the scale, which depends on the\n    // dpi, mpu, inchPerMeter, and resolution. (TODO: (@hallbergs) Clarify these calculations).\n    const dpi = 25.4 / 0.28,\n      mpu = this.printView.getProjection().getMetersPerUnit(),\n      inchesPerMeter = 39.37,\n      res = this.printView.getResolution();\n\n    return res * mpu * inchesPerMeter * dpi;\n  };\n\n  getFittingScale = () => {\n    //Get map scale\n    const proposedScale = this.getMapScale();\n\n    //Get the scale closest to the proposed scale.\n    return this.scales.reduce((prev, curr) => {\n      return Math.abs(curr - proposedScale) < Math.abs(prev - proposedScale)\n        ? curr\n        : prev;\n    });\n  };\n\n  removePreview = () => {\n    this.previewFeature = undefined;\n    this.previewLayer.getSource().clear();\n    this.map.removeInteraction(this.translate);\n  };\n\n  getPreviewCenter = () => {\n    const extent = this.previewFeature.getGeometry().getExtent();\n    return getCenter(extent);\n  };\n\n  // Calculates the margin around the map-image depending on\n  // the paper dimensions\n  getMargin = (paperDim) => {\n    const longestSide = Math.max(...paperDim);\n    return this.marginAmount * longestSide;\n  };\n\n  // Returns an array with the paper dimensions with the selected\n  // format and orientation.\n  getPaperDim = (format, orientation) => {\n    return orientation === \"portrait\"\n      ? [...this.dims[format]].reverse()\n      : this.dims[format];\n  };\n\n  addPreview(options) {\n    const scale = options.scale;\n    const format = options.format;\n    const orientation = options.orientation;\n    const useMargin = options.useMargin;\n\n    // If the user wants text and icons in the margins and outside the map image\n    // we should only allow that if margins are used\n    const useTextIconsInMargin = useMargin\n      ? options.useTextIconsInMargin\n      : false;\n\n    const dim = this.getPaperDim(format, orientation);\n\n    this.margin = useMargin ? this.getMargin(dim) : 0;\n\n    //We need a different margin value for text and icons to be placed in the margins,\n    //because \"this.margin\" (above) is sometimes used independently\n    this.textIconsMargin = useTextIconsInMargin ? 0 : 6;\n\n    const inchInMillimeter = 25.4;\n    // We should take pixelRatio into account? What happens when we have\n    // pr=2? PixelSize will be 0.14?\n    const defaultPixelSizeInMillimeter = 0.28;\n\n    const dpi = inchInMillimeter / defaultPixelSizeInMillimeter; // ~90\n\n    // Here we calculate height and width of preview window based on user and admin selection\n    // (ex. if admin wants image border or if user wants margins).\n    const calculatedWidth =\n      this.includeImageBorder && !options.useMargin ? 1 : this.margin * 2;\n\n    const calculatedHeight =\n      this.includeImageBorder && !options.useMargin\n        ? 1\n        : options.useTextIconsInMargin && format === \"a5\"\n        ? this.margin * 8\n        : options.useTextIconsInMargin\n        ? this.margin * 6\n        : this.margin * 2;\n\n    //We set the size of preview window based on the calculated heights and widths.\n    const size = {\n      width: (dim[0] - calculatedWidth) / 25.4,\n      height: (dim[1] - calculatedHeight) / 25.4,\n    };\n\n    const paper = {\n      width: size.width * dpi,\n      height: size.height * dpi,\n    };\n\n    const center = this.previewFeature\n      ? getCenter(this.previewFeature.getGeometry().getExtent())\n      : this.map.getView().getCenter();\n\n    const ipu = 39.37,\n      sf = 1,\n      w = (((paper.width / dpi / ipu) * scale) / 2) * sf,\n      y = (((paper.height / dpi / ipu) * scale) / 2) * sf,\n      coords = [\n        [\n          [center[0] - w, center[1] - y],\n          [center[0] - w, center[1] + y],\n          [center[0] + w, center[1] + y],\n          [center[0] + w, center[1] - y],\n          [center[0] - w, center[1] - y],\n        ],\n      ],\n      feature = new Feature({\n        geometry: new Polygon(coords),\n      });\n\n    // Each time print settings change, we actually render a new preview feature,\n    // so first let's remove the old one.\n    this.removePreview();\n\n    // Now re-add feature, source and interaction to map.\n    this.previewFeature = feature;\n    this.previewLayer.getSource().addFeature(feature);\n    this.translate = new Translate({\n      features: new Collection([feature]),\n    });\n    this.map.addInteraction(this.translate);\n  }\n\n  renderPreviewFeature = (previewLayerVisible, options) => {\n    if (previewLayerVisible) {\n      this.addPreview(options);\n    } else {\n      this.removePreview();\n    }\n  };\n\n  /**\n   * @summary Returns a Promise which resolves if image loading succeeded.\n   * @description The Promise will contain an object with data blob of the loaded image. If loading fails, the Promise rejects\n   *\n   * @param {*} url\n   * @returns {Promise}\n   */\n  getImageDataBlobFromUrl = (url) => {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      image.setAttribute(\"crossOrigin\", \"anonymous\"); //getting images from external domain\n\n      // We must resolve the promise even if\n      image.onerror = function (err) {\n        reject(err);\n      };\n\n      // When load succeeds\n      image.onload = function () {\n        const imgCanvas = document.createElement(\"canvas\");\n        imgCanvas.width = this.naturalWidth;\n        imgCanvas.height = this.naturalHeight;\n\n        // Draw the image on canvas so that we can read the data blob later on\n        imgCanvas.getContext(\"2d\").drawImage(this, 0, 0);\n\n        resolve({\n          data: imgCanvas.toDataURL(\"image/png\"), // read data blob from canvas\n          width: imgCanvas.width, // also return dimensions so we can use them later\n          height: imgCanvas.height,\n        });\n      };\n\n      // Go, load!\n      image.src = url;\n    });\n  };\n  /**\n   * @summary Helper function that takes a URL and max width and returns the ready data blob as well as width/height which fit into the specified max value.\n   *\n   * @param {*} url\n   * @param {*} maxWidth\n   * @returns {Object} image data blob, image width, image height\n   */\n  getImageForPdfFromUrl = async (url, maxWidth) => {\n    // Use the supplied logo URL to get img data blob and dimensions\n    const {\n      data,\n      width: sourceWidth,\n      height: sourceHeight,\n    } = await this.getImageDataBlobFromUrl(url);\n\n    // We must ensure that the logo will be printed with a max width of X, while keeping the aspect ratio between width and height\n    const ratio = maxWidth / sourceWidth;\n    const width = sourceWidth * ratio;\n    const height = sourceHeight * ratio;\n    return { data, width, height };\n  };\n\n  /**\n   * @summary Returns an object stating the x and y position\n   * @description Helper function that takes some content and calculates where it should be placed on the canvas\n   *\n   * @param {*} placement chosen placement on the canvas\n   * @param {*} contentWidth\n   * @param {*} contentHeight\n   * @param {*} pdfWidth\n   * @param {*} pdfHeight\n   * @returns {Object} x-axis and y-axis placement in mm\n   */\n  getPlacement = (\n    placement,\n    contentWidth,\n    contentHeight,\n    pdfWidth,\n    pdfHeight\n  ) => {\n    // We must take the potential margin around the map-image into account (this.margin)\n\n    const margin = this.textIconsMargin + this.margin;\n\n    let pdfPlacement = { x: 0, y: 0 };\n    if (placement === \"topLeft\") {\n      pdfPlacement.x = margin;\n      pdfPlacement.y = margin;\n    } else if (placement === \"topRight\") {\n      pdfPlacement.x = pdfWidth - contentWidth - margin;\n      pdfPlacement.y = margin;\n    } else if (placement === \"bottomRight\") {\n      pdfPlacement.x = pdfWidth - contentWidth - margin;\n      pdfPlacement.y = pdfHeight - contentHeight - margin;\n    } else {\n      pdfPlacement.x = margin;\n      pdfPlacement.y = pdfHeight - contentHeight - margin;\n    }\n    return pdfPlacement;\n  };\n\n  /**\n   * @summary Returns fitting scale bar length depending on the scale\n   * @description Helper function that returns a fitting number of meters for the supplied scale.\n   *\n   * @param {*} scale\n   * @returns {Float} Fitting number of meters for current scale.\n   */\n  getFittingScaleBarLength = (scale) => {\n    const length = this.scaleBarLengths[scale];\n\n    if (length) {\n      return length;\n    } else {\n      if (scale < 250) {\n        return 5;\n      } else if (scale < 2500) {\n        return scale * 0.02;\n      } else {\n        return scale * 0.05;\n      }\n    }\n  };\n\n  //Formats the text for the scale bar\n  getLengthText = (scaleBarLengthMeters) => {\n    let units = \"m\";\n    if (scaleBarLengthMeters > 1000) {\n      scaleBarLengthMeters /= 1000;\n      units = \"km\";\n    }\n    return `${Number(scaleBarLengthMeters).toLocaleString()} ${units}`;\n  };\n\n  // Divides scaleBarLength with correct number to get divisions lines every 1, 10 or 100 m or km.\n  // Example 1: If scaleBarLengthMeters is 1000 we divide by 10 to get 10 division lines every 100 meters.\n  // Example 2: If _scaleBarLengthMeters is 500 we divide by 5 to get 5 division lines every 10 meters.\n  getDivLinesArrayAndDivider = (scaleBarLengthMeters, scaleBarLength) => {\n    const scaleBarLengthMetersStr = scaleBarLengthMeters.toString();\n    // Here we get the lengthMeters first two numbers.\n    const scaleBarFirstDigits = parseInt(\n      scaleBarLengthMetersStr.substring(0, 2)\n    );\n    // We want to check if lengthMeters starts with 10 through 19 to make sure we divide correctly later.\n    const startsWithDoubleDigits =\n      scaleBarFirstDigits >= 10 && scaleBarFirstDigits <= 19;\n\n    // Here we set the scaleLength variable to the length of lengthMeters.\n    // For example, if lengthMeters is 1000 we want the scaleLength to be 10.\n    // And if lengthMeters is 500 we want the scaleLength to be 5.\n    const scaleLength = startsWithDoubleDigits\n      ? scaleBarLengthMetersStr.length - 2\n      : scaleBarLengthMetersStr.length - 1;\n\n    // Here we set the divider by dividing lengthMeters with 10 to the power of scaleLength...\n    // For example, if lengthMeters is 500 we want to divide it by 5 to get 5 division lines, each 100 meters...\n    // and if lengthMeters is 1 000 we want to divide it by 100.\n    const divider = scaleBarLengthMeters / Math.pow(10, scaleLength);\n    // Finally, we want to calculate the number of pixels between each division line on the scalebar\n    const divLinePixelsCount = scaleBarLength / divider;\n\n    // We loop through and fill the divLinesArray with the divLinePixelsCount...\n    // to get the correct division line distribution on the scalebar\n    let divLinesArray = [];\n    for (\n      let divLine = divLinePixelsCount;\n      divLine <= scaleBarLength;\n      divLine += divLinePixelsCount\n    ) {\n      divLinesArray.push(divLine);\n    }\n\n    return { divLinesArray, divider };\n  };\n\n  addDividerLinesAndTexts = (props) => {\n    this.drawDividerLines(props);\n\n    // We want to make sure that given scale is a set scale in our admin settings...\n    // to ensure the text has correct spacing\n    if (this.scaleBarLengths[props.scale]) this.addDividerTexts(props);\n  };\n\n  drawDividerLines({\n    pdf,\n    scaleBarPosition,\n    scaleBarLength,\n    color,\n    scaleBarLengthMeters,\n  }) {\n    // Set line width and color\n    pdf.setLineWidth(0.25).setDrawColor(color);\n\n    // Draw starting, finish, and through lines\n    pdf.line(\n      scaleBarPosition.x,\n      scaleBarPosition.y + 3,\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 3\n    );\n    pdf.line(\n      scaleBarPosition.x,\n      scaleBarPosition.y + 1,\n      scaleBarPosition.x,\n      scaleBarPosition.y + 5\n    );\n    pdf.line(\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 1,\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 5\n    );\n\n    // Here we get number of lines we will draw below\n    const { divLinesArray } = this.getDivLinesArrayAndDivider(\n      scaleBarLengthMeters,\n      scaleBarLength\n    );\n\n    // Here we draw the dividing lines marking 10 (or 100) meters each\n    divLinesArray.forEach((divLine) => {\n      const largerMiddleLineValue =\n        divLinesArray.length === 10 && divLine === divLinesArray[4] ? 0.7 : 0;\n      pdf.line(\n        scaleBarPosition.x + divLine,\n        scaleBarPosition.y + 1.9 - largerMiddleLineValue,\n        scaleBarPosition.x + divLine,\n        scaleBarPosition.y + 4.1 + largerMiddleLineValue\n      );\n    });\n\n    // If the space between 0 and the first number on the scalebar is long enough...\n    // we draw additional lines between 0 and the first number\n    if (divLinesArray[0] > 10) {\n      const numLine = divLinesArray[0] / 5;\n      for (\n        let divLine = numLine;\n        divLine < divLinesArray[0];\n        divLine += numLine\n      ) {\n        pdf.line(\n          scaleBarPosition.x + divLine,\n          scaleBarPosition.y + 2.25,\n          scaleBarPosition.x + divLine,\n          scaleBarPosition.y + 3.85\n        );\n      }\n    }\n  }\n\n  addDividerTexts = ({\n    pdf,\n    scaleBarPosition,\n    scaleBarLength,\n    scaleBarLengthMeters,\n    color,\n  }) => {\n    pdf.setFontSize(8);\n    pdf.setTextColor(color);\n\n    // Here we set the number 0 at the start of the scalebar\n    pdf.text(\"0\", scaleBarPosition.x - 0.7, scaleBarPosition.y + 8);\n\n    // Here we convert the scaleBarLengthMeters to km if above 1000\n    const calculatedScaleBarLengthMeters =\n      scaleBarLengthMeters > 1000\n        ? (scaleBarLengthMeters / 1000).toString()\n        : scaleBarLengthMeters;\n\n    // Here we get number of lines we will draw below\n    const { divLinesArray, divider } = this.getDivLinesArrayAndDivider(\n      scaleBarLengthMeters,\n      scaleBarLength\n    );\n\n    const scaleBarHasSpace = divLinesArray[0] > 10 && scaleBarLengthMeters > 10;\n\n    // Here we add the first number after 0\n    let divNr = calculatedScaleBarLengthMeters / divider;\n    let divNrString = divNr.toLocaleString();\n    pdf.text(\n      divNrString,\n      scaleBarPosition.x + divLinesArray[0] - divNrString.length,\n      scaleBarPosition.y + 8\n    );\n\n    // Here we add the middle number or if no middle exists...\n    // a number that's close to the middle\n\n    // let midIndex =\n    //   divLinesArray.length % 2 === 0\n    //     ? divLinesArray.length / 2\n    //     : Math.floor(divLinesArray.length / 2);\n\n    const midIndex = Math.round(divLinesArray.length / 2);\n\n    divNr = (calculatedScaleBarLengthMeters / divider) * midIndex;\n    divNrString = divNr.toLocaleString();\n    pdf.text(\n      divNrString,\n      scaleBarPosition.x + divLinesArray[midIndex - 1] - divNrString.length,\n      scaleBarPosition.y + 8\n    );\n\n    // Here we add a number to the first additional division line but only if scaleBar has space\n    if (scaleBarHasSpace) {\n      const dividerNrPosition = divLinesArray[0] / 5;\n      divNr = calculatedScaleBarLengthMeters / divider / 5;\n      divNrString = divNr.toLocaleString();\n\n      // We need to make sure correct placement if divNr is a decimal number\n      const dividerStrLength =\n        divNr % 1 !== 0 ? divNrString.length - 1 : divNrString.length;\n\n      pdf.text(\n        divNrString,\n        scaleBarPosition.x + dividerNrPosition - dividerStrLength,\n        scaleBarPosition.y + 8\n      );\n    }\n  };\n\n  drawScaleBar = (\n    pdf,\n    scaleBarPosition,\n    color,\n    scaleBarLength,\n    scale,\n    scaleBarLengthMeters,\n    format,\n    orientation\n  ) => {\n    const lengthText = this.getLengthText(scaleBarLengthMeters);\n    pdf.setFontSize(8);\n    pdf.setTextColor(color);\n    pdf.setLineWidth(0.25);\n    pdf.text(\n      lengthText,\n      scaleBarPosition.x + scaleBarLength + 1,\n      scaleBarPosition.y + 4\n    );\n\n    pdf.setFontSize(10);\n    pdf.text(\n      `Skala: ${this.getUserFriendlyScale(\n        scale\n      )} (vid ${format.toUpperCase()} ${\n        orientation === \"landscape\" ? \"liggande\" : \"stående\"\n      })`,\n      scaleBarPosition.x,\n      scaleBarPosition.y - 1\n    );\n\n    this.addDividerLinesAndTexts({\n      pdf,\n      scale,\n      scaleBarLengthMeters,\n      scaleBarPosition,\n      scaleBarLength,\n      color,\n    });\n  };\n\n  addScaleBar = (\n    pdf,\n    color,\n    scale,\n    resolution,\n    scaleBarPlacement,\n    scaleResolution,\n    format,\n    orientation\n  ) => {\n    const millimetersPerInch = 25.4;\n    const pixelSize = millimetersPerInch / resolution / scaleResolution;\n    const scaleBarLengthMeters = this.getFittingScaleBarLength(scale);\n\n    const scaleBarLength = scaleBarLengthMeters * pixelSize;\n    const scaleBarHeight = 6;\n\n    const scaleBarPosition = this.getPlacement(\n      scaleBarPlacement,\n      scaleBarLength + 9,\n      scaleBarHeight,\n      pdf.internal.pageSize.width,\n      pdf.internal.pageSize.height\n    );\n\n    this.drawScaleBar(\n      pdf,\n      scaleBarPosition,\n      color,\n      scaleBarLength,\n      scale,\n      scaleBarLengthMeters,\n      format,\n      orientation\n    );\n  };\n\n  // Make sure the desired resolution (depending on scale and dpi)\n  // works with the current map-setup.\n  desiredPrintOptionsOk = (options) => {\n    const resolution = options.resolution;\n    const scale = options.scale / 1000;\n    const desiredResolution = this.getScaleResolution(\n      scale,\n      resolution,\n      this.map.getView().getCenter()\n    );\n\n    // The desired options are OK if they result in a resolution bigger than the minimum\n    // resolution of the print-view.\n    return desiredResolution >= this.printView.getMinResolution();\n  };\n\n  getScaleResolution = (scale, resolution, center) => {\n    return (\n      scale /\n      getPointResolution(\n        this.map.getView().getProjection(),\n        resolution / 25.4,\n        center\n      )\n    );\n  };\n\n  // If the user has selected one of the \"special\" backgroundLayers (white or black)\n  // the backgroundColor of the mapCanvas has changed. We must keep track of this\n  // to make sure that the print-results has the same appearance.\n  getMapBackgroundColor = () => {\n    const currentBackgroundColor =\n      document.getElementById(\"map\").style.backgroundColor;\n    return currentBackgroundColor !== \"\" ? currentBackgroundColor : \"white\";\n  };\n\n  // Returns all currently active tile-, and image-layers as an array\n  getVisibleTileAndImageLayers = () => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return layer.getVisible() && this.layerIsTileOrImageLayer(layer);\n      });\n  };\n\n  // Returns true if the supplied layer is a tiled or an image-based layer.\n  layerIsTileOrImageLayer = (layer) => {\n    return (\n      (layer instanceof TileLayer && layer.getSource() instanceof TileWMS) ||\n      (layer instanceof ImageLayer && layer.getSource() instanceof ImageWMS)\n    );\n  };\n\n  // Returns all currently active image-layers as an array\n  getVisibleImageLayers = () => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return (\n          layer.getVisible() &&\n          layer instanceof ImageLayer &&\n          layer.getSource() instanceof ImageWMS\n        );\n      });\n  };\n\n  // Returns the layer placement (index) in the array of map-layers.\n  // The placement is generally the draw-order (unless z-index is set on the layer).\n  getLayerPlacementIndex = (layer) => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .map((l) => l.get(\"name\"))\n      .indexOf(layer.get(\"name\"));\n  };\n\n  // Hides the supplied layer and adds another layer with appropriate settings for\n  // printing. The added layer is always an image-layer. Why exchange the sources\n  // with only image sources? Well, it seems as if OL does some funky stuff with all the tiled sources,\n  // leading to an excess of loaded tiles. By making sure to only use image-layers during print, we can\n  // make sure we're not requesting too many tiles, and also that the wms-style is applied properly.\n  exchangeLayer = (layer) => {\n    // Let's run this in a try-catch just in case\n    try {\n      // Since we're adding a \"print-layer\", we want to make sure to hide\n      // the \"real\" layer so that we don't show the same information twice.\n      layer.setVisible(false);\n      // We have to keep track of all the layers that we have hidden, so that\n      // we can show them again when the printing is done.\n      this.hiddenLayers.add(layer);\n      // When we create the new layer, we're gonna need the original source!\n      const source = layer.getSource();\n      // Let's create a new image-source containing all the options from the supplied source\n      // along with some additional settings. We make sure to set the ratio to one (1) so that\n      // OL does not load more data than necessary, and we also make sure to disable hiDpi!\n      // (Otherwise the print-process will fetch more pixels than necessary).\n      const imageSource = new ImageWMS({\n        ...source.getProperties(),\n        projection: source.getProjection(),\n        crossOrigin: source.crossOrigin ?? \"anonymous\",\n        params: { ...source.getParams() },\n        ratio: 1,\n        hidpi: false,\n      });\n      // We have to make sure to check the current layer-opacity and use that\n      // opacity-value on the new layer.\n      const layerOpacity = layer.getOpacity() ?? 1;\n      // Then we can create the new image-layer with the new image-source.\n      const imageLayer = new ImageLayer({\n        opacity: layerOpacity,\n        source: imageSource,\n        zIndex: layer.getZIndex(),\n      });\n      // Finally we add the new layer to the map... First we have to check where\n      // the original layer was placed (so that it keeps its draw-order).\n      const layerPlacement = this.getLayerPlacementIndex(layer);\n      // Then we can add the layer...\n      this.map.getLayers().insertAt(layerPlacement, imageLayer);\n      // ... and update the array containing the added layers so that we can remove\n      // them when the printing process is completed.\n      this.addedLayers.add(imageLayer);\n    } catch (error) {\n      console.error(\n        `Failed to exchange the supplied layer with a print-layer! Error: ${error}`\n      );\n    }\n  };\n\n  // Returns an array of floats representing the bounding box found\n  // in the 'BBOX' query-parameter in the supplied url.\n  getBoundingBoxFromUrl = (url) => {\n    return url.searchParams\n      .get(\"BBOX\")\n      .split(\",\")\n      .map((coord) => parseFloat(coord));\n  };\n\n  // Loads an image (tile) and draws it on the supplied canvas-context\n  loadImageTile = (canvas, tileOptions) => {\n    // We have to get the context so that we can draw the image\n    const ctx = canvas.getContext(\"2d\");\n    // Then we need some tile-information\n    const { url, x, y, tileWidth, tileHeight } = tileOptions;\n    // Let's return a promise...\n    return new Promise((resolve, reject) => {\n      // Let's create an image-element\n      const tile = document.createElement(\"img\");\n      tile.onload = () => {\n        // When the tile has loaded, we can draw the tile on the canvas.\n        ctx.drawImage(tile, x, y, tileWidth, tileHeight);\n        // The promise can be resolved when the tile has been fetched and\n        // drawn on the canvas.\n        resolve();\n      };\n      // If the fetch fails, we have to reject the promise.\n      tile.onerror = () => {\n        reject();\n      };\n      // Let's set the cross-origin-attribute to prevent cors-problems\n      tile.crossOrigin = \"anonymous\";\n      // Then we'll set the url so that the image can be fetched.\n      tile.src = url;\n    });\n  };\n\n  // Creates tile-information-objects for a column (all tiles needed to fill\n  // up to the target-height).\n  getTileColumn = (targetHeight, x, tileWidth) => {\n    // We're gonna need to store the tile-information in an array\n    const tiles = [];\n    // We'll iterate (and push tiles to the tile-array) until...\n    while (true) {\n      // ... we've reached the target-height. Let's summarize all tile-height\n      // so that we can check if we're done.\n      const accHeight = tiles.reduce((acc, curr) => acc + curr.tileHeight, 0);\n      // If we are, we can return the array of tile-information\n      if (accHeight >= targetHeight) return tiles;\n      // Otherwise we'll calculate how many pixels are left...\n      const remainingHeight = targetHeight - accHeight;\n      // And either create a tile with that height (or the max-height if the remainder is too large).\n      const tileHeight =\n        remainingHeight > this.maxTileSize ? this.maxTileSize : remainingHeight;\n      // Then we have to calculate where the tile is to be placed on the canvas later.\n      const y = targetHeight - accHeight - tileHeight;\n      // And finally we'll push the information to the array.\n      tiles.push({\n        x,\n        y,\n        tileWidth,\n        tileHeight,\n      });\n    }\n  };\n\n  // Returns a string representing the bounding-box for the supplied tile.\n  // (WMS-version 1.3.0)\n  // If the WMS-version is set to 1.3.0 the axis-orientation should be set by the\n  // definition of the projection. However, in 'ConfigMapper.js' we specify the\n  // axis-direction as 'NEU' (northing, easting, up). This means we can assume\n  // that the axis-direction is 'NEU' when dealing with version 1.3.0.\n  getVersionThreeBoundingBox = (tile, bBox, height, width) => {\n    // We have to know how much the northing and easting change per pixel, so that we\n    // can calculate proper bounding-boxes for the new tiles.\n    const northingChangePerPixel = (bBox[2] - bBox[0]) / height;\n    const eastingChangePerPixel = (bBox[3] - bBox[1]) / width;\n    // Then we can construct the bounding-box-string:\n    // The bounding-box is calculated by combining how much the bounding-box\n    // changes per pixel, along with the supplied tile height, width, and position\n    // (presented as pixel-values). For information regarding x, and y, see:\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage\n    return `${\n      bBox[0] + northingChangePerPixel * (height - tile.y - tile.tileHeight)\n    },${bBox[1] + eastingChangePerPixel * tile.x},${\n      bBox[0] + northingChangePerPixel * (height - tile.y)\n    }, ${bBox[1] + eastingChangePerPixel * (tile.x + tile.tileWidth)}`;\n  };\n\n  // Returns a string representing the bounding-box for the supplied tile.\n  // (WMS-version 1.1.1)\n  // In version 1.1.1 the axis orientation is always 'ENU' (easting-northing-up).\n  getVersionOneBoundingBox = (tile, bBox, height, width) => {\n    // We have to know how much the northing and easting change per pixel, so that we\n    // can calculate proper bounding-boxes for the new tiles.\n    const northingChangePerPixel = (bBox[3] - bBox[1]) / height;\n    const eastingChangePerPixel = (bBox[2] - bBox[0]) / width;\n    // Then we can construct the bounding-box-string:\n    // The bounding-box is calculated by combining how much the bounding-box\n    // changes per pixel, along with the supplied tile height, width, and position\n    // (presented as pixel-values). For information regarding x, and y, see:\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage\n    return `${bBox[0] + eastingChangePerPixel * tile.x},${\n      bBox[1] + northingChangePerPixel * (height - tile.y - tile.tileHeight)\n    },${bBox[0] + eastingChangePerPixel * (tile.x + tile.tileWidth)},${\n      bBox[1] + northingChangePerPixel * (height - tile.y)\n    }`;\n  };\n\n  // Appends a bounding-box to each tile-information-object.\n  appendBoundingBox = (tiles, bBox, height, width, wmsVersion) => {\n    // The bounding-box calculations might seem a bit messy... One reason for that\n    // is that the x- and y-values for the tiles are set to match how images are added\n    // to a canvas, and those coordinates go the opposite direction compared to the map-coordinate-axels.\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage for more info.\n    // Let's calculate and set the bounding-box for each tile-information-object.\n    for (const tile of tiles) {\n      // We have to make sure to check if we're dealing with version 1.3.0 or 1.1.1\n      // so that we can handle the axis-orientation properly.\n      if (wmsVersion === \"1.3.0\") {\n        tile.bBox = this.getVersionThreeBoundingBox(tile, bBox, height, width);\n      } else {\n        // If we're not dealing with version 1.3.0, we're probably dealing with 1.1.1\n        tile.bBox = this.getVersionOneBoundingBox(tile, bBox, height, width);\n      }\n    }\n  };\n\n  // Returns an array of objects containing information regarding the tiles\n  // that should be created to comply with the supplied 'MAX_TILE_SIZE' and\n  // also 'fill' the image.\n  getTileInformation = (height, width, url) => {\n    // We're gonna want to return an array containing the tile-objects\n    const tiles = [];\n    // We're also gonna need to keep track of the original bounding box. This bounding-box\n    // will be used to calculate the new bounding-boxes for each tile that we're about to create.\n    const bBox = this.getBoundingBoxFromUrl(url);\n    // Since the northing and easting axels are flipped in version 1.1.0 vs 1.3.0 we\n    // have to make sure to check which WMS-version we are dealing with.\n    const wmsVersion = url.searchParams.get(\"VERSION\");\n    // To gather all the required tile-information we will work with 'columns'. This means\n    // we will create all necessary images at a fixed width, and then move to the next width.\n    // We'll do this until we've created enough columns to fill the entire width.\n    let accWidth = 0;\n    while (true) {\n      // If we've created enough columns to fill the supplied width, we can break.\n      if (accWidth >= width) break;\n      // Otherwise we'll check how many pixels remain until we do...\n      const remainingWidth = width - accWidth;\n      // We'll use a tile-width that is either:\n      // - The remaining amount of pixels\n      // - The max tile-size\n      const tileWidth =\n        remainingWidth > this.maxTileSize ? this.maxTileSize : remainingWidth;\n      // Then we'll create a column of tiles\n      tiles.push(...this.getTileColumn(height, accWidth, tileWidth));\n      // And bump the current width\n      accWidth += tileWidth;\n    }\n    // When the tile-information is created, we can append the bounding-box-information\n    // to each tile. The bounding-box-information will be used to fetch the tiles later.\n    this.appendBoundingBox(tiles, bBox, height, width, wmsVersion);\n    // Finally we can return the tile-information.\n    return tiles;\n  };\n\n  // Updates the parameters of the supplied layer to make sure we\n  // request the images in the correct DPI for the print! This function\n  // only handles image-layers.\n  prepareImageLayer = (layer, options) => {\n    // Let's run this in a try-catch just in case\n    try {\n      // We're gonna need to grab the layer-source\n      const source = layer.getSource();\n      // We have to update the image-loading-function (so that the current print-DPI is taken\n      // into consideration).\n      source.setImageLoadFunction((image, src) => {\n        // Let's create an URL-object so that we can easily grab and alter search-parameters.\n        const url = new URL(src);\n        const searchParams = url.searchParams;\n        // We have to make sure to update the search-parameters to include dpi-settings.\n        searchParams.set(\"DPI\", options.resolution);\n        searchParams.set(\"MAP_RESOLUTION\", options.resolution);\n        searchParams.set(\"FORMAT_OPTIONS\", `dpi:${options.resolution}`);\n        // We're gonna need to grab the width and height so that we can make sure the\n        // requested image is not too large for the WMS-server to render. (If we're requesting\n        // too many pixels at a high DPI the server will not be able to create the image).\n        const height = parseFloat(searchParams.get(\"HEIGHT\")) || 1;\n        const width = parseFloat(searchParams.get(\"WIDTH\")) || 1;\n        // What will be too complex for the WMS-servers? Good question. For now,\n        // we say that the image is too complex if either the height or width is larger than\n        // 'this.maxTileSize' (around 4096 probably).\n        if (Math.max(height, width) > this.maxTileSize) {\n          // If the image is too complex, we have to create tiles that are no more than 'this.maxTileSize'\n          // wide or high. Let's gather some tile-information to begin with.\n          const tiles = this.getTileInformation(height, width, url);\n          // Then we'll create a canvas that we can use to draw the tile-images on.\n          const canvas = document.createElement(\"canvas\");\n          // The canvas must be as big as the originally requested image was.\n          canvas.width = width;\n          canvas.height = height;\n          // Let's declare an array that we can use to store all the promises created when\n          // requesting the tile-images.\n          const promises = [];\n          // Then, for each tile-information-object, we'll create a request-url containing the\n          // information that we've gathered (such as the size and bounding-box).\n          for (const tile of tiles) {\n            const tileUrl = new URL(url.toString());\n            tileUrl.searchParams.set(\"BBOX\", tile.bBox);\n            tileUrl.searchParams.set(\"HEIGHT\", tile.tileHeight);\n            tileUrl.searchParams.set(\"WIDTH\", tile.tileWidth);\n            // Then we'll fetch the images from the WMS-server\n            promises.push(\n              this.loadImageTile(canvas, { ...tile, url: tileUrl.toString() })\n            );\n          }\n          // When all image-promises has settled, we can set the image to the canvas on which we've\n          // added all the tile-images.\n          Promise.allSettled(promises).then(() => {\n            image.getImage().src = canvas.toDataURL();\n          });\n        } else {\n          // If the request is not too complex, we can fetch it right away.\n          image.getImage().src = url.toString();\n        }\n      });\n    } catch (error) {\n      console.error(\n        `Failed to update the DPI-options while creating print-image (Single-tile WMS). Error: ${error}`\n      );\n    }\n  };\n\n  // Since we're allowing the user to print the map with different DPI-options,\n  // the layers that are about to be printed must be prepared. The preparation consists\n  // of settings the DPI-parameters so that we ensure that we are sending proper WMS-requests.\n  // (If we would print with 300 dpi, and just let OL send an ordinary request, the images returned\n  // from the server would not show the correct layout for 300 DPI usage).\n  // To do this, we first make sure to exchange all visible layers with \"prepared image-layers\". This is done since\n  // OL seems to do some funky stuff to the tile-layers, and image-layers gives us more control.\n  // TODO: Vector-layers, for example from the draw-plugin, must be handled as well. Otherwise, the text\n  // on vector-layers will be very small when printing with high DPI.\n  prepareActiveLayersForPrint = (options) => {\n    // First we have to exchange all visible tile-, and image-layers for \"print-image-layers\".\n    for (const layer of this.getVisibleTileAndImageLayers()) {\n      this.exchangeLayer(layer, options);\n    }\n    // Then we have to \"prepare\" all currently visible image-layers. Note that all currently\n    // visible image-layers will be layers created in the method above! (Since all other image-layers\n    // has been turned off. They will be turned back on when the printing is complete).\n    for (const imageLayer of this.getVisibleImageLayers()) {\n      this.prepareImageLayer(imageLayer, options);\n    }\n  };\n\n  // Since we've been adding and hiding layers while printing, we have to make sure to reset\n  // everything back to normal!\n  resetPrintLayers = () => {\n    // Since we have been hiding all tile- and image-layers and exchanged them with\n    // \"print-image-layers\", we have to make sure to:\n    // 1. Show the original layers again\n    for (const layer of this.hiddenLayers) {\n      layer.setVisible(true);\n    }\n    // 2. Remove the added image-layers\n    for (const layer of this.addedLayers) {\n      this.map.removeLayer(layer);\n    }\n    // When all layers has been reset and so on, we'll have to reset the collections\n    // containing the added/hidden layers.\n    this.hiddenLayers = new Set();\n    this.addedLayers = new Set();\n  };\n\n  // Adds fonts needed to properly render necessary characters. (The default jsPDF fonts does not support all characters).\n  // Also enables a font (in the future we could provide a possibility for the user to select font).\n  setupFonts = (pdf, font = \"ROBOTO_NORMAL\") => {\n    // First we'll add the available fonts\n    pdf.addFileToVFS(\"roboto-normal.ttf\", ROBOTO_NORMAL);\n    pdf.addFont(\"roboto-normal.ttf\", \"roboto-normal\", \"normal\");\n    // Then we'll set the font we want to use now. (The switch below is unnecessary but\n    // added for possible future use cases).\n    switch (font) {\n      case \"ROBOTO_NORMAL\":\n        pdf.setFont(\"roboto-normal\");\n        break;\n      default:\n        break;\n    }\n  };\n\n  print = (options) => {\n    const format = options.format;\n    const orientation = options.orientation;\n    const resolution = options.resolution;\n    const scale = options.scale / 1000;\n\n    // Our dimensions are for landscape orientation by default. Flip the values if portrait orientation requested.\n    const dim =\n      orientation === \"portrait\"\n        ? [...this.dims[format]].reverse()\n        : this.dims[format];\n\n    const width = Math.round((dim[0] * resolution) / 25.4);\n    const height = Math.round((dim[1] * resolution) / 25.4);\n\n    // Since we're allowing the users to choose which DPI they want to print the map\n    // in, we have to make sure to prepare the layers so that they are fetched with\n    // the correct DPI-settings! We're only doing this if we're supposed to. An admin\n    // might choose not to use this functionality (useCustomTileLoaders set to false).\n    this.useCustomTileLoaders && this.prepareActiveLayersForPrint(options);\n\n    // Before we're printing we must make sure to change the map-view from the\n    // original one, to the print-view.\n    this.printView.setCenter(this.originalView.getCenter());\n    this.map.setView(this.printView);\n\n    // Store mapsize, it's needed when map is restored after print or cancel.\n    this.originalMapSize = this.map.getSize();\n\n    const scaleResolution = this.getScaleResolution(\n      scale,\n      resolution,\n      this.map.getView().getCenter()\n    );\n\n    // Save some of our values that are necessary to use if user want to cancel the process\n\n    this.map.once(\"rendercomplete\", async () => {\n      if (this.pdfCreationCancelled === true) {\n        this.pdfCreationCancelled = false;\n        return false;\n      }\n\n      // This is needed to prevent some buggy output from some browsers\n      // when a lot of tiles are being rendered (it could result in black\n      // canvas PDF)\n      await delay(500);\n\n      // Create the map canvas that will hold all of our map tiles\n      const mapCanvas = document.createElement(\"canvas\");\n\n      // Set canvas dimensions to the newly calculated ones that take user's desired resolution etc into account\n      mapCanvas.width = width;\n      mapCanvas.height = height;\n\n      const mapContext = mapCanvas.getContext(\"2d\");\n      const backgroundColor = this.getMapBackgroundColor(); // Make sure we use the same background-color as the map\n      mapContext.fillStyle = backgroundColor;\n      mapContext.fillRect(0, 0, width, height);\n\n      // Each canvas element inside OpenLayer's viewport should get printed\n      document.querySelectorAll(\".ol-viewport canvas\").forEach((canvas) => {\n        if (canvas.width > 0) {\n          const opacity = canvas.parentNode.style.opacity;\n          mapContext.globalAlpha = opacity === \"\" ? 1 : Number(opacity);\n          // Get the transform parameters from the style's transform matrix\n          if (canvas.style.transform) {\n            const matrix = canvas.style.transform\n              .match(/^matrix\\(([^(]*)\\)$/)[1]\n              .split(\",\")\n              .map(Number);\n            // Apply the transform to the export map context\n            CanvasRenderingContext2D.prototype.setTransform.apply(\n              mapContext,\n              matrix\n            );\n          }\n          mapContext.drawImage(canvas, 0, 0);\n        }\n      });\n\n      // Initiate the PDF object\n      const pdf = new jsPDF({\n        orientation,\n        format,\n        putOnlyUsedFonts: true,\n        compress: true,\n      });\n\n      // Make sure to add necessary fonts and enable the font we want to use.\n      this.setupFonts(pdf, \"ROBOTO_NORMAL\");\n\n      // Add our map canvas to the PDF, start at x/y=0/0 and stretch for entire width/height of the canvas\n      pdf.addImage(mapCanvas, \"JPEG\", 0, 0, dim[0], dim[1]);\n\n      if (this.includeImageBorder) {\n        // Frame color is set to dark gray\n        pdf.setDrawColor(this.textColor);\n        pdf.setLineWidth(0.5);\n        pdf.rect(0.3, 0.3, dim[0] - 0.5, dim[1] - 0, \"S\");\n      }\n\n      // Add potential margin around the image\n      if (this.margin > 0) {\n        // We always want a white margin\n        pdf.setDrawColor(\"white\");\n        // We want to check if user has chosen to put icons and text\n        // in the margins, which if so, must be larger than usual\n        // Note that we first check if user has NOT chosen this (!).\n        if (!options.useTextIconsInMargin) {\n          // The lineWidth increases the line width equally to \"both sides\",\n          // therefore, we must have a line width two times the margin we want.\n          pdf.setLineWidth(this.margin * 2);\n          // Draw the border (margin) around the entire image\n          pdf.rect(0, 0, dim[0], dim[1], \"S\");\n          // If selected as feature in Admin, we draw a frame around the map image\n          if (this.includeImageBorder) {\n            // Frame color is set to dark gray\n            pdf.setDrawColor(this.textColor);\n            pdf.setLineWidth(0.5);\n            pdf.rect(\n              this.margin,\n              this.margin,\n              dim[0] - this.margin * 2,\n              dim[1] - this.margin * 2,\n              \"S\"\n            );\n          }\n          // Now we check if user did choose text in margins\n        } else {\n          // We do a special check for a5-format and set the dimValue\n          // to get the correct margin values when drawing the rectangle\n          let dimValue =\n            options.format === \"a5\" ? this.margin + 2 : this.margin;\n          // This lineWidth needs to be larger if user has chosen text in margins\n          pdf.setLineWidth(dimValue * 6);\n          // Draw the increased border (margin) around the entire image\n          // here with special values for larger margins.\n          pdf.rect(-(dimValue * 2), 0, dim[0] + dimValue * 4, dim[1], \"S\");\n          // If selected as feature in Admin, we draw a frame around the map image\n          if (this.includeImageBorder) {\n            // Frame color is set to dark gray\n            pdf.setDrawColor(this.textColor);\n            pdf.setLineWidth(0.5);\n            pdf.rect(\n              dimValue,\n              dimValue * 3,\n              dim[0] - dimValue * 2,\n              dim[1] - dimValue * 6,\n              \"S\"\n            );\n          }\n        }\n      }\n      // If logo URL is provided, add the logo to the map\n      if (options.includeLogo && this.logoUrl.trim().length >= 5) {\n        try {\n          const {\n            data: logoData,\n            width: logoWidth,\n            height: logoHeight,\n          } = await this.getImageForPdfFromUrl(this.logoUrl, this.logoMaxWidth);\n\n          let logoPlacement = this.getPlacement(\n            options.logoPlacement,\n            logoWidth,\n            logoHeight,\n            dim[0],\n            dim[1]\n          );\n\n          pdf.addImage(\n            logoData,\n            \"PNG\",\n            logoPlacement.x,\n            logoPlacement.y,\n            logoWidth,\n            logoHeight\n          );\n        } catch (error) {\n          // The image loading may fail due to e.g. wrong URL, so let's catch the rejected Promise\n          this.localObserver.publish(\"error-loading-logo-image\");\n        }\n      }\n\n      if (options.includeNorthArrow && this.northArrowUrl.trim().length >= 5) {\n        try {\n          const {\n            data: arrowData,\n            width: arrowWidth,\n            height: arrowHeight,\n          } = await this.getImageForPdfFromUrl(\n            this.northArrowUrl,\n            this.northArrowMaxWidth\n          );\n\n          const arrowPlacement = this.getPlacement(\n            options.northArrowPlacement,\n            arrowWidth,\n            arrowHeight,\n            dim[0],\n            dim[1]\n          );\n\n          pdf.addImage(\n            arrowData,\n            \"PNG\",\n            arrowPlacement.x,\n            arrowPlacement.y,\n            arrowWidth,\n            arrowHeight\n          );\n        } catch (error) {\n          // The image loading may fail due to e.g. wrong URL, so let's catch the rejected Promise\n          this.localObserver.publish(\"error-loading-arrow-image\");\n        }\n      }\n\n      if (options.includeScaleBar) {\n        this.addScaleBar(\n          pdf,\n          options.mapTextColor,\n          options.scale,\n          options.resolution,\n          options.scaleBarPlacement,\n          scaleResolution,\n          options.format,\n          options.orientation\n        );\n      }\n\n      // Add map title if user supplied one\n      if (options.mapTitle.trim().length > 0) {\n        let verticalMargin = options.useTextIconsInMargin\n          ? 8 + this.margin\n          : 12 + this.margin;\n        pdf.setFontSize(24);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(options.mapTitle, dim[0] / 2, verticalMargin, {\n          align: \"center\",\n        });\n      }\n\n      // Add print comment if user supplied one\n      if (options.printComment.trim().length > 0) {\n        let yPos = options.useTextIconsInMargin\n          ? 13 + this.margin\n          : 18 + this.margin;\n        pdf.setFontSize(11);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(options.printComment, dim[0] / 2, yPos, {\n          align: \"center\",\n        });\n      }\n\n      // Add potential copyright text\n      if (this.copyright.length > 0) {\n        let yPos = options.useTextIconsInMargin\n          ? this.textIconsMargin + this.margin / 2\n          : this.margin;\n        pdf.setFontSize(8);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(this.copyright, dim[0] - 4 - yPos, dim[1] - 5.5 - yPos, {\n          align: \"right\",\n        });\n      }\n\n      // Add potential date text\n      if (this.date.length > 0) {\n        const date = this.date.replace(\n          \"{date}\",\n          new Date().toLocaleDateString()\n        );\n        let yPos = options.useTextIconsInMargin\n          ? this.textIconsMargin + this.margin / 2\n          : this.margin;\n        pdf.setFontSize(8);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(date, dim[0] - 4 - yPos, dim[1] - 2 - yPos, {\n          align: \"right\",\n        });\n      }\n\n      // Add potential disclaimer text\n      if (this.disclaimer.length > 0) {\n        let yPos = options.useTextIconsInMargin\n          ? this.textIconsMargin + this.margin / 2\n          : this.margin;\n        pdf.setFontSize(8);\n        pdf.setTextColor(options.mapTextColor);\n        let textLines = pdf.splitTextToSize(\n          this.disclaimer,\n          dim[0] / 2 - this.margin - 8\n        );\n        let textLinesDims = pdf.getTextDimensions(textLines, { fontSize: 8 });\n        pdf.text(\n          textLines,\n          dim[0] - 4 - yPos,\n          dim[1] - 6 - yPos - textLinesDims.h,\n          {\n            align: \"right\",\n          }\n        );\n      }\n\n      // Since we've been messing with the layer-settings while printing, we have to\n      // make sure to reset these settings. (Should only be done if custom loaders has been used).\n      this.useCustomTileLoaders && this.resetPrintLayers();\n\n      // Finally, save the PDF (or PNG)\n      this.saveToFile(pdf, width, options.saveAsType)\n        .then(() => {\n          this.localObserver.publish(\"print-completed\");\n        })\n        .catch((error) => {\n          console.warn(error);\n          this.localObserver.publish(\"print-failed-to-save\");\n        })\n        .finally(() => {\n          // Reset map to how it was before print\n          this.restoreOriginalView();\n        });\n    });\n\n    // Get print center from preview feature's center coordinate\n    const printCenter = getCenter(\n      this.previewFeature.getGeometry().getExtent()\n    );\n\n    // Hide our preview feature so it won't get printed\n    this.previewLayer.setVisible(false);\n\n    // Set map size and resolution, this will initiate print, as we have a listener for renderComplete.\n    // (Which will fire when the new size and resolution has been set and the new tiles has been loaded).\n    this.map.getTargetElement().style.width = `${width}px`;\n    this.map.getTargetElement().style.height = `${height}px`;\n    this.map.updateSize();\n    this.map.getView().setCenter(printCenter);\n    this.map.getView().setResolution(scaleResolution);\n  };\n\n  restoreOriginalView = () => {\n    this.previewLayer.setVisible(true);\n    this.map.setSize(this.originalMapSize);\n    this.map.getTargetElement().style.width = \"\";\n    this.map.getTargetElement().style.height = \"\";\n    this.map.updateSize();\n    this.map.setView(this.originalView);\n  };\n\n  // Imports and returns the dependencies required to create a PNG-print-export.\n  #getPngDependencies = async () => {\n    try {\n      const pdfjs = await import(\"pdfjs-dist/build/pdf\");\n      return { pdfjs };\n    } catch (error) {\n      throw new Error(\n        `Failed to import required dependencies. Error: ${error}`\n      );\n    }\n  };\n\n  // Saves the supplied PDF with the supplied file-name.\n  #saveToPdf = async (pdf, fileName) => {\n    try {\n      pdf.save(`${fileName}.pdf`);\n    } catch (error) {\n      throw new Error(`Failed to save PDF. Error: ${error}`);\n    }\n  };\n\n  // Saves the supplied PDF *as a PNG* with the supplied file-name.\n  // The width of the document has to be supplied since some calculations\n  // must be done in order to create a PNG with the correct resolution etc.\n  #saveToPng = async (pdf, fileName, width) => {\n    try {\n      // First we'll dynamically import the required dependencies.\n      const { pdfjs } = await this.#getPngDependencies();\n      // Then we'll set up the pdfJS-worker. TODO: Terrible?! PDF-js does not seem to have a better solution for the\n      // source-map-errors that occur from setting the worker the ordinary way.\n      pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`;\n      // We'll output the PDF as an array-buffer that can be used to create the PNG.\n      const ab = pdf.output(\"arraybuffer\");\n      // We'll use the PDF-JS library to create a new \"PDF-JS-PDF\". (Wasteful? Yes very, but the JS-PDF-library\n      // does not support export to any other format than PDF, and the PDF-JS-library does.) Notice that\n      // JS-PDF and PDF-JS are two different libraries, both with their pros and cons.\n      // - PDF-JS: Pro => Can export to PNG, Con: Cannot create as nice of an image as JS-PDF.\n      // - JS-PDF: Pro => Creates good-looking PDFs, Con: Cannot export to PNG.\n      // - Conclusion: We use both...\n      pdfjs.getDocument({ data: ab }).promise.then((pdf) => {\n        // So, when the PDF-JS-PDF is created, we get the first page, and then render\n        // it on a canvas so that we can export it as a PNG.\n        pdf.getPage(1).then((page) => {\n          // We're gonna need a canvas and its context.\n          let canvas = document.createElement(\"canvas\");\n          let ctx = canvas.getContext(\"2d\");\n          // Scale the viewport to match current resolution\n          const viewport = page.getViewport({ scale: 1 });\n          const scale = width / viewport.width;\n          const scaledViewport = page.getViewport({ scale: scale });\n          // Create the render-context-object.\n          const renderContext = {\n            canvasContext: ctx,\n            viewport: scaledViewport,\n          };\n          // Set the canvas dimensions to the correct width and height.\n          canvas.height = scaledViewport.height;\n          canvas.width = scaledViewport.width;\n          // Then we'll render and save!\n          page.render(renderContext).promise.then(() => {\n            canvas.toBlob((blob) => {\n              saveAs(blob, `${fileName}.png`);\n            });\n          });\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to save PNG. Error: ${error}`);\n    }\n  };\n\n  // Saves the print-contents to file, either PDF, or PNG (depending on supplied type).\n  saveToFile = async (pdf, width, type) => {\n    // We're gonna need to create a file-name.\n    const fileName = `Kartexport - ${new Date().toLocaleString()}`;\n    // Then we'll try to save the contents in the format the user requested.\n    try {\n      switch (type) {\n        case \"PDF\":\n          return this.#saveToPdf(pdf, fileName);\n        case \"PNG\":\n          return this.#saveToPng(pdf, fileName, width);\n        default:\n          throw new Error(\n            `Supplied type could not be handled. The supplied type was ${type} and currently only PDF and PNG is supported.`\n          );\n      }\n    } catch (error) {\n      throw new Error(`Failed to save file... ${error}`);\n    }\n  };\n\n  cancelPrint = () => {\n    // Set this flag to prevent \"rendercomplete\" from firing\n    this.pdfCreationCancelled = true;\n\n    // Reset map to how it was before print\n    this.restoreOriginalView();\n    // Reset the layer-settings to how it was before print.\n    // (Should only be done if custom loaders has been used).\n    this.useCustomTileLoaders && this.resetPrintLayers();\n  };\n\n  /**\n   * @description Using toLocalString for sv-SE is the easiest way to get space as thousand separator.\n   *\n   * @param {*} scale Number that will be prefixed with \"1:\"\n   * @returns {string} Input parameter, prefixed by \"1:\" and with spaces as thousands separator, e.g \"5000\" -> \"1:5 000\".\n   */\n  getUserFriendlyScale = (scale) => {\n    return `1:${Number(scale).toLocaleString()}`;\n  };\n}\n"],"names":["PrintModel","constructor","settings","defaultScaleBarLengths","previewLayer","previewFeature","marginAmount","margin","textIconsMargin","pdfCreationCancelled","getMapScale","this","printView","setZoom","originalView","getZoom","mpu","getProjection","getMetersPerUnit","getResolution","getFittingScale","proposedScale","scales","reduce","prev","curr","Math","abs","removePreview","undefined","getSource","clear","map","removeInteraction","translate","getPreviewCenter","extent","getGeometry","getExtent","getCenter","getMargin","paperDim","longestSide","max","getPaperDim","format","orientation","dims","reverse","renderPreviewFeature","previewLayerVisible","options","addPreview","getImageDataBlobFromUrl","url","Promise","resolve","reject","image","Image","setAttribute","onerror","err","onload","imgCanvas","document","createElement","width","naturalWidth","height","naturalHeight","getContext","drawImage","data","toDataURL","src","getImageForPdfFromUrl","async","maxWidth","sourceWidth","sourceHeight","ratio","getPlacement","placement","contentWidth","contentHeight","pdfWidth","pdfHeight","pdfPlacement","x","y","getFittingScaleBarLength","scale","length","scaleBarLengths","getLengthText","scaleBarLengthMeters","units","Number","toLocaleString","getDivLinesArrayAndDivider","scaleBarLength","scaleBarLengthMetersStr","toString","scaleBarFirstDigits","parseInt","substring","scaleLength","divider","pow","divLinePixelsCount","divLinesArray","divLine","push","addDividerLinesAndTexts","props","drawDividerLines","addDividerTexts","pdf","scaleBarPosition","color","setFontSize","setTextColor","text","calculatedScaleBarLengthMeters","scaleBarHasSpace","divNr","divNrString","midIndex","round","dividerNrPosition","dividerStrLength","drawScaleBar","lengthText","setLineWidth","getUserFriendlyScale","toUpperCase","addScaleBar","resolution","scaleBarPlacement","scaleResolution","pixelSize","internal","pageSize","desiredPrintOptionsOk","getScaleResolution","getView","getMinResolution","center","getPointResolution","getMapBackgroundColor","currentBackgroundColor","getElementById","style","backgroundColor","getVisibleTileAndImageLayers","getLayers","getArray","filter","layer","getVisible","layerIsTileOrImageLayer","TileLayer","TileWMS","ImageLayer","ImageWMS","getVisibleImageLayers","getLayerPlacementIndex","l","get","indexOf","exchangeLayer","setVisible","hiddenLayers","add","source","imageSource","getProperties","projection","crossOrigin","params","getParams","hidpi","layerOpacity","getOpacity","imageLayer","opacity","zIndex","getZIndex","layerPlacement","insertAt","addedLayers","error","console","getBoundingBoxFromUrl","searchParams","split","coord","parseFloat","loadImageTile","canvas","tileOptions","ctx","tileWidth","tileHeight","tile","getTileColumn","targetHeight","tiles","accHeight","acc","remainingHeight","maxTileSize","getVersionThreeBoundingBox","bBox","northingChangePerPixel","eastingChangePerPixel","getVersionOneBoundingBox","appendBoundingBox","wmsVersion","getTileInformation","accWidth","remainingWidth","prepareImageLayer","setImageLoadFunction","URL","set","promises","tileUrl","allSettled","then","getImage","prepareActiveLayersForPrint","resetPrintLayers","removeLayer","Set","setupFonts","font","addFileToVFS","ROBOTO_NORMAL","addFont","setFont","print","dim","useCustomTileLoaders","setCenter","setView","originalMapSize","getSize","once","delay","mapCanvas","mapContext","fillStyle","fillRect","querySelectorAll","forEach","parentNode","globalAlpha","transform","matrix","match","CanvasRenderingContext2D","prototype","setTransform","apply","jsPDF","putOnlyUsedFonts","compress","addImage","includeImageBorder","setDrawColor","textColor","rect","useTextIconsInMargin","dimValue","includeLogo","logoUrl","trim","logoData","logoWidth","logoHeight","logoMaxWidth","logoPlacement","localObserver","publish","includeNorthArrow","northArrowUrl","arrowData","arrowWidth","arrowHeight","northArrowMaxWidth","arrowPlacement","northArrowPlacement","includeScaleBar","mapTextColor","mapTitle","verticalMargin","align","printComment","yPos","copyright","date","replace","Date","toLocaleDateString","disclaimer","textLines","splitTextToSize","textLinesDims","getTextDimensions","fontSize","h","saveToFile","saveAsType","catch","warn","finally","restoreOriginalView","printCenter","getTargetElement","updateSize","setResolution","setSize","pdfjs","Error","fileName","save","GlobalWorkerOptions","workerSrc","version","ab","output","getDocument","promise","getPage","page","viewport","getViewport","scaledViewport","renderContext","canvasContext","render","toBlob","blob","saveAs","type","cancelPrint","logo","northArrow","scaleMeters","calculateScaleBarLengths","mapConfig","View","constrainOnlyCenter","constrainResolution","maxZoom","minZoom","resolutions","allResolutions","zoom","index","addPreviewLayer","Vector","VectorSource","layerType","name","caption","Style","stroke","Stroke","fill","Fill","addLayer","useMargin","dpi","calculatedWidth","calculatedHeight","paper","w","coords","feature","Feature","geometry","Polygon","addFeature","Translate","features","Collection","addInteraction","line","largerMiddleLineValue","numLine"],"sourceRoot":""}