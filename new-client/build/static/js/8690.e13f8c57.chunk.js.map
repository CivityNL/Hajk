{"version":3,"file":"static/js/8690.e13f8c57.chunk.js","mappings":"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","sources":["../node_modules/ol/interaction/Modify.js","../node_modules/ol/interaction/Select.js","../node_modules/ol/interaction/Translate.js"],"sourcesContent":["/**\n * @module ol/interaction/Modify\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {\n  altKeyOnly,\n  always,\n  primaryAction,\n  singleClick,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  buffer as bufferExtent,\n  createOrUpdateFromCoordinate as createExtent,\n} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  equals as coordinatesEqual,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {equals} from '../array.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\n\n/**\n * The segment index assigned to a circle's center when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CENTER_INDEX = 0;\n\n/**\n * The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n * @type {number}\n */\nconst CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\nconst tempExtent = [0, 0, 0, 0];\nconst tempSegment = [];\n\n/**\n * @enum {string}\n */\nconst ModifyEventType = {\n  /**\n   * Triggered upon feature modification start\n   * @event ModifyEvent#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ModifyEvent#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend',\n};\n\n/**\n * @typedef {Object} SegmentData\n * @property {Array<number>} [depth] Depth.\n * @property {import(\"../Feature\").FeatureLike} feature Feature.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} [index] Index.\n * @property {Array<Array<number>>} segment Segment.\n * @property {Array<SegmentData>} [featureSegments] FeatureSegments.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event will be considered to add or move a\n * vertex to the sketch. Default is\n * {@link module:ol/events/condition.primaryAction}.\n * @property {import(\"../events/condition.js\").Condition} [deleteCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. By default,\n * {@link module:ol/events/condition.singleClick} with\n * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.\n * @property {import(\"../events/condition.js\").Condition} [insertVertexCondition] A\n * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether a new vertex should be added to the sketch\n * features. Default is {@link module:ol/events/condition.always}.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style used for the modification point or vertex. For linestrings and polygons, this will\n * be the affected vertex, for circles a point along the circle, and for points the actual\n * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).\n * When using a style function, the point feature passed to the function will have a `features`\n * property - an array whose entries are the features that are being modified, and a `geometries`\n * property - an array whose entries are the geometries that are being modified. Both arrays are\n * in the same order. The `geometries` are only useful when modifying geometry collections, where\n * the geometry will be the particular geometry from the collection that is being modified.\n * @property {VectorSource} [source] The vector source with\n * features to modify.  If a vector source is not provided, a feature collection\n * must be provided with the `features` option.\n * @property {boolean|import(\"../layer/BaseVector\").default} [hitDetection] When configured, point\n * features will be considered for modification based on their visual appearance, instead of being within\n * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is\n * provided, only the rendered representation of the features on that layer will be considered.\n * @property {Collection<Feature>} [features]\n * The features the interaction works on.  If a feature collection is not\n * provided, a vector source must be provided with the `source` option.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the\n * pointer coordinate when clicked within the `pixelTolerance`.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are\n * instances of this type.\n */\nexport class ModifyEvent extends Event {\n  /**\n   * @param {ModifyEventType} type Type.\n   * @param {Collection<import(\"../Feature\").FeatureLike>} features\n   * The features modified.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent\n   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, features, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being modified.\n     * @type {Collection<import(\"../Feature\").FeatureLike>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * Cartesian distance from the pointer is used to determine the features that\n * will be modified. This means that geometries will only be considered for\n * modification when they are within the configured `pixelTolerance`. For point\n * geometries, the `hitDetection` option can be used to match their visual\n * appearance.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n * @fires ModifyEvent\n * @api\n */\nclass Modify extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ModifyOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ModifyOnSignature<void>}\n     */\n    this.un;\n\n    /** @private */\n    this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : primaryAction;\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultDeleteCondition_ = function (mapBrowserEvent) {\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n    };\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.deleteCondition_ = options.deleteCondition\n      ? options.deleteCondition\n      : this.defaultDeleteCondition_;\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.insertVertexCondition_ = options.insertVertexCondition\n      ? options.insertVertexCondition\n      : always;\n\n    /**\n     * Editing vertex.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    /**\n     * Segments intersecting {@link this.vertexFeature_} by segment uid.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.vertexSegments_ = null;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.lastPixel_ = [0, 0];\n\n    /**\n     * Tracks if the next `singleclick` event should be ignored to prevent\n     * accidental deletion right after vertex creation.\n     * @type {boolean}\n     * @private\n     */\n    this.ignoreNextSingleClick_ = false;\n\n    /**\n     * @type {Collection<import(\"../Feature\").FeatureLike>}\n     * @private\n     */\n    this.featuresBeingModified_ = null;\n\n    /**\n     * Segment RTree for each layer\n     * @type {RBush<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Indicate whether the interaction is currently changing a feature's\n     * coordinates.\n     * @type {boolean}\n     * @private\n     */\n    this.changingFeature_ = false;\n\n    /**\n     * @type {Array}\n     * @private\n     */\n    this.dragSegments_ = [];\n\n    /**\n     * Draw overlay where sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * @const\n     * @private\n     * @type {!Object<string, function(Feature, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_.bind(this),\n      'LineString': this.writeLineStringGeometry_.bind(this),\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\n      'Polygon': this.writePolygonGeometry_.bind(this),\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\n      'Circle': this.writeCircleGeometry_.bind(this),\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\n    };\n\n    /**\n     * @type {VectorSource}\n     * @private\n     */\n    this.source_ = null;\n\n    /**\n     * @type {boolean|import(\"../layer/BaseVector\").default}\n     */\n    this.hitDetection_ = null;\n\n    /** @type {Collection<Feature>} */\n    let features;\n    if (options.features) {\n      features = options.features;\n    } else if (options.source) {\n      this.source_ = options.source;\n      features = new Collection(this.source_.getFeatures());\n      this.source_.addEventListener(\n        VectorEventType.ADDFEATURE,\n        this.handleSourceAdd_.bind(this)\n      );\n      this.source_.addEventListener(\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceRemove_.bind(this)\n      );\n    }\n    if (!features) {\n      throw new Error(\n        'The modify interaction requires features, a source or a layer'\n      );\n    }\n    if (options.hitDetection) {\n      this.hitDetection_ = options.hitDetection;\n    }\n\n    /**\n     * @type {Collection<import(\"../Feature.js\").FeatureLike>}\n     * @private\n     */\n    this.features_ = features;\n\n    this.features_.forEach(this.addFeature_.bind(this));\n    this.features_.addEventListener(\n      CollectionEventType.ADD,\n      this.handleFeatureAdd_.bind(this)\n    );\n    this.features_.addEventListener(\n      CollectionEventType.REMOVE,\n      this.handleFeatureRemove_.bind(this)\n    );\n\n    /**\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @private\n     */\n    this.lastPointerEvent_ = null;\n\n    /**\n     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.\n     * @type {Array<number>}\n     */\n    this.delta_ = [0, 0];\n\n    /**\n     * @private\n     */\n    this.snapToPointer_ =\n      options.snapToPointer === undefined\n        ? !this.hitDetection_\n        : options.snapToPointer;\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  addFeature_(feature) {\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (writer) {\n        writer(feature, geometry);\n      }\n    }\n    const map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n    feature.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.\n   * @private\n   */\n  willModifyFeatures_(evt, segments) {\n    if (!this.featuresBeingModified_) {\n      this.featuresBeingModified_ = new Collection();\n      const features = this.featuresBeingModified_.getArray();\n      for (let i = 0, ii = segments.length; i < ii; ++i) {\n        const segment = segments[i];\n        for (let s = 0, ss = segment.length; s < ss; ++s) {\n          const feature = segment[s].feature;\n          if (feature && !features.includes(feature)) {\n            this.featuresBeingModified_.push(feature);\n          }\n        }\n      }\n      if (this.featuresBeingModified_.getLength() === 0) {\n        this.featuresBeingModified_ = null;\n      } else {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYSTART,\n            this.featuresBeingModified_,\n            evt\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeature_(feature) {\n    this.removeFeatureSegmentData_(feature);\n    // Remove the vertex feature if the collection of candidate features is empty.\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    feature.removeEventListener(\n      EventType.CHANGE,\n      this.boundHandleFeatureChange_\n    );\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureSegmentData_(feature) {\n    const rBush = this.rBush_;\n    /** @type {Array<SegmentData>} */\n    const nodesToRemove = [];\n    rBush.forEach(\n      /**\n       * @param {SegmentData} node RTree node.\n       */\n      function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      }\n    );\n    for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n      const nodeToRemove = nodesToRemove[i];\n      for (let j = this.dragSegments_.length - 1; j >= 0; --j) {\n        if (this.dragSegments_[j][0] === nodeToRemove) {\n          this.dragSegments_.splice(j, 1);\n        }\n      }\n      rBush.remove(nodeToRemove);\n    }\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    super.setActive(active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.overlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders the modification point or vertex to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceAdd_(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceRemove_(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    this.addFeature_(evt.element);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    if (!this.changingFeature_) {\n      const feature = /** @type {Feature} */ (evt.target);\n      this.removeFeature_(feature);\n      this.addFeature_(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    this.removeFeature_(evt.element);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {Point} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n\n    /** @type {SegmentData} */\n    const segmentData = {\n      feature: feature,\n      geometry: geometry,\n      segment: [coordinates, coordinates],\n    };\n\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        depth: [i],\n        index: i,\n        segment: [coordinates, coordinates],\n      };\n\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n\n      /** @type {SegmentData} */\n      const segmentData = {\n        feature: feature,\n        geometry: geometry,\n        index: i,\n        segment: segment,\n      };\n\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n\n        /** @type {SegmentData} */\n        const segmentData = {\n          feature: feature,\n          geometry: geometry,\n          depth: [j],\n          index: i,\n          segment: segment,\n        };\n\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n\n          /** @type {SegmentData} */\n          const segmentData = {\n            feature: feature,\n            geometry: geometry,\n            depth: [j, k],\n            index: i,\n            segment: segment,\n          };\n\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * We convert a circle into two segments.  The segment at index\n   * {@link CIRCLE_CENTER_INDEX} is the\n   * circle's center (a point).  The segment at index\n   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is\n   * the circumference, and is not a line segment.\n   *\n   * @param {Feature} feature Feature.\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const coordinates = geometry.getCenter();\n\n    /** @type {SegmentData} */\n    const centerSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CENTER_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    /** @type {SegmentData} */\n    const circumferenceSegmentData = {\n      feature: feature,\n      geometry: geometry,\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates, coordinates],\n    };\n\n    const featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = featureSegments;\n    circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(createExtent(coordinates), centerSegmentData);\n    let circleGeometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection && this.getMap()) {\n      const projection = this.getMap().getView().getProjection();\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n      circleGeometry = fromCircle(\n        /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n      ).transform(projection, userProjection);\n    }\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i];\n      const writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      writer(feature, geometry);\n    }\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {Array<import(\"../Feature\").FeatureLike>} features The features being modified.\n   * @param {Array<import(\"../geom/SimpleGeometry.js\").default>} geometries The geometries being modified.\n   * @return {Feature} Vertex feature.\n   * @private\n   */\n  createOrUpdateVertexFeature_(coordinates, features, geometries) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(coordinates));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(coordinates);\n    }\n    vertexFeature.set('features', features);\n    vertexFeature.set('geometries', geometries);\n    return vertexFeature;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n\n    let handled;\n    if (\n      !mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (\n        mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK ||\n        !this.ignoreNextSingleClick_\n      ) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n\n    return super.handleEvent(mapBrowserEvent) && !handled;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   */\n  handleDragEvent(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(evt, this.dragSegments_);\n\n    const vertex = [\n      evt.coordinate[0] + this.delta_[0],\n      evt.coordinate[1] + this.delta_[1],\n    ];\n    const features = [];\n    const geometries = [];\n    for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n      const dragSegment = this.dragSegments_[i];\n      const segmentData = dragSegment[0];\n      const feature = segmentData.feature;\n      if (!features.includes(feature)) {\n        features.push(feature);\n      }\n      const geometry = segmentData.geometry;\n      if (!geometries.includes(geometry)) {\n        geometries.push(geometry);\n      }\n      const depth = segmentData.depth;\n      let coordinates;\n      const segment = segmentData.segment;\n      const index = dragSegment[1];\n\n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index][vertex.length]);\n      }\n\n      switch (geometry.getType()) {\n        case 'Point':\n          coordinates = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'MultiPoint':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index] = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case 'LineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiLineString':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Polygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'MultiPolygon':\n          coordinates = geometry.getCoordinates();\n          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n          segment[index] = vertex;\n          break;\n        case 'Circle':\n          segment[0] = vertex;\n          segment[1] = vertex;\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            geometry.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else {\n            // We're dragging the circle's circumference:\n            this.changingFeature_ = true;\n            const projection = evt.map.getView().getProjection();\n            let radius = coordinateDistance(\n              fromUserCoordinate(geometry.getCenter(), projection),\n              fromUserCoordinate(vertex, projection)\n            );\n            const userProjection = getUserProjection();\n            if (userProjection) {\n              const circleGeometry = geometry\n                .clone()\n                .transform(userProjection, projection);\n              circleGeometry.setRadius(radius);\n              radius = circleGeometry\n                .transform(projection, userProjection)\n                .getRadius();\n            }\n            geometry.setRadius(radius);\n            this.changingFeature_ = false;\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (coordinates) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    const pixelCoordinate = evt.coordinate;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\n    this.dragSegments_.length = 0;\n    this.featuresBeingModified_ = null;\n    const vertexFeature = this.vertexFeature_;\n    if (vertexFeature) {\n      const projection = evt.map.getView().getProjection();\n      const insertVertices = [];\n      const vertex = vertexFeature.getGeometry().getCoordinates();\n      const vertexExtent = boundingExtent([vertex]);\n      const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n      const componentSegments = {};\n      segmentDataMatches.sort(compareIndexes);\n      for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n        const segmentDataMatch = segmentDataMatches[i];\n        const segment = segmentDataMatch.segment;\n        let uid = getUid(segmentDataMatch.geometry);\n        const depth = segmentDataMatch.depth;\n        if (depth) {\n          uid += '-' + depth.join('-'); // separate feature components\n        }\n        if (!componentSegments[uid]) {\n          componentSegments[uid] = new Array(2);\n        }\n\n        if (\n          segmentDataMatch.geometry.getType() === 'Circle' &&\n          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          const closestVertex = closestOnSegmentData(\n            pixelCoordinate,\n            segmentDataMatch,\n            projection\n          );\n          if (\n            coordinatesEqual(closestVertex, vertex) &&\n            !componentSegments[uid][0]\n          ) {\n            this.dragSegments_.push([segmentDataMatch, 0]);\n            componentSegments[uid][0] = segmentDataMatch;\n          }\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[0], vertex) &&\n          !componentSegments[uid][0]\n        ) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          coordinatesEqual(segment[1], vertex) &&\n          !componentSegments[uid][1]\n        ) {\n          if (\n            componentSegments[uid][0] &&\n            componentSegments[uid][0].index === 0\n          ) {\n            let coordinates = segmentDataMatch.geometry.getCoordinates();\n            switch (segmentDataMatch.geometry.getType()) {\n              // prevent dragging closed linestrings by the connecting node\n              case 'LineString':\n              case 'MultiLineString':\n                continue;\n              // if dragging the first vertex of a polygon, ensure the other segment\n              // belongs to the closing vertex of the linear ring\n              case 'MultiPolygon':\n                coordinates = coordinates[depth[1]];\n              /* falls through */\n              case 'Polygon':\n                if (\n                  segmentDataMatch.index !==\n                  coordinates[depth[0]].length - 2\n                ) {\n                  continue;\n                }\n                break;\n              default:\n              // pass\n            }\n          }\n\n          this.dragSegments_.push([segmentDataMatch, 1]);\n          componentSegments[uid][1] = segmentDataMatch;\n          continue;\n        }\n\n        if (\n          getUid(segment) in this.vertexSegments_ &&\n          !componentSegments[uid][0] &&\n          !componentSegments[uid][1] &&\n          this.insertVertexCondition_(evt)\n        ) {\n          insertVertices.push(segmentDataMatch);\n        }\n      }\n\n      if (insertVertices.length) {\n        this.willModifyFeatures_(evt, [insertVertices]);\n      }\n\n      for (let j = insertVertices.length - 1; j >= 0; --j) {\n        this.insertVertex_(insertVertices[j], vertex);\n      }\n    }\n    return !!this.vertexFeature_;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n      const segmentData = this.dragSegments_[i][0];\n      const geometry = segmentData.geometry;\n      if (geometry.getType() === 'Circle') {\n        // Update a circle object in the R* bush:\n        const coordinates = geometry.getCenter();\n        const centerSegmentData = segmentData.featureSegments[0];\n        const circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = coordinates;\n        centerSegmentData.segment[1] = coordinates;\n        circumferenceSegmentData.segment[0] = coordinates;\n        circumferenceSegmentData.segment[1] = coordinates;\n        this.rBush_.update(createExtent(coordinates), centerSegmentData);\n        let circleGeometry = geometry;\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          const projection = evt.map.getView().getProjection();\n          circleGeometry = circleGeometry\n            .clone()\n            .transform(userProjection, projection);\n          circleGeometry = fromCircle(circleGeometry).transform(\n            projection,\n            userProjection\n          );\n        }\n        this.rBush_.update(\n          circleGeometry.getExtent(),\n          circumferenceSegmentData\n        );\n      } else {\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n      }\n    }\n    if (this.featuresBeingModified_) {\n      this.dispatchEvent(\n        new ModifyEvent(\n          ModifyEventType.MODIFYEND,\n          this.featuresBeingModified_,\n          evt\n        )\n      );\n      this.featuresBeingModified_ = null;\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @private\n   */\n  handlePointerMove_(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../Map.js\").default} map Map.\n   * @param {import(\"../coordinate.js\").Coordinate} [coordinate] The pixel Coordinate.\n   * @private\n   */\n  handlePointerAtPixel_(pixel, map, coordinate) {\n    const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);\n    const projection = map.getView().getProjection();\n    const sortByDistance = function (a, b) {\n      return (\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) -\n        projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection)\n      );\n    };\n\n    /** @type {Array<SegmentData>|undefined} */\n    let nodes;\n    let hitPointGeometry;\n    if (this.hitDetection_) {\n      const layerFilter =\n        typeof this.hitDetection_ === 'object'\n          ? (layer) => layer === this.hitDetection_\n          : undefined;\n      map.forEachFeatureAtPixel(\n        pixel,\n        (feature, layer, geometry) => {\n          geometry =\n            geometry ||\n            /** @type {import(\"../geom/SimpleGeometry\").default} */ (\n              feature.getGeometry()\n            );\n          if (\n            geometry.getType() === 'Point' &&\n            this.features_.getArray().includes(feature)\n          ) {\n            hitPointGeometry = geometry;\n            const coordinate = geometry.getFlatCoordinates().slice(0, 2);\n            nodes = [\n              {\n                feature,\n                geometry,\n                segment: [coordinate, coordinate],\n              },\n            ];\n          }\n          return true;\n        },\n        {layerFilter}\n      );\n    }\n    if (!nodes) {\n      const viewExtent = fromUserExtent(\n        createExtent(pixelCoordinate, tempExtent),\n        projection\n      );\n      const buffer = map.getView().getResolution() * this.pixelTolerance_;\n      const box = toUserExtent(\n        bufferExtent(viewExtent, buffer, tempExtent),\n        projection\n      );\n      nodes = this.rBush_.getInExtent(box);\n    }\n\n    if (nodes && nodes.length > 0) {\n      const node = nodes.sort(sortByDistance)[0];\n      const closestSegment = node.segment;\n      let vertex = closestOnSegmentData(pixelCoordinate, node, projection);\n      const vertexPixel = map.getPixelFromCoordinate(vertex);\n      let dist = coordinateDistance(pixel, vertexPixel);\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\n        /** @type {Object<string, boolean>} */\n        const vertexSegments = {};\n        vertexSegments[getUid(closestSegment)] = true;\n\n        if (!this.snapToPointer_) {\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\n        }\n        if (\n          node.geometry.getType() === 'Circle' &&\n          node.index === CIRCLE_CIRCUMFERENCE_INDEX\n        ) {\n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry]\n          );\n        } else {\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          if (this.snappedToVertex_) {\n            vertex =\n              squaredDist1 > squaredDist2\n                ? closestSegment[1]\n                : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(\n            vertex,\n            [node.feature],\n            [node.geometry]\n          );\n          const geometries = {};\n          geometries[getUid(node.geometry)] = true;\n          for (let i = 1, ii = nodes.length; i < ii; ++i) {\n            const segment = nodes[i].segment;\n            if (\n              (coordinatesEqual(closestSegment[0], segment[0]) &&\n                coordinatesEqual(closestSegment[1], segment[1])) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n                coordinatesEqual(closestSegment[1], segment[0]))\n            ) {\n              const geometryUid = getUid(nodes[i].geometry);\n              if (!(geometryUid in geometries)) {\n                geometries[geometryUid] = true;\n                vertexSegments[getUid(segment)] = true;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  }\n\n  /**\n   * @param {SegmentData} segmentData Segment data.\n   * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n   * @private\n   */\n  insertVertex_(segmentData, vertex) {\n    const segment = segmentData.segment;\n    const feature = segmentData.feature;\n    const geometry = segmentData.geometry;\n    const depth = segmentData.depth;\n    const index = segmentData.index;\n    let coordinates;\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n\n    switch (geometry.getType()) {\n      case 'MultiLineString':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'Polygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'MultiPolygon':\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n        break;\n      case 'LineString':\n        coordinates = geometry.getCoordinates();\n        coordinates.splice(index + 1, 0, vertex);\n        break;\n      default:\n        return;\n    }\n\n    this.setGeometryCoordinates_(geometry, coordinates);\n    const rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index, depth, 1);\n\n    /** @type {SegmentData} */\n    const newSegmentData = {\n      segment: [segment[0], vertex],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n\n    /** @type {SegmentData} */\n    const newSegmentData2 = {\n      segment: [vertex, segment[1]],\n      feature: feature,\n      geometry: geometry,\n      depth: depth,\n      index: index + 1,\n    };\n\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    this.ignoreNextSingleClick_ = true;\n  }\n\n  /**\n   * Removes the vertex currently being pointed.\n   * @return {boolean} True when a vertex was removed.\n   * @api\n   */\n  removePoint() {\n    if (\n      this.lastPointerEvent_ &&\n      this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG\n    ) {\n      const evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(evt, this.dragSegments_);\n      const removed = this.removeVertex_();\n      if (this.featuresBeingModified_) {\n        this.dispatchEvent(\n          new ModifyEvent(\n            ModifyEventType.MODIFYEND,\n            this.featuresBeingModified_,\n            evt\n          )\n        );\n      }\n\n      this.featuresBeingModified_ = null;\n      return removed;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a vertex from all matching features.\n   * @return {boolean} True when a vertex was removed.\n   * @private\n   */\n  removeVertex_() {\n    const dragSegments = this.dragSegments_;\n    const segmentsByFeature = {};\n    let deleted = false;\n    let component, coordinates, dragSegment, geometry, i, index, left;\n    let newIndex, right, segmentData, uid;\n    for (i = dragSegments.length - 1; i >= 0; --i) {\n      dragSegment = dragSegments[i];\n      segmentData = dragSegment[0];\n      uid = getUid(segmentData.feature);\n      if (segmentData.depth) {\n        // separate feature components\n        uid += '-' + segmentData.depth.join('-');\n      }\n      if (!(uid in segmentsByFeature)) {\n        segmentsByFeature[uid] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid].right = segmentData;\n        segmentsByFeature[uid].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid].left = segmentData;\n        segmentsByFeature[uid].index = segmentData.index + 1;\n      }\n    }\n    for (uid in segmentsByFeature) {\n      right = segmentsByFeature[uid].right;\n      left = segmentsByFeature[uid].left;\n      index = segmentsByFeature[uid].index;\n      newIndex = index - 1;\n      if (left !== undefined) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates = geometry.getCoordinates();\n      component = coordinates;\n      deleted = false;\n      switch (geometry.getType()) {\n        case 'MultiLineString':\n          if (coordinates[segmentData.depth[0]].length > 2) {\n            coordinates[segmentData.depth[0]].splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'LineString':\n          if (coordinates.length > 2) {\n            coordinates.splice(index, 1);\n            deleted = true;\n          }\n          break;\n        case 'MultiPolygon':\n          component = component[segmentData.depth[1]];\n        /* falls through */\n        case 'Polygon':\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index == component.length - 1) {\n              index = 0;\n            }\n            component.splice(index, 1);\n            deleted = true;\n            if (index === 0) {\n              // close the ring again\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n        default:\n        // pass\n      }\n\n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates);\n        const segments = [];\n        if (left !== undefined) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== undefined) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== undefined && right !== undefined) {\n          /** @type {SegmentData} */\n          const newSegmentData = {\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments,\n          };\n\n          this.rBush_.insert(\n            boundingExtent(newSegmentData.segment),\n            newSegmentData\n          );\n        }\n        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n    }\n    return deleted;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {Array} coordinates Coordinates.\n   * @private\n   */\n  setGeometryCoordinates_(geometry, coordinates) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates);\n    this.changingFeature_ = false;\n  }\n\n  /**\n   * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {number} index Index.\n   * @param {Array<number>|undefined} depth Depth.\n   * @param {number} delta Delta (1 or -1).\n   * @private\n   */\n  updateSegmentIndices_(geometry, index, depth, delta) {\n    this.rBush_.forEachInExtent(\n      geometry.getExtent(),\n      function (segmentDataMatch) {\n        if (\n          segmentDataMatch.geometry === geometry &&\n          (depth === undefined ||\n            segmentDataMatch.depth === undefined ||\n            equals(segmentDataMatch.depth, depth)) &&\n          segmentDataMatch.index > index\n        ) {\n          segmentDataMatch.index += delta;\n        }\n      }\n    );\n  }\n}\n\n/**\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {SegmentData} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction projectedDistanceToSegmentDataSquared(\n  pointCoordinates,\n  segmentData,\n  projection\n) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === 'Circle') {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n          circleGeometry.clone().transform(userProjection, projection)\n        );\n      }\n      const distanceToCenterSquared = squaredCoordinateDistance(\n        circleGeometry.getCenter(),\n        fromUserCoordinate(pointCoordinates, projection)\n      );\n      const distanceToCircumference =\n        Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return squaredDistanceToSegment(coordinate, tempSegment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {import(\"../coordinate.js\").Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {SegmentData} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n * @return {import(\"../coordinate.js\").Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\n  const geometry = segmentData.geometry;\n\n  if (\n    geometry.getType() === 'Circle' &&\n    segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX\n  ) {\n    let circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n      geometry\n    );\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    return toUserCoordinate(\n      circleGeometry.getClosestPoint(\n        fromUserCoordinate(pointCoordinates, projection)\n      ),\n      projection\n    );\n  }\n  const coordinate = fromUserCoordinate(pointCoordinates, projection);\n  tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n  tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n  return toUserCoordinate(\n    closestOnSegment(coordinate, tempSegment),\n    projection\n  );\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\nexport default Modify;\n","/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @this {Select}\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        function (feature, layer) {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        }.bind(this),\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        function (feature, layer) {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        }.bind(this),\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent\n        )\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","/**\n * @module ol/interaction/Translate\n */\nimport Collection from '../Collection.js';\nimport Event from '../events/Event.js';\nimport InteractionProperty from './Property.js';\nimport PointerInteraction from './Pointer.js';\nimport {TRUE} from '../functions.js';\nimport {always} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst TranslateEventType = {\n  /**\n   * Triggered upon feature translation start.\n   * @event TranslateEvent#translatestart\n   * @api\n   */\n  TRANSLATESTART: 'translatestart',\n  /**\n   * Triggered upon feature translation.\n   * @event TranslateEvent#translating\n   * @api\n   */\n  TRANSLATING: 'translating',\n  /**\n   * Triggered upon feature translation end.\n   * @event TranslateEvent#translateend\n   * @api\n   */\n  TRANSLATEEND: 'translateend',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} or\n * {@link module:ol/render/Feature~RenderFeature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {Collection<import(\"../Feature.js\").default>} [features] Features contained in this collection will be able to be translated together.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers] A list of layers from which features should be\n * translated. Alternatively, a filter function can be provided. The\n * function will be called for each layer in the map and should return\n * `true` for layers that you want to be translatable. If the option is\n * absent, all visible layers will be considered translatable.\n * Not used if `features` is provided.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * translated or `false` otherwise. Not used if `features` is provided.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position\n * will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Translate~Translate} instances\n * are instances of this type.\n */\nexport class TranslateEvent extends Event {\n  /**\n   * @param {TranslateEventType} type Type.\n   * @param {Collection<import(\"../Feature.js\").default>} features The features translated.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} startCoordinate The original coordinates before.translation started\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   */\n  constructor(type, features, coordinate, startCoordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The features being translated.\n     * @type {Collection<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.features = features;\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * The coordinate of the start position before translation started.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.startCoordinate = startCoordinate;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for translating (moving) features.\n * If you want to translate multiple features in a single action (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.\n *\n * @fires TranslateEvent\n * @api\n */\nclass Translate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TranslateOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TranslateOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * The last position we translated to.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = null;\n\n    /**\n     * The start position before translation started.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.startCoordinate_ = null;\n\n    /**\n     * @type {Collection<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features !== undefined ? options.features : null;\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers && !this.features_) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter && !this.features_ ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * @type {import(\"../Feature.js\").default}\n     * @private\n     */\n    this.lastFeature_ = null;\n\n    this.addChangeListener(\n      InteractionProperty.ACTIVE,\n      this.handleActiveChanged_\n    );\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    if (!event.originalEvent || !this.condition_(event)) {\n      return false;\n    }\n    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);\n    if (!this.lastCoordinate_ && this.lastFeature_) {\n      this.startCoordinate_ = event.coordinate;\n      this.lastCoordinate_ = event.coordinate;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATESTART,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    if (this.lastCoordinate_) {\n      this.lastCoordinate_ = null;\n      this.handleMoveEvent(event);\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATEEND,\n          features,\n          event.coordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n      // cleanup\n      this.startCoordinate_ = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleDragEvent(event) {\n    if (this.lastCoordinate_) {\n      const newCoordinate = event.coordinate;\n      const deltaX = newCoordinate[0] - this.lastCoordinate_[0];\n      const deltaY = newCoordinate[1] - this.lastCoordinate_[1];\n\n      const features = this.features_ || new Collection([this.lastFeature_]);\n\n      features.forEach(function (feature) {\n        const geom = feature.getGeometry();\n        geom.translate(deltaX, deltaY);\n        feature.setGeometry(geom);\n      });\n\n      this.lastCoordinate_ = newCoordinate;\n\n      this.dispatchEvent(\n        new TranslateEvent(\n          TranslateEventType.TRANSLATING,\n          features,\n          newCoordinate,\n          this.startCoordinate_,\n          event\n        )\n      );\n    }\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  handleMoveEvent(event) {\n    const elem = event.map.getViewport();\n\n    // Change the cursor to grab/grabbing if hovering any of the features managed\n    // by the interaction\n    if (this.featuresAtPixel_(event.pixel, event.map)) {\n      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');\n      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');\n    } else {\n      elem.classList.remove('ol-grab', 'ol-grabbing');\n    }\n  }\n\n  /**\n   * Tests to see if the given coordinates intersects any of our selected\n   * features.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel coordinate to test for intersection.\n   * @param {import(\"../Map.js\").default} map Map to test the intersection on.\n   * @return {import(\"../Feature.js\").default} Returns the feature found at the specified pixel\n   * coordinates.\n   * @private\n   */\n  featuresAtPixel_(pixel, map) {\n    return map.forEachFeatureAtPixel(\n      pixel,\n      function (feature, layer) {\n        if (this.filter_(feature, layer)) {\n          if (!this.features_ || this.features_.getArray().includes(feature)) {\n            return feature;\n          }\n        }\n      }.bind(this),\n      {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_,\n      }\n    );\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    super.setMap(map);\n    this.updateState_(oldMap);\n  }\n\n  /**\n   * @private\n   */\n  handleActiveChanged_() {\n    this.updateState_(null);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default} oldMap Old map.\n   * @private\n   */\n  updateState_(oldMap) {\n    let map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      map = map || oldMap;\n      if (map) {\n        const elem = map.getViewport();\n        elem.classList.remove('ol-grab', 'ol-grabbing');\n      }\n    }\n  }\n}\n\nexport default Translate;\n"],"names":["tempExtent","tempSegment","ModifyEventType","ModifyEvent","type","features","mapBrowserEvent","Event","Modify","options","on","once","un","boundHandleFeatureChange_","handleFeatureChange_","bind","condition_","condition","primaryAction","defaultDeleteCondition_","altKeyOnly","singleClick","deleteCondition_","deleteCondition","insertVertexCondition_","insertVertexCondition","always","vertexFeature_","vertexSegments_","lastPixel_","ignoreNextSingleClick_","featuresBeingModified_","rBush_","RBush","pixelTolerance_","undefined","pixelTolerance","snappedToVertex_","changingFeature_","dragSegments_","overlay_","VectorLayer","source","VectorSource","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileAnimating","updateWhileInteracting","SEGMENT_WRITERS_","writePointGeometry_","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeCircleGeometry_","writeGeometryCollectionGeometry_","source_","hitDetection_","Collection","getFeatures","addEventListener","VectorEventType","handleSourceAdd_","handleSourceRemove_","Error","hitDetection","features_","forEach","addFeature_","CollectionEventType","handleFeatureAdd_","handleFeatureRemove_","lastPointerEvent_","delta_","snapToPointer_","snapToPointer","feature","geometry","getGeometry","writer","this","getType","map","getMap","isRendered","getActive","handlePointerAtPixel_","EventType","evt","segments","getArray","i","ii","length","segment","s","ss","includes","push","getLength","dispatchEvent","removeFeatureSegmentData_","getSource","removeFeature","removeEventListener","rBush","nodesToRemove","node","nodeToRemove","j","splice","remove","active","setMap","event","element","target","removeFeature_","coordinates","getCoordinates","segmentData","insert","getExtent","points","depth","index","slice","boundingExtent","lines","jj","rings","polygons","k","kk","getCenter","centerSegmentData","circumferenceSegmentData","featureSegments","createExtent","circleGeometry","userProjection","getUserProjection","projection","getView","getProjection","clone","transform","fromCircle","geometries","getGeometriesArray","vertexFeature","setCoordinates","Feature","Point","addFeature","set","originalEvent","getInteracting","MapBrowserEventType","handlingDownUpSequence","handlePointerMove_","handled","removePoint","willModifyFeatures_","vertex","coordinate","dragSegment","getStride","setCenter","radius","coordinateDistance","fromUserCoordinate","setRadius","getRadius","setGeometryCoordinates_","createOrUpdateVertexFeature_","pixelCoordinate","pixel","insertVertices","vertexExtent","segmentDataMatches","getInExtent","componentSegments","sort","compareIndexes","segmentDataMatch","uid","getUid","join","Array","coordinatesEqual","closestVertex","closestOnSegmentData","insertVertex_","update","nodes","hitPointGeometry","getCoordinateFromPixel","layerFilter","layer","forEachFeatureAtPixel","getFlatCoordinates","viewExtent","fromUserExtent","buffer","getResolution","box","toUserExtent","bufferExtent","a","b","projectedDistanceToSegmentDataSquared","closestSegment","vertexPixel","getPixelFromCoordinate","dist","vertexSegments","pixel1","pixel2","squaredDist1","squaredCoordinateDistance","squaredDist2","Math","sqrt","min","geometryUid","rTree","updateSegmentIndices_","newSegmentData","newSegmentData2","removed","removeVertex_","component","left","newIndex","right","dragSegments","segmentsByFeature","deleted","pop","delta","forEachInExtent","equals","PointerInteraction","pointCoordinates","distanceToCenterSquared","distanceToCircumference","squaredDistanceToSegment","toUserCoordinate","getClosestPoint","closestOnSegment","createEditingStyle","resolution","SelectEventType","SelectEvent","selected","deselected","originalFeatureStyles","Select","boundAddFeature_","boundRemoveFeature_","addCondition_","addCondition","never","removeCondition_","removeCondition","toggleCondition_","toggleCondition","shiftKeyOnly","multi_","multi","filter_","filter","TRUE","hitTolerance_","hitTolerance","style_","styles","extend","layers","layerFilter_","featureLayerAssociation_","restorePreviousStyle_","applySelectedStyle_","getLayer","getAllLayers","find","hasFeature","addFeatureLayerAssociation_","key","getStyle","setStyle","interactions","getInteractions","interaction","lastIndexOf","add","toggle","clear","item","indexOf","removeFeatureLayerAssociation_","Interaction","TranslateEventType","TranslateEvent","startCoordinate","Translate","lastCoordinate_","startCoordinate_","lastFeature_","addChangeListener","InteractionProperty","handleActiveChanged_","featuresAtPixel_","handleMoveEvent","newCoordinate","deltaX","deltaY","geom","translate","setGeometry","elem","getViewport","classList","oldMap","updateState_"],"sourceRoot":""}