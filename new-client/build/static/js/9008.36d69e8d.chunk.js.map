{"version":3,"file":"static/js/9008.36d69e8d.chunk.js","mappings":"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","sources":["plugins/LayerSwitcher/LayerSwitcherView.js","plugins/LayerSwitcher/components/BackgroundSwitcher.js","plugins/LayerSwitcher/components/BreadCrumb.js","plugins/LayerSwitcher/components/BreadCrumbs.js"],"sourcesContent":["import React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport propTypes from \"prop-types\";\n\nimport { styled } from \"@mui/material/styles\";\nimport { AppBar, Tab, Tabs } from \"@mui/material\";\n\nimport BackgroundSwitcher from \"./components/BackgroundSwitcher.js\";\nimport LayerGroup from \"./components/LayerGroup.js\";\nimport BreadCrumbs from \"./components/BreadCrumbs.js\";\nimport DrawOrder from \"./components/DrawOrder.js\";\n\n// The styled-component below might seem unnecessary since we are using the sx-prop\n// on it as well. However, since we cannot use the sx-prop on a non-MUI-component\n// (which would force us to change the <div> to a <Box>) this felt OK in this\n// particular occasion.\nconst Root = styled(\"div\")(() => ({\n  margin: -10, // special case, we need to \"unset\" the padding for Window content that's set in Window.js\n}));\n\nconst StyledAppBar = styled(AppBar)(() => ({\n  top: -10,\n}));\n\nconst ContentWrapper = styled(\"div\")(() => ({\n  padding: 10,\n}));\n\nclass LayersSwitcherView extends React.PureComponent {\n  static propTypes = {\n    app: propTypes.object.isRequired,\n    map: propTypes.object.isRequired,\n    model: propTypes.object.isRequired,\n    observer: propTypes.object.isRequired,\n    options: propTypes.object.isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n    this.options = props.options;\n    this.state = {\n      chapters: [],\n      baseLayers: props.model.getBaseLayers(),\n      activeTab: 0,\n    };\n\n    props.app.globalObserver.subscribe(\"informativeLoaded\", (chapters) => {\n      if (Array.isArray(chapters)) {\n        this.setState({\n          chapters: chapters,\n        });\n      }\n    });\n  }\n\n  /**\n   * LayerSwitcher consists of two Tabs: one shows\n   * \"regular\" layers (as checkboxes, multi select), and the\n   * other shows background layers (as radio buttons, one-at-at-time).\n   *\n   * This method controls which of the two Tabs is visible.\n   *\n   * @memberof LayersSwitcherView\n   */\n  handleChangeTabs = (event, activeTab) => {\n    this.setState({ activeTab });\n  };\n\n  /**\n   * @summary Ensure that the selected Tab's indicator has correct width.\n   * @description When Tabs are mounted, the indicator (below selected button)\n   * can have incorrect width (based on calculations done prior complete render).\n   * This function is called once, on mount of <Tabs> and ensures that the\n   * indicator gets correct width.\n   *\n   * @memberof LayersSwitcherView\n   */\n  handleTabsMounted = (ref) => {\n    // Not beautiful but it works - timeout is needed to ensure rendering is done\n    // and parent's element are correct.\n    setTimeout(() => {\n      ref !== null && ref.updateIndicator();\n    }, 1);\n  };\n\n  /**\n   * @summary Loops through map configuration and\n   * renders all groups. Visible only if @param shouldRender is true.\n   *\n   * @param {boolean} [shouldRender=true]\n   * @returns {<div>}\n   */\n  renderLayerGroups = (shouldRender = true) => {\n    return (\n      <div\n        style={{\n          display: shouldRender === true ? \"block\" : \"none\",\n        }}\n      >\n        {this.options.groups.map((group, i) => {\n          return (\n            <LayerGroup\n              key={i}\n              group={group}\n              model={this.props.model}\n              chapters={this.state.chapters}\n              app={this.props.app}\n              options={this.props.options}\n            />\n          );\n        })}\n      </div>\n    );\n  };\n\n  /**\n   * BreadCrumbs are a feature used to \"link\" content between LayerSwitcher\n   * and Informative plugins. They get rendered directly to #map, as they\n   * are not part of LayerSwitcher plugin, at least not visually. To achieve\n   * that we use createPortal().\n   *\n   * @returns\n   * @memberof LayersSwitcherView\n   */\n  renderBreadCrumbs = () => {\n    return (\n      this.options.showBreadcrumbs &&\n      createPortal(\n        // We must wrap the component in a div, on which we can catch\n        // events. This is done to prevent event bubbling to the\n        // layerSwitcher component.\n        <div onMouseDown={(e) => e.stopPropagation()}>\n          <BreadCrumbs\n            map={this.props.map}\n            model={this.props.model}\n            app={this.props.app}\n          />\n        </div>,\n        document.getElementById(\"breadcrumbs-container\")\n      )\n    );\n  };\n\n  render() {\n    const { windowVisible } = this.props;\n    return (\n      <Root sx={{ display: windowVisible ? \"block\" : \"none\" }}>\n        <StyledAppBar\n          position=\"sticky\" // Does not work in IE11\n          color=\"default\"\n        >\n          <Tabs\n            action={this.handleTabsMounted}\n            onChange={this.handleChangeTabs}\n            value={windowVisible ? this.state.activeTab : false} // If the window is not visible,\n            // we cannot send a proper value to the tabs-component. If we do, mui will throw an error.\n            // false is OK though, apparently.\n            variant=\"fullWidth\"\n            textColor=\"inherit\"\n          >\n            <Tab label=\"Kartlager\" />\n            <Tab label=\"Bakgrund\" />\n            {this.options.showActiveLayersView === true && (\n              <Tab label=\"Aktiva lager\" />\n            )}\n          </Tabs>\n        </StyledAppBar>\n        <ContentWrapper>\n          {this.renderLayerGroups(this.state.activeTab === 0)}\n          <BackgroundSwitcher\n            display={this.state.activeTab === 1}\n            layers={this.state.baseLayers}\n            layerMap={this.props.model.layerMap}\n            backgroundSwitcherBlack={this.options.backgroundSwitcherBlack}\n            backgroundSwitcherWhite={this.options.backgroundSwitcherWhite}\n            enableOSM={this.options.enableOSM}\n            map={this.props.map}\n            app={this.props.app}\n          />\n          {this.options.showActiveLayersView === true &&\n            this.state.activeTab === 2 && (\n              <DrawOrder map={this.props.map} app={this.props.app} />\n            )}\n        </ContentWrapper>\n        {this.renderBreadCrumbs()}\n      </Root>\n    );\n  }\n}\n\nexport default LayersSwitcherView;\n","import React from \"react\";\nimport propTypes from \"prop-types\";\nimport { isValidLayerId } from \"utils/Validator\";\nimport OSM from \"ol/source/OSM\";\nimport TileLayer from \"ol/layer/Tile\";\nimport LayerItem from \"./LayerItem.js\";\nimport Observer from \"react-event-observer\";\nimport Box from \"@mui/material/Box\";\n\nconst WHITE_BACKROUND_LAYER_ID = \"-1\";\nconst BLACK_BACKROUND_LAYER_ID = \"-2\";\nconst OSM_BACKGROUND_LAYER_ID = \"-3\";\n\nconst SPECIAL_BACKGROUND_COLORS = {\n  [WHITE_BACKROUND_LAYER_ID]: \"#fff\",\n  [BLACK_BACKROUND_LAYER_ID]: \"#000\",\n};\n\nclass BackgroundSwitcher extends React.PureComponent {\n  state = {\n    selectedLayerId: null,\n  };\n\n  static propTypes = {\n    backgroundSwitcherBlack: propTypes.bool.isRequired,\n    backgroundSwitcherWhite: propTypes.bool.isRequired,\n    enableOSM: propTypes.bool.isRequired,\n    display: propTypes.bool.isRequired,\n    layerMap: propTypes.object.isRequired,\n    layers: propTypes.array.isRequired,\n  };\n  constructor(props) {\n    super(props);\n    this.localObserver = Observer();\n    if (props.enableOSM) {\n      this.osmSource = new OSM({\n        reprojectionErrorThreshold: 5,\n      });\n      this.osmLayer = new TileLayer({\n        visible: false,\n        source: this.osmSource,\n        zIndex: -1,\n        layerType: \"base\",\n        name: \"osm-layer\",\n        caption: \"OpenStreetMap\",\n        layerInfo: {\n          caption: \"OpenStreetMap\",\n          layerType: \"base\",\n        },\n      });\n    }\n  }\n\n  /**\n   * @summary If there's a Background layer that is visible from start, make sure that proper radio button is selected in Background Switcher.\n   * @memberof BackgroundSwitcher\n   */\n  componentDidMount() {\n    const backgroundVisibleFromStart = this.props.layers.find(\n      (layer) => layer.visible\n    );\n    backgroundVisibleFromStart &&\n      this.setState({\n        selectedLayerId: backgroundVisibleFromStart.name,\n      });\n\n    if (this.props.enableOSM) {\n      // Initiate our special case layer, OpenStreetMap\n      this.props.map.addLayer(this.osmLayer);\n    }\n\n    // Ensure that BackgroundSwitcher correctly selects visible layer,\n    // by listening to a event that each layer will send when its visibility\n    // changes.\n    this.props.app.globalObserver.subscribe(\n      \"core.layerVisibilityChanged\",\n      ({ target: layer }) => {\n        const name = layer.get(\"name\");\n\n        // Early return if layer who's visibility was changed couldn't\n        // be found among the background layers, or if the visibility\n        // was changed to 'false'.\n        if (\n          this.props.layers.findIndex((l) => name === l.name) === -1 ||\n          layer.get(\"visible\") === false\n        ) {\n          return;\n        }\n\n        // If we got this far, we have a background layer that just\n        // became visible. Let's notify the radio buttons by setting state!\n        this.setState({\n          selectedLayerId: layer.get(\"name\"),\n        });\n      }\n    );\n  }\n\n  isSpecialBackgroundLayer = (id) => {\n    return [\n      WHITE_BACKROUND_LAYER_ID,\n      BLACK_BACKROUND_LAYER_ID,\n      OSM_BACKGROUND_LAYER_ID,\n    ].includes(id);\n  };\n\n  setSpecialBackground = (id) => {\n    document.getElementById(\"map\").style.backgroundColor =\n      SPECIAL_BACKGROUND_COLORS[id];\n  };\n\n  /**\n   * @summary Hides previously selected background and shows current selection.\n   * @param {Object} e The event object, contains target's value\n   */\n  onChange = (e) => {\n    const newSelectedId = e.target.value;\n    const { selectedLayerId } = this.state;\n    const { layerMap } = this.props;\n\n    this.isSpecialBackgroundLayer(newSelectedId)\n      ? this.setSpecialBackground(newSelectedId)\n      : layerMap[newSelectedId].setVisible(true);\n\n    !this.isSpecialBackgroundLayer(selectedLayerId) &&\n      layerMap[selectedLayerId].setVisible(false);\n    this.osmLayer &&\n      this.osmLayer.setVisible(newSelectedId === OSM_BACKGROUND_LAYER_ID);\n\n    this.setState({\n      selectedLayerId: newSelectedId,\n    });\n  };\n\n  /**\n   * @summary Returns a <div> that contains a {React.Component} consisting of one Radio button.\n   *\n   * @param {Object} config Base layer to be rendered\n   * @param {Number} index Unique key\n   * @returns {React.Component}\n   * @memberof BackgroundSwitcher\n   */\n  renderRadioButton(config, index) {\n    const checked = this.state.selectedLayerId === config.name;\n\n    // mapLayer will be sent to the LayerItem component. It will contain\n    // the Hajk layer with all properties.\n    let mapLayer = this.props.layerMap[config.name];\n\n    // There's a special case for the OpenStreetMap layer. It does not exist\n    // in Hajk's layers repository, but has been created here, as a property\n    // of 'this'. Let's set mapLayer accordingly.\n    if (config.name === OSM_BACKGROUND_LAYER_ID) {\n      mapLayer = this.osmLayer;\n      mapLayer.set(\"foo\", \"bar\");\n      // mapLayer.set(\"layerInfo\", { layerType: \"base\" });\n    }\n\n    // If we still don't have any mapLayer it means it's neither existing in\n    // Hajks layers repository, nor the OSM layer. (This will be the case for our\n    // black and white background colors.) In this case, let's prepare a fake\n    // 'mapLayer' that contains the necessary properties, so we can use the same\n    // logic further on.\n    if (!mapLayer) {\n      // Add some values so the code does not crash in LayerItem's constructor\n      mapLayer = {\n        isFakeMapLayer: true,\n        properties: {\n          name: config.name,\n          visible: checked,\n          layerInfo: {\n            caption: config.caption,\n            name: config.name,\n            layerType: \"base\",\n          },\n          opacity: 1, // Only full opacity available for black/white backgrounds\n        },\n        get(key) {\n          return this.properties[key];\n        },\n        set(key, value) {\n          this.properties[key] = value;\n        },\n        getProperties() {\n          return Object.keys(this.properties);\n        },\n      };\n    }\n\n    // No matter the type of 'mapLayer', we want to append these\n    // properties:\n    mapLayer[\"localObserver\"] = this.localObserver;\n\n    // Finally, let's render the component\n    return (\n      <LayerItem\n        key={index}\n        layer={mapLayer}\n        model={this.props.model}\n        options={this.props.options}\n        app={this.props.app}\n      />\n    );\n  }\n\n  /**\n   * Prepares an array of radio buttons with the configured base layers.\n   *\n   * @returns {React.Component[]} radioButtons Array of ready to use DOM components of Radio buttons\n   * @memberof BackgroundSwitcher\n   */\n  renderBaseLayerComponents() {\n    const { backgroundSwitcherWhite, backgroundSwitcherBlack, enableOSM } =\n      this.props;\n    let radioButtons = [],\n      defaults = [];\n\n    /**\n     * If admin wants to display white/black options for background, let's\n     * call renderRadioButton() for those two special cases. The resulting\n     * Component will be pushed into an array called @param defaults.\n     */\n    if (backgroundSwitcherWhite) {\n      defaults.push(\n        this.renderRadioButton(\n          {\n            name: WHITE_BACKROUND_LAYER_ID,\n            caption: \"Vit\",\n          },\n          Number(WHITE_BACKROUND_LAYER_ID)\n        )\n      );\n    }\n    if (backgroundSwitcherBlack) {\n      defaults.push(\n        this.renderRadioButton(\n          {\n            name: BLACK_BACKROUND_LAYER_ID,\n            caption: \"Svart\",\n          },\n          Number(BLACK_BACKROUND_LAYER_ID)\n        )\n      );\n    }\n\n    enableOSM &&\n      defaults.push(\n        this.renderRadioButton(\n          { name: OSM_BACKGROUND_LAYER_ID, caption: \"OpenStreetMap\" },\n          Number(OSM_BACKGROUND_LAYER_ID)\n        )\n      );\n\n    /**\n     * Let's construct the final array of radio buttons. It will consists\n     * of the defaults from above, plus the result of calling renderRadioButton()\n     * for each base layer.\n     */\n    radioButtons = [\n      ...defaults,\n      ...this.props.layers\n        .filter((layer) => {\n          //Remove layers not having a valid id\n          const validLayerId = isValidLayerId(layer.name);\n          if (!validLayerId) {\n            console.warn(\n              `Backgroundlayer with id ${layer.name} has a non-valid id`\n            );\n          }\n          return validLayerId;\n        })\n        .map((layerConfig, i) => this.renderRadioButton(layerConfig, i)),\n    ];\n\n    return radioButtons;\n  }\n\n  render() {\n    return (\n      <Box sx={{ display: this.props.display ? \"block\" : \"none\" }}>\n        {this.renderBaseLayerComponents()}\n      </Box>\n    );\n  }\n}\n\nexport default BackgroundSwitcher;\n","import React, { Component } from \"react\";\nimport CloseIcon from \"@mui/icons-material/Close\";\nimport VisibilityIcon from \"@mui/icons-material/Visibility\";\nimport VisibilityOffIcon from \"@mui/icons-material/VisibilityOff\";\nimport LaunchIcon from \"@mui/icons-material/Launch\";\nimport { Button, IconButton, Grid, Typography, Paper } from \"@mui/material\";\nimport CallMadeIcon from \"@mui/icons-material/CallMade\";\nimport { styled } from \"@mui/material/styles\";\nimport Popover from \"@mui/material/Popover\";\n\nconst StyledPaper = styled(Paper)(({ theme }) => ({\n  marginRight: theme.spacing(0.5),\n  border: `${theme.spacing(0.1)} solid ${theme.palette.divider}`,\n}));\n\nconst ContentGridContainer = styled(Grid)(({ theme }) => ({\n  padding: theme.spacing(1),\n}));\n\nconst TitleGridContainer = styled(Grid)(({ theme }) => ({\n  paddingLeft: theme.spacing(0.5),\n}));\n\nconst LinkContainer = styled(\"div\")(({ theme }) => ({\n  padding: theme.spacing(0.5),\n}));\n\nclass BreadCrumb extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hidden: props.layer.getOpacity() === 0,\n      anchorEl: null,\n      popoverOpen: false,\n    };\n    this.chapters = this.findChapters(\n      this.props.layer.get(\"name\"),\n      this.props.chapters\n    );\n  }\n\n  setHidden = (e) => {\n    var o = e.target.getOpacity();\n    this.setState({\n      hidden: o === 0,\n    });\n  };\n\n  componentDidMount() {\n    this.props.layer.on(\"change:opacity\", this.setHidden);\n  }\n\n  componentWillUnmount() {\n    this.props.layer.un(\"change:opacity\", this.setHidden);\n  }\n\n  setLayerOpacity = (layer) => (event) => {\n    this.setState(\n      {\n        hidden: !this.state.hidden,\n      },\n      () => {\n        layer.setOpacity(this.state.hidden ? 0 : 1);\n      }\n    );\n  };\n\n  setLayerVisibility = (layer) => (event) => {\n    if (layer.get(\"visible\")) {\n      layer.setOpacity(1);\n      this.props.app.globalObserver.publish(\"layerswitcher.hideLayer\", layer);\n    }\n    layer.set(\"visible\", !layer.get(\"visible\"));\n  };\n\n  isOverflow(el) {\n    if (!el) return false;\n    let original = el.scrollLeft++;\n    let overflow = el.scrollLeft-- > original;\n    return overflow;\n  }\n\n  findChapters(id, chapters) {\n    if (!chapters) {\n      return [];\n    }\n    return chapters.reduce((chaptersWithLayer, chapter) => {\n      if (Array.isArray(chapter.layers)) {\n        if (chapter.layers.some((layerId) => layerId === id)) {\n          chaptersWithLayer = [...chaptersWithLayer, chapter];\n        }\n        if (chapter.chapters.length > 0) {\n          chaptersWithLayer = [\n            ...chaptersWithLayer,\n            ...this.findChapters(id, chapter.chapters),\n          ];\n        }\n      }\n      return chaptersWithLayer;\n    }, []);\n  }\n\n  renderChapterLinks() {\n    if (this.chapters && this.chapters.length > 0) {\n      if (this.chapters.length > 0) {\n        return (\n          <LinkContainer>\n            {this.chapters.map((chapter, i) => {\n              return (\n                <div key={i}>\n                  <Button\n                    size=\"small\"\n                    onClick={() => {\n                      this.setState({\n                        popoverOpen: false,\n                      });\n                      this.openInformative(chapter);\n                    }}\n                  >\n                    {chapter.header}\n                    <CallMadeIcon />\n                  </Button>\n                </div>\n              );\n            })}\n          </LinkContainer>\n        );\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  openInformative = (chapter) => {\n    const informativeWindow = this.props.app.windows.find(\n      (window) => window.type === \"informative\"\n    );\n    informativeWindow.props.custom.open(chapter);\n  };\n\n  handleClose = () => {\n    this.setState({\n      anchorEl: null,\n      popoverOpen: false,\n    });\n  };\n\n  renderChaptersPopover(target) {\n    this.setState({\n      anchorEl: target,\n      popoverOpen: true,\n    });\n  }\n\n  renderInformativeIcon() {\n    if (!this.props.chapters) {\n      return null;\n    }\n    if (this.chapters && this.chapters.length > 0) {\n      return (\n        <IconButton\n          size=\"small\"\n          onClick={(e) => {\n            this.chapters.length === 1\n              ? this.openInformative(this.chapters[0])\n              : this.renderChaptersPopover(e.target);\n          }}\n        >\n          <LaunchIcon />\n        </IconButton>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  render() {\n    const { layer, title, type } = this.props;\n    const { hidden } = this.state;\n    return (\n      <StyledPaper square={type === \"flat\"} elevation={0}>\n        <ContentGridContainer\n          container\n          data-type=\"bread-crumb\"\n          justifyContent=\"space-between\"\n          alignItems=\"center\"\n        >\n          <Grid item>\n            <IconButton\n              size=\"small\"\n              onClick={this.setLayerOpacity(layer)}\n              aria-label=\"Visa/dölj lagret tillfälligt\"\n            >\n              {!hidden ? <VisibilityIcon /> : <VisibilityOffIcon />}\n            </IconButton>\n          </Grid>\n          {this.renderInformativeIcon()}\n          <TitleGridContainer item>\n            <Typography variant=\"body2\" noWrap>\n              {title}\n            </Typography>\n          </TitleGridContainer>\n          <Grid item>\n            <IconButton\n              size=\"small\"\n              onClick={this.setLayerVisibility(layer)}\n              aria-label=\"Ta bort lagret från kartan\"\n            >\n              <CloseIcon />\n            </IconButton>\n          </Grid>\n        </ContentGridContainer>\n        <Popover\n          id=\"simple-popper\"\n          open={this.state.popoverOpen}\n          anchorEl={this.state.anchorEl}\n          onClose={this.handleClose}\n          anchorOrigin={{\n            vertical: \"top\",\n            horizontal: \"center\",\n          }}\n          transformOrigin={{\n            vertical: \"bottom\",\n            horizontal: \"center\",\n          }}\n        >\n          {this.renderChapterLinks()}\n        </Popover>\n      </StyledPaper>\n    );\n  }\n}\n\nexport default BreadCrumb;\n","import React, { Component } from \"react\";\nimport BreadCrumb from \"./BreadCrumb.js\";\nimport { styled } from \"@mui/material/styles\";\nimport { useTheme } from \"@mui/material\";\nimport { useMediaQuery } from \"@mui/material\";\nimport Grid from \"@mui/material/Grid\";\nimport Divider from \"@mui/material/Divider\";\nimport Typography from \"@mui/material/Typography\";\nimport Button from \"@mui/material/Button\";\nimport IconButton from \"@mui/material/IconButton\";\nimport AddCircleIcon from \"@mui/icons-material/AddCircle\";\nimport RemoveCircleIcon from \"@mui/icons-material/RemoveCircle\";\nimport VisibilityOffIcon from \"@mui/icons-material/VisibilityOff\";\nimport ScrollMenu from \"react-horizontal-scrolling-menu\";\n\n// A HOC that pipes isMobile to the children. See this as a proposed\n// solution. It is not pretty, but if we move this to a separate file\n// we could use this HOC instead of the isMobile helper function in ../../utils/.\n// TODO: Move to some /hooks folder\nconst withIsMobile = () => (WrappedComponent) => (props) => {\n  const theme = useTheme();\n  const isMobile = useMediaQuery(theme.breakpoints.down(\"sm\"));\n  return <WrappedComponent {...props} isMobile={isMobile} />;\n};\n\nconst MobileRoot = styled(\"div\")(({ theme }) => ({\n  background: theme.palette.background.paper,\n  boxShadow: theme.shadows[24],\n  left: 0,\n  bottom: 0,\n  right: 0,\n  width: \"auto\",\n  zIndex: 2,\n}));\n\nconst MobileHeader = styled(\"div\")(({ theme }) => ({\n  padding: `6px ${theme.spacing(2)}`,\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n}));\n\nconst BreadCrumbsContainerMobile = styled(\"div\")(({ theme }) => ({\n  maxHeight: \"300px\",\n  overflow: \"auto\",\n  [theme.breakpoints.down(\"sm\")]: {\n    maxHeight: \"110px\",\n  },\n}));\n\nconst BreadCrumbsContainer = styled(\"div\")(() => ({\n  position: \"absolute\",\n  left: 0,\n  right: 0,\n  bottom: 0,\n  zIndex: 2,\n}));\n\nconst MobileBreadCrumbWrapper = styled(\"div\")(({ theme }) => ({\n  width: \"100%\",\n  paddingLeft: theme.spacing(0.5),\n  paddingBottom: theme.spacing(0.5),\n}));\n\nclass BreadCrumbs extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      chapters: null,\n      visibleLayers: [],\n      open: false,\n    };\n    props.app.globalObserver.subscribe(\"informativeLoaded\", (chapters) => {\n      this.setState({\n        chapters: chapters,\n      });\n    });\n  }\n\n  bindLayerEvents = (visibleLayers) => (layer) => {\n    if (layer.get(\"visible\")) {\n      visibleLayers.push(layer);\n    }\n\n    this.setState({\n      visibleLayers: visibleLayers,\n    });\n\n    this.addedLayerBuffer = [];\n    this.removedLayerBuffer = [];\n\n    layer.on(\"change:visible\", (e) => {\n      const changedLayer = e.target;\n      setTimeout(() => {\n        var visibleLayers = [\n          ...this.state.visibleLayers,\n          ...this.addedLayerBuffer,\n        ];\n        visibleLayers = visibleLayers.filter((visibleLayer) => {\n          return !this.removedLayerBuffer.some(\n            (removedLayer) => visibleLayer === removedLayer\n          );\n        });\n        this.setState({\n          visibleLayers: visibleLayers,\n        });\n        this.addedLayerBuffer = [];\n        this.removedLayerBuffer = [];\n      }, 0);\n\n      if (this.props.model.clearing) {\n        this.setState({\n          visibleLayers: [],\n        });\n      } else {\n        if (changedLayer.get(\"visible\")) {\n          this.addedLayerBuffer.push(changedLayer);\n        } else {\n          this.removedLayerBuffer.push(changedLayer);\n        }\n      }\n    });\n  };\n\n  getVisibleLayers() {\n    return this.props.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return layer.getVisible();\n      });\n  }\n\n  clear = () => {\n    this.props.app.clear();\n  };\n\n  componentDidMount() {\n    var visibleLayers = [];\n    if (this.props.map) {\n      this.props.map\n        .getLayers()\n        .getArray()\n        .forEach(this.bindLayerEvents(visibleLayers));\n    }\n  }\n\n  // Returns all active layers except background layers\n  getBreadCrumbCompatibleLayers = () => {\n    return this.state.visibleLayers.filter((layer) =>\n      [\"layer\", \"group\"].includes(layer.get(\"layerType\"))\n    );\n  };\n\n  toggle = () => {\n    this.setState({\n      open: !this.state.open,\n    });\n  };\n\n  renderMobile(layers) {\n    const { open } = this.state;\n    return (\n      <MobileRoot>\n        <MobileHeader>\n          <Typography>Innehåll i kartan</Typography>\n          <IconButton onClick={this.toggle} size=\"small\">\n            {open ? <RemoveCircleIcon /> : <AddCircleIcon />}\n          </IconButton>\n        </MobileHeader>\n        {open && <Divider />}\n        {!open ? null : (\n          <BreadCrumbsContainerMobile>\n            {layers.length > 0 ? (\n              <Grid\n                container\n                item\n                xs={12}\n                justifyContent=\"center\"\n                sx={{ marginTop: 1, marginBottom: 1 }}\n              >\n                <Button variant=\"contained\" onClick={this.clear}>\n                  Ta bort allt innehåll\n                  <VisibilityOffIcon sx={{ marginLeft: 2 }} />\n                </Button>\n              </Grid>\n            ) : (\n              <Typography>\n                Använd sökfunktionen eller innehållsmenyn för att visa\n                information i kartan.\n              </Typography>\n            )}\n            {layers.map((layer, index) => (\n              <MobileBreadCrumbWrapper key={`${layer.get(\"caption\")}-${index}`}>\n                <BreadCrumb\n                  title={layer.get(\"caption\")}\n                  layer={layer}\n                  chapters={this.state.chapters}\n                  app={this.props.app}\n                />\n              </MobileBreadCrumbWrapper>\n            ))}\n          </BreadCrumbsContainerMobile>\n        )}\n      </MobileRoot>\n    );\n  }\n\n  renderDesktop(layers) {\n    const breadCrumbs = layers.map((layer, index) => (\n      <BreadCrumb\n        key={`${layer.get(\"caption\")}-${index}`}\n        title={layer.get(\"caption\")}\n        layer={layer}\n        chapters={this.state.chapters}\n        app={this.props.app}\n      />\n    ));\n    return (\n      <BreadCrumbsContainer>\n        <ScrollMenu ref=\"scrollMenu\" data={breadCrumbs} alignCenter={false} />\n      </BreadCrumbsContainer>\n    );\n  }\n\n  render() {\n    // We've never been mobile, huh?...\n    //const isMobile = this.state.width < 600;\n    const layers = this.getBreadCrumbCompatibleLayers();\n    if (this.props.isMobile) {\n      // We don't want to show the breadcrumbs-summary if there are no layers\n      return layers.length > 0 ? this.renderMobile(layers) : null;\n    } else {\n      return this.renderDesktop(layers);\n    }\n  }\n}\n\nexport default withIsMobile()(BreadCrumbs);\n"],"names":["Root","styled","margin","StyledAppBar","AppBar","top","ContentWrapper","padding","LayersSwitcherView","props","handleChangeTabs","event","activeTab","setState","handleTabsMounted","ref","setTimeout","updateIndicator","renderLayerGroups","shouldRender","style","display","options","groups","map","group","i","model","chapters","state","app","renderBreadCrumbs","showBreadcrumbs","createPortal","onMouseDown","e","stopPropagation","document","getElementById","baseLayers","getBaseLayers","globalObserver","subscribe","Array","isArray","windowVisible","this","sx","position","color","action","onChange","value","variant","textColor","label","showActiveLayersView","layers","layerMap","backgroundSwitcherBlack","backgroundSwitcherWhite","enableOSM","React","WHITE_BACKROUND_LAYER_ID","BLACK_BACKROUND_LAYER_ID","OSM_BACKGROUND_LAYER_ID","SPECIAL_BACKGROUND_COLORS","BackgroundSwitcher","selectedLayerId","isSpecialBackgroundLayer","id","includes","setSpecialBackground","backgroundColor","newSelectedId","target","setVisible","osmLayer","localObserver","Observer","osmSource","OSM","reprojectionErrorThreshold","TileLayer","visible","source","zIndex","layerType","name","caption","layerInfo","backgroundVisibleFromStart","find","layer","addLayer","get","findIndex","l","config","index","checked","mapLayer","set","isFakeMapLayer","properties","opacity","key","getProperties","Object","keys","defaults","push","renderRadioButton","Number","filter","validLayerId","isValidLayerId","console","warn","layerConfig","renderBaseLayerComponents","StyledPaper","Paper","theme","marginRight","spacing","border","palette","divider","ContentGridContainer","Grid","TitleGridContainer","paddingLeft","LinkContainer","BreadCrumb","setHidden","o","getOpacity","hidden","setLayerOpacity","setOpacity","setLayerVisibility","publish","openInformative","chapter","windows","window","type","custom","open","handleClose","anchorEl","popoverOpen","findChapters","on","un","el","original","scrollLeft","reduce","chaptersWithLayer","some","layerId","length","size","onClick","header","renderChaptersPopover","title","square","elevation","container","justifyContent","alignItems","item","renderInformativeIcon","noWrap","onClose","anchorOrigin","vertical","horizontal","transformOrigin","renderChapterLinks","Component","WrappedComponent","MobileRoot","background","paper","boxShadow","shadows","left","bottom","right","width","MobileHeader","BreadCrumbsContainerMobile","maxHeight","overflow","breakpoints","down","BreadCrumbsContainer","MobileBreadCrumbWrapper","paddingBottom","BreadCrumbs","bindLayerEvents","visibleLayers","addedLayerBuffer","removedLayerBuffer","changedLayer","visibleLayer","removedLayer","clearing","clear","getBreadCrumbCompatibleLayers","toggle","getLayers","getArray","getVisible","forEach","xs","marginTop","marginBottom","marginLeft","breadCrumbs","data","alignCenter","isMobile","renderMobile","renderDesktop","useTheme","useMediaQuery"],"sourceRoot":""}