{"version":3,"file":"static/js/3572.9c9b9bfe.chunk.js","mappings":"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","sources":["../node_modules/ol/format/KML.js"],"sourcesContent":["/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  isDocument,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeReplacer,\n  makeSequence,\n  makeSimpleNodeFactory,\n  makeStructureNS,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {asArray} from '../color.js';\nimport {assert} from '../asserts.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readBoolean,\n  readDecimal,\n  readString,\n  writeBooleanTextNode,\n  writeCDATASection,\n  writeDecimalTextNode,\n  writeStringTextNode,\n} from './xsd.js';\nimport {toRadians} from '../math.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [\n  null,\n  'http://earth.google.com/kml/2.0',\n  'http://earth.google.com/kml/2.1',\n  'http://earth.google.com/kml/2.2',\n  'http://www.opengis.net/kml/2.2',\n];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION =\n  'http://www.opengis.net/kml/2.2 ' +\n  'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels',\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'ExtendedData': extendedDataParser,\n    'Region': regionParser,\n    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n    'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n    'Style': makeObjectPropertySetter(readStyle),\n    'StyleMap': placemarkStyleMapParser,\n    'address': makeObjectPropertySetter(readString),\n    'description': makeObjectPropertySetter(readString),\n    'name': makeObjectPropertySetter(readString),\n    'open': makeObjectPropertySetter(readBoolean),\n    'phoneNumber': makeObjectPropertySetter(readString),\n    'styleUrl': makeObjectPropertySetter(readStyleURL),\n    'visibility': makeObjectPropertySetter(readBoolean),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),\n  })\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser,\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\n\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR,\n  });\n\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n\n  DEFAULT_IMAGE_STYLE_SRC =\n    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC,\n  });\n\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1,\n  });\n\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2,\n  });\n\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8,\n  });\n\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0,\n  });\n\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle\n      ? options.defaultStyle\n      : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ =\n      options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ =\n      options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ =\n      options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction\n      ? options.iconUrlFunction\n      : defaultIconUrlFunction;\n\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this),\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop(\n      {'geometry': null},\n      PLACEMARK_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (\n      objectStack[0]\n    );\n\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(\n        style,\n        styleUrl,\n        this.defaultStyle_,\n        this.sharedStyles_,\n        this.showPointNames_\n      );\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [\n      this.getReadOptions(node, options),\n    ]);\n    if (feature) {\n      return feature;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (feature) {\n        return [feature];\n      } else {\n        return [];\n      }\n    } else if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readNameFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readNameFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode(/** @type {Element} */ (n));\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' ||\n          localName == 'Folder' ||\n          localName == 'Placemark' ||\n          localName == 'kml')\n      ) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromNode(/** @type {Element} */ (source))\n      );\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          networkLinks,\n          this.readNetworkLinksFromNode(/** @type {Element} */ (n))\n        );\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        n.localName == 'NetworkLink'\n      ) {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        regions,\n        this.readRegionFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(regions, this.readRegionFromNode(/** @type {Element} */ (source)));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode(/** @type {Element} */ (n)));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATION\n    );\n\n    const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {\n        node: kml,\n      };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(\n      context,\n      KML_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      [options],\n      orderedKeys,\n      this\n    );\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle,\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(\n  style,\n  styleUrl,\n  defaultStyle,\n  sharedStyles,\n  showPointNames\n) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry\n              .getGeometriesArrayRecursive()\n              .filter(function (geometry) {\n                const type = geometry.getType();\n                return type === 'Point' || type === 'MultiPoint';\n              });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n\n      if (drawName) {\n        name = /** @type {string} */ (feature.get('name'));\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null,\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  } else if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  } else {\n    return defaultStyle;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [\n      parseInt(hexColor.substr(6, 2), 16),\n      parseInt(hexColor.substr(4, 2), 16),\n      parseInt(hexColor.substr(2, 2), 16),\n      parseInt(hexColor.substr(0, 2), 16) / 255,\n    ];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re =\n    /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while ((m = re.exec(s))) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false)\n    .trim()\n    .replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin,\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */ (IconObject['href']);\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n\n  let offset;\n  const x = /** @type {number|undefined} */ (IconObject['x']);\n  const y = /** @type {number|undefined} */ (IconObject['y']);\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n\n  let size;\n  const w = /** @type {number|undefined} */ (IconObject['w']);\n  const h = /** @type {number|undefined} */ (IconObject['h']);\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n\n  let rotation;\n  const heading = /** @type {number} */ (object['heading']);\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n\n  const scale = /** @type {number|undefined} */ (object['scale']);\n\n  const color = /** @type {Array<number>|undefined} */ (object['color']);\n\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color,\n    });\n\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (\n            !(\n              imageState === ImageState.IDLE ||\n              imageState === ImageState.LOADING\n            )\n          ) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color:\n        /** @type {import(\"../color.js\").Color} */\n        ('color' in object ? object['color'] : DEFAULT_COLOR),\n    }),\n    scale: /** @type {number|undefined} */ (object['scale']),\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n    width: /** @type {number} */ ('width' in object ? object['width'] : 1),\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */ (object['fill']);\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */ (object['outline']);\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re =\n    /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop(\n    [],\n    GX_MULTITRACK_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'when': whenParser,\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'coord': gxCoordParser,\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop(\n    /** @type {GxTrackObject} */ ({\n      coordinates: [],\n      whens: [],\n    }),\n    GX_TRACK_PARSERS,\n    node,\n    objectStack\n  );\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (\n    let i = 0, ii = Math.min(coordinates.length, whens.length);\n    i < ii;\n    ++i\n  ) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(\n        coordinates[i][0],\n        coordinates[i][1],\n        coordinates[i][2],\n        whens[i]\n      );\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeObjectPropertySetter(readURI),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeObjectPropertySetter(readDecimal),\n    'y': makeObjectPropertySetter(readDecimal),\n    'w': makeObjectPropertySetter(readDecimal),\n    'h': makeObjectPropertySetter(readDecimal),\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  } else {\n    return null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(\n    null,\n    GEOMETRY_FLAT_COORDINATES_PARSERS,\n    node,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [\n      flatCoordinates.length,\n    ]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop(\n    [],\n    MULTI_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      assert(false, 37); // Unknown geometry type found\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return /** @type {import(\"../geom/Geometry.js\").default} */ (multiGeometry);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop(\n    /** @type {Object<string,*>} */ ({}),\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatLinearRings = pushParseAndPop(\n    [null],\n    FLAT_LINEAR_RINGS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop(\n    {},\n    STYLE_PARSERS,\n    node,\n    objectStack,\n    this\n  );\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle =\n    /** @type {Fill} */\n    (\n      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE\n    );\n  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = styleObject['imageStyle'];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle =\n    /** @type {Text} */\n    (\n      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE\n    );\n  const strokeStyle =\n    /** @type {Stroke} */\n    (\n      'strokeStyle' in styleObject\n        ? styleObject['strokeStyle']\n        : DEFAULT_STROKE_STYLE\n    );\n  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type !== 'Polygon' && type !== 'MultiPolygon';\n                })\n            );\n          } else if (type !== 'Polygon' && type !== 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        image: imageStyle,\n        stroke: strokeStyle,\n        text: textStyle,\n        zIndex: undefined, // FIXME\n      }),\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Polygon' || type === 'MultiPolygon';\n                })\n            );\n          } else if (type === 'Polygon' || type === 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        stroke: null,\n        zIndex: undefined, // FIXME\n      }),\n    ];\n  }\n  return [\n    new Style({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined, // FIXME\n    }),\n  ];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      },\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */ (pairObject['key']);\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */ (pairObject['Style']);\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    assert(false, 38); // `styleMapValue` has an unknown type\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */ (\n      objectStack[objectStack.length - 1]\n    );\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop(\n    {},\n    LAT_LON_ALT_BOX_PARSERS,\n    node,\n    objectStack\n  );\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const extent = [\n    parseFloat(object['west']),\n    parseFloat(object['south']),\n    parseFloat(object['east']),\n    parseFloat(object['north']),\n  ];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop(\n    /** @type {Array<Array<number>>} */ ([]),\n    INNER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(\n    undefined,\n    OUTER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRing) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n\n  const layout = context['layout'];\n  const stride = context['stride'];\n\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    assert(false, 34); // Invalid geometry layout\n  }\n\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName),\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const value = pair.value;\n\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.displayName],\n        objectStack,\n        ['displayName']\n      );\n    }\n\n    if (value !== null && value.value) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.value],\n        objectStack,\n        ['value']\n      );\n    }\n  } else {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      [value],\n      objectStack,\n      ['value']\n    );\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    DOCUMENT_SERIALIZERS,\n    DOCUMENT_NODE_FACTORY,\n    features,\n    objectStack,\n    undefined,\n    this\n  );\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      DATA_NODE_FACTORY,\n      [{name: names[i], value: values[i]}],\n      objectStack\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS,\n  ['href'],\n  makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h'])\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeChildAppender(writeStringTextNode),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeChildAppender(writeDecimalTextNode),\n    'y': makeChildAppender(writeDecimalTextNode),\n    'w': makeChildAppender(writeDecimalTextNode),\n    'h': makeChildAppender(writeDecimalTextNode),\n  })\n);\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    GX_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'scale',\n  'heading',\n  'Icon',\n  'color',\n  'hotSpot',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const /** @type {Object<string, any>} */ properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src,\n  };\n\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */ hotSpot = {\n          x: anchor[0],\n          xunits: 'pixels',\n          y: size[1] - anchor[1],\n          yunits: 'pixels',\n        };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n\n  properties['Icon'] = iconProperties;\n\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'scale',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LABEL_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LINE_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry',\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      parentNode.namespaceURI,\n      GEOMETRY_TYPE_TO_NODENAME[\n        /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType()\n      ]\n    );\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */ (geometry)\n      .getGeometriesArrayRecursive()\n      .forEach(function (geometry) {\n        const type = geometry.getType();\n        if (type === 'MultiPoint') {\n          geometries = geometries.concat(\n            /** @type {MultiPoint} */ (geometry).getPoints()\n          );\n        } else if (type === 'MultiLineString') {\n          geometries = geometries.concat(\n            /** @type {MultiLineString} */ (geometry).getLineStrings()\n          );\n        } else if (type === 'MultiPolygon') {\n          geometries = geometries.concat(\n            /** @type {MultiPolygon} */ (geometry).getPolygons()\n          );\n        } else if (\n          type === 'Point' ||\n          type === 'LineString' ||\n          type === 'Polygon'\n        ) {\n          geometries.push(geometry);\n        } else {\n          assert(false, 39); // Unknown geometry type\n        }\n      });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */ (geometry).getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    assert(false, 39); // Unknown geometry type\n  }\n  pushSerializeAndPop(\n    context,\n    MULTI_GEOMETRY_SERIALIZERS,\n    factory,\n    geometries,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    BOUNDARY_IS_SERIALIZERS,\n    LINEAR_RING_NODE_FACTORY,\n    [linearRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'open',\n  'visibility',\n  'address',\n  'phoneNumber',\n  'description',\n  'styleUrl',\n  'Style',\n]);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */ (feature.getId()));\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1,\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {})\n    .sort()\n    .filter(function (v) {\n      return !filter[v];\n    });\n\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return /** @type {GeometryCollection} */ (geometry)\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Point' || type === 'MultiPoint';\n                }).length;\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        ('Point');\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'LineString' || type === 'MultiLineString';\n                  }).length;\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'Polygon' || type === 'MultiPolygon';\n                  }).length;\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles,\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {names: keys, values: sequence};\n    pushSerializeAndPop(\n      context,\n      PLACEMARK_SERIALIZERS,\n      EXTENDEDDATA_NODE_FACTORY,\n      [namesAndValues],\n      objectStack\n    );\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n    objectStack[0]\n  );\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    GEOMETRY_NODE_FACTORY,\n    [geometry],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'extrude',\n  'tessellate',\n  'altitudeMode',\n  'coordinates',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PRIMITIVE_GEOMETRY_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'fill',\n  'outline',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs),\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  // inner rings\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    INNER_BOUNDARY_NODE_FACTORY,\n    linearRings,\n    objectStack\n  );\n  // outer ring\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    OUTER_BOUNDARY_NODE_FACTORY,\n    [outerRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    POLY_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'IconStyle',\n  'LabelStyle',\n  'LineStyle',\n  'PolyStyle',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (\n      imageStyle &&\n      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'\n    ) {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\n\nexport default KML;\n"],"names":["DEFAULT_COLOR","DEFAULT_IMAGE_STYLE_ANCHOR","DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS","DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS","DEFAULT_IMAGE_STYLE_SIZE","DEFAULT_IMAGE_STYLE_SRC","GX_NAMESPACE_URIS","NAMESPACE_URIS","ICON_ANCHOR_UNITS_MAP","PLACEMARK_PARSERS","makeStructureNS","extendedDataParser","regionParser","makeObjectPropertySetter","readMultiGeometry","readLineString","readLinearRing","readPoint","readPolygon","readStyle","node","objectStack","styleMapValue","readStyleMapValue","call","this","placemarkObject","length","Array","isArray","assert","readString","readBoolean","readStyleURL","lineStrings","pushParseAndPop","GX_MULTITRACK_GEOMETRY_PARSERS","MultiLineString","readGxTrack","NETWORK_LINK_PARSERS","parseNode","LINK_PARSERS","readURI","REGION_PARSERS","object","LAT_LON_ALT_BOX_PARSERS","regionObject","extent","parseFloat","LOD_PARSERS","lodObject","KML_SEQUENCE","KML_SERIALIZERS","makeChildAppender","features","context","pushSerializeAndPop","DOCUMENT_SERIALIZERS","DOCUMENT_NODE_FACTORY","undefined","writePlacemark","DEFAULT_FILL_STYLE","DEFAULT_NO_IMAGE_STYLE","DEFAULT_IMAGE_STYLE","DEFAULT_TEXT_STROKE_STYLE","DEFAULT_STROKE_STYLE","DEFAULT_TEXT_STYLE","DEFAULT_STYLE","TEXTAREA","DEFAULT_STYLE_ARRAY","scaleForSize","size","Math","min","defaultIconUrlFunction","href","KML","options","Fill","color","Icon","anchor","anchorOrigin","anchorXUnits","anchorYUnits","crossOrigin","rotation","scale","src","Stroke","width","Text","font","fill","stroke","Style","image","text","zIndex","dataProjection","getProjection","defaultStyle_","defaultStyle","extractStyles_","extractStyles","writeStyles_","writeStyles","sharedStyles_","showPointNames_","showPointNames","crossOrigin_","iconUrlFunction_","iconUrlFunction","supportedMediaTypes","parsersNS","makeArrayExtender","readDocumentOrFolder_","makeArrayPusher","readPlacemark_","readSharedStyle_","bind","readSharedStyleMap_","feature","Feature","id","getAttribute","setId","geometry","transformGeometryWithOptions","setGeometry","styleFunction","style","styleUrl","sharedStyles","resolution","drawName","name","multiGeometryPoints","getGeometry","GeometryCollection","getGeometriesArrayRecursive","filter","type","getType","get","test","document","createElement","innerHTML","value","featureStyle","findStyle","nameStyle","foundStyle","textOffset","textAlign","imageStyle","getImage","imageSize","getSize","imageScale","getScaleArray","getAnchor","textStyle","getText","clone","setFont","getFont","setScale","getScale","setFill","getFill","setStroke","getStroke","setText","setOffsetX","setOffsetY","setTextAlign","createNameStyleFunction","concat","slice","createFeatureStyleFunction","setStyle","setProperties","styleUri","baseURI","window","location","URL","includes","namespaceURI","getReadOptions","localName","n","firstElementChild","nextElementSibling","fs","readFeaturesFromNode","extend","source","doc","parse","readNameFromDocument","isDocument","readNameFromNode","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","networkLinks","readNetworkLinksFromDocument","readNetworkLinksFromNode","obj","push","regions","readRegionFromDocument","readRegionFromNode","adaptOptions","kml","createElementNS","xmlnsUri","setAttributeNS","XML_SCHEMA_INSTANCE_URI","properties","orderedKeys","values","makeSequence","OBJECT_PROPERTY_NODE_FACTORY","XMLFeature","styleValue","readColor","s","getAllTextContent","m","exec","hexColor","parseInt","substr","readFlatCoordinates","flatCoordinates","replace","re","x","y","z","trim","readScale","readDecimal","STYLE_MAP_PARSERS","pairObject","PAIR_PARSERS","key","ICON_STYLE_PARSERS","iconObject","ICON_PARSERS","origin","xunits","yunits","LABEL_STYLE_PARSERS","LINE_STYLE_PARSERS","POLY_STYLE_PARSERS","FLAT_LINEAR_RING_PARSERS","makeReplacer","readFlatLinearRing","GX_TRACK_PARSERS","whens","when","Date","isNaN","coordinates","gxTrackObject","i","ii","LineString","GEOMETRY_FLAT_COORDINATES_PARSERS","readFlatCoordinatesFromNode","EXTRUDE_AND_ALTITUDE_MODE_PARSERS","lineString","polygon","Polygon","MULTI_GEOMETRY_PARSERS","multiGeometry","geometries","layout","homogeneous","point","getLayout","getFlatCoordinates","setCommonGeometryProperties","MultiPoint","MultiPolygon","Point","FLAT_LINEAR_RINGS_PARSERS","innerBoundaryFlatLinearRings","INNER_BOUNDARY_IS_PARSERS","flatLinearRings","flatLinearRing","OUTER_BOUNDARY_IS_PARSERS","ends","STYLE_PARSERS","styleObject","IconObject","drawIcon","Object","keys","offset","hotSpot","w","h","heading","toRadians","offsetOrigin","imageState","getImageState","ImageState","listenImageChange","listener","resizeScale","unlistenImageChange","load","strokeStyle","fillStyle","outline","collection","hasExtrude","hasTessellate","hasAltitudeMode","extrudes","tessellates","altitudeModes","set","DATA_PARSERS","EXTENDED_DATA_PARSERS","featureObject","displayName","toString","SCHEMA_DATA_PARSERS","data","writeColorTextNode","rgba","asArray","abgr","hex","floor","writeStringTextNode","join","EXTENDEDDATA_NODE_SERIALIZERS","pair","setAttribute","writeCDATASection","nodeName","parentNode","DATA_NODE_FACTORY","makeSimpleNodeFactory","ICON_SEQUENCE","ICON_SERIALIZERS","writeDecimalTextNode","GX_NODE_FACTORY","ICON_STYLE_SEQUENCE","ICON_STYLE_SERIALIZERS","icon","vec2","String","writeScaleTextNode","LABEL_STYLE_SEQUENCE","LABEL_STYLE_SERIALIZERS","LINE_STYLE_SEQUENCE","LINE_STYLE_SERIALIZERS","GEOMETRY_TYPE_TO_NODENAME","GEOMETRY_NODE_FACTORY","POINT_NODE_FACTORY","LINE_STRING_NODE_FACTORY","LINEAR_RING_NODE_FACTORY","POLYGON_NODE_FACTORY","MULTI_GEOMETRY_SERIALIZERS","writePrimitiveGeometry","writePolygon","writeMultiGeometry","factory","forEach","getPoints","getLineStrings","getPolygons","BOUNDARY_IS_SERIALIZERS","writeBoundaryIs","linearRing","PLACEMARK_SERIALIZERS","namesAndValues","names","styles","pointStyles","getSrc","lineStyles","polyStyles","STYLE_SEQUENCE","STYLE_SERIALIZERS","writeBooleanTextNode","PLACEMARK_SEQUENCE","EXTENDEDDATA_NODE_FACTORY","getId","getProperties","getGeometryName","sort","v","getStyleFunction","styleArray","getGeometryFunction","PRIMITIVE_GEOMETRY_SEQUENCE","PRIMITIVE_GEOMETRY_SERIALIZERS","dimension","stride","d","getStride","POLY_STYLE_SEQUENCE","POLYGON_SERIALIZERS","INNER_BOUNDARY_NODE_FACTORY","OUTER_BOUNDARY_NODE_FACTORY","linearRings","getLinearRings","outerRing","shift","POLY_STYLE_SERIALIZERS","round","iconImageSize","getImageSize","iconProperties","getOrigin","getRotation","getColor","Number","getWidth"],"sourceRoot":""}