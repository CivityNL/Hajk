{"version":3,"file":"static/js/7512.31b9d140.chunk.js","mappings":"oQAUMA,GAAaC,EAAAA,EAAAA,IAAOC,EAAAA,EAAPD,EAAgB,gBAAGE,EAAH,EAAGA,MAAH,eACjCC,aAAcD,EAAME,QAAQ,GAC5BC,MAAO,SACNH,EAAMI,YAAYC,KAAK,MAAQ,CAC9BC,UAAW,OACXC,aAAc,iBACdC,aAAc,EACdC,OAAQ,EACRN,MAAO,OACPO,eAAgB,QATe,IAa7BC,GAAeb,EAAAA,EAAAA,IAAOc,EAAAA,EAAPd,EAAe,kBAAgB,CAClDe,WADkC,EAAGb,MACnBc,QAAQC,KAAKC,QADG,IAI9BC,EAAAA,SAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,GAAAA,SAAAA,IAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,KAAAA,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GACI,OADJA,EAAAA,EAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,KACJC,MAAQ,CACNC,MAAM,EACNJ,KAAM,IAFA,EA+BP,OA/BO,8BAiBR,WACE,MAA2CK,KAAKC,MAAxCC,EAAR,EAAQA,SAAUC,EAAlB,EAAkBA,KAAMC,EAAxB,EAAwBA,QAASC,EAAjC,EAAiCA,MAEjC,OACE,SAAC5B,EAAD,CAAY2B,QAASA,EAArB,UACE,SAAC,IAAD,WACE,SAAC,IAAD,CACEE,QAAQ,SAACf,EAAD,UAAeY,IACvBE,MAAOA,EACPE,UAAWL,OAKpB,OAhCGL,CAAaW,EAAAA,eAAbX,EAaGY,aAAe,CACpBP,SAAU,qBACVG,MAAO,gBAoBX,W,kNCrDMK,EAAAA,SAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,GAUJ,WAAYT,GAAQ,IAAD,mBACjB,cAAMA,IA+ERU,kBAAoB,SAACC,GACnB,EAAKC,WAAW,CACdC,wBAAwB,EACxBC,aAAa,IAEf,EAAKd,MAAMe,IAAIC,eAAeC,QAAQ,8BACvC,EAtFkB,EAwFnBL,WAAa,SAACM,GACZ,IAAML,EAAyBK,EAAKL,yBAA0B,EAC5DC,EAAcI,EAAKJ,cAAe,EAapC,GAVA,EAAKd,MAAMe,IAAII,WAAa,EAAKC,KAGjC,EAAKpB,MAAMe,IAAIC,eAAeC,QAAQ,uBAAwB,CAC5DI,UAAW,cACXC,WAAY,EAAKF,KACjBG,UAAW,EAAKvB,MAAMe,IAAIS,OAAOD,aAIF,IAA7B,EAAK1B,MAAM4B,cACb,OAAO,MAGkB,IAA3BZ,GAAmC,EAAKb,MAAMe,IAAIW,cAAf,WAEnC,EAAKC,SACH,CACEF,eAAe,IAEjB,YAEkB,IAAhBX,GAC4C,oBAAnC,EAAKd,MAAM4B,OAAOC,cACzB,EAAK7B,MAAM4B,OAAOC,cACrB,GAEJ,EAxHkB,EA0HnBC,YAAc,WAGR,EAAKV,OAAS,EAAKpB,MAAMe,IAAII,aAC/B,EAAKnB,MAAMe,IAAII,gBAAaY,GAE9B,EAAKJ,SACH,CACEF,eAAe,IAEjB,WAC4C,oBAAnC,EAAKzB,MAAM4B,OAAOI,cACvB,EAAKhC,MAAM4B,OAAOI,cACrB,GAEJ,EAtIC,EAAKZ,KAAOpB,EAAMoB,KAAKa,oBAAiBF,EAGxC,EAAKG,YAAclC,EAAMmC,QAAQD,aAAelC,EAAM4B,OAAOM,YAG7D,IAAME,GAC2C,IAA9C,EAAKpC,MAAMe,IAAIS,OAAOa,UAAUC,IAAIC,QAClCC,EAAAA,SACGxC,EAAMmC,QAAQM,qBACdzC,EAAMmC,QAAQC,kBACpB,EAKEA,GACF,EAAKpC,MAAMe,IAAIC,eAAeC,QAAQ,uBAAwB,CAC5DI,UAAW,cACXC,WAAY,EAAKF,KACjBG,UAAW,EAAKvB,MAAMe,IAAIS,OAAOD,YAMrC,EAAK1B,MAAQ,CACXO,MAAOJ,EAAMmC,QAAQ/B,OAASJ,EAAM4B,OAAOxB,OAAS,iBACpDsC,MAAO1C,EAAMmC,QAAQO,OAAS1C,EAAM4B,OAAOc,OAAS,KACpDjB,cAAeW,GAMjB,EAAKhC,MAAQJ,EAAMmC,QAAQ/B,OAASJ,EAAM4B,OAAOxB,OAAS,iBAG1D,EAAKtB,MAAQkB,EAAMmC,QAAQrD,OAASkB,EAAM4B,OAAO9C,OAAS,IAC1D,EAAK6D,OAAS3C,EAAMmC,QAAQQ,QAAU3C,EAAM4B,OAAOe,QAAU,OAC7D,EAAKC,SAAW5C,EAAMmC,QAAQS,UAAY5C,EAAM4B,OAAOgB,UAAY,OAGnE5C,EAAMe,IAAI8B,sBAAV,WAIA,IAAMxB,EAAS,UAAM,EAAKD,KAAX,eAGfpB,EAAMe,IAAIC,eAAe8B,UAAUzB,GAAW,SAACH,GAC7C,EAAKN,WAAWM,EACjB,IAGD,IAAM6B,EAAc,UAAM,EAAK3B,KAAX,gBA1DH,OA4DjBpB,EAAMe,IAAIC,eAAe8B,UAAUC,GAAgB,WACjD,EAAKjB,aACN,IA9DgB,CA+DlB,CAmMA,O,0CAhMD,SAAmBkB,GAGjBA,EAAUpB,OAAOxB,QAAUL,KAAKC,MAAM4B,OAAOxB,OAC3CL,KAAK4B,SAAS,CAAEvB,MAAOL,KAAKC,MAAM4B,OAAOxB,QAE3C4C,EAAUpB,OAAOc,QAAU3C,KAAKC,MAAM4B,OAAOc,OAC3C3C,KAAK4B,SAAS,CAAEe,MAAO3C,KAAKC,MAAM4B,OAAOc,OAC5C,+BAED,SAAeO,GACb,MAAO,CAAC,OAAQ,SAASC,SAASD,EACnC,6BAmED,SAAarB,GACX,IAAQqB,EAAWlD,KAAKC,MAAMmC,QAAtBc,OAIR,MAAiC,oBAA1B,OAAOrB,QAAP,IAAOA,OAAP,EAAOA,EAAQuB,QACpBvB,EAAOuB,UAKP,iCACE,SAAC,UAAD,CACEnC,eAAgBjB,KAAKC,MAAMe,IAAIC,eAC/BZ,MAAOL,KAAKF,MAAMO,MAClBsC,MAAO3C,KAAKF,MAAM6C,MAClBU,QAASrD,KAAK+B,YACdhC,KAAMC,KAAKF,MAAM4B,cACjB4B,SAAUtD,KAAKC,MAAM4B,OAAOyB,SAC5BC,WAAYvD,KAAKC,MAAM4B,OAAO0B,WAC9BC,WAAYxD,KAAKC,MAAM4B,OAAO2B,WAC9BC,gBAAiBzD,KAAKC,MAAM4B,OAAO4B,gBACnCC,yBAA0B1D,KAAKC,MAAM4B,OAAO6B,yBAC5CC,gBAAiB3D,KAAKC,MAAM4B,OAAO8B,gBACnCC,WAAY5D,KAAKC,MAAM4B,OAAO+B,WAC9BC,qBAAsB7D,KAAKC,MAAM4B,OAAOgC,qBACxCC,eAAgB9D,KAAKC,MAAM4B,OAAOiC,eAClC/E,MAAOiB,KAAKjB,MACZ6D,OAAQ5C,KAAK4C,OACbC,SAAU7C,KAAK6C,SACfkB,KAAK,SACLC,oBAAqBhE,KAAKC,MAAMe,IAAIS,OAAOa,UAAU2B,MAAMC,MACzD,SAACC,GAAD,MAAkB,kBAAXA,EAAE9C,IAAT,IApBJ,SA2BGb,EAAAA,aAAmBR,KAAKC,MAAMmE,SAAU,CACvC1C,cAAe1B,KAAKF,MAAM4B,mBAIjB,YAAXwB,GAAwBlD,KAAKqE,eAAenB,KAC5ClD,KAAKsE,qBAENtE,KAAKqE,eAAenB,IACnBlD,KAAKuE,mBAAL,UAA2BrB,EAA3B,YAEU,YAAXA,GAAwBlD,KAAKwE,wBAGnC,GASH,gCACE,WACE,OAAOC,EAAAA,EAAAA,eACL,SAAC,IAAD,CAAQC,KAAM1E,KAAKqE,eAAerE,KAAKC,MAAMmC,QAAQc,QAArD,UACE,UAAC,KAAD,CACEyB,QAAM,EACNC,SAAS,EACTC,SAAU7E,KAAKF,MAAM4B,cACrBtB,QAASJ,KAAKW,kBAJhB,WAME,SAAC,IAAD,UAAeX,KAAKC,MAAM4B,OAAO1B,QACjC,SAAC,IAAD,CAAcP,QAASI,KAAKK,aAGhCyE,SAASC,eAAe,kBAE3B,mCAED,SAAmBC,GACjB,OAAOP,EAAAA,EAAAA,eAEL,SAAC,IAAD,CAAQQ,QAAM,EAAd,UACE,SAAC,UAAD,CACE9E,KAAMH,KAAKC,MAAM4B,OAAO1B,KACxBC,QAASJ,KAAKW,kBACdN,MAAOL,KAAKK,MACZH,SAAUF,KAAKmC,gBAGnB2C,SAASC,eAAeC,GAE3B,oCAED,WACE,OAAOP,EAAAA,EAAAA,eACL,SAAC,UAAD,CACEtE,KAAMH,KAAKC,MAAM4B,OAAO1B,KACxBC,QAASJ,KAAKW,kBACdN,MAAOL,KAAKK,MACZH,SAAUF,KAAKmC,cAEjB2C,SAASC,eAAe,0BAE3B,uBAED,WAEE,OACgD,IAA9C/E,KAAKC,MAAMe,IAAIS,OAAOa,UAAUC,IAAIC,OACpCxC,KAAKkF,aAAalF,KAAKC,MAAM4B,OAEhC,OA5QGnB,CAAyBF,EAAAA,eA+Q/B,W,6ICvNA,UArDkB,SAACP,GAEjB,IAAMkF,EAAgBC,MAIhBC,EAAe,IAAIC,EAAAA,QAAa,CACpCH,cAAeA,EACf5C,IAAKtC,EAAMsC,IACXH,QAASnC,EAAMmC,UAKXmD,EAAiB,IAAIC,EAAAA,QAAe,CACxCL,cAAeA,EACfnE,IAAKf,EAAMe,IACXqE,aAAcA,EACdjD,QAASnC,EAAMmC,UAYjB,OACE,SAAC,WAAD,kBACMnC,GADN,IAEEoB,KAAK,YACLQ,OAAQ,CACN1B,MAAM,SAAC,IAAD,IACNE,MAAO,aACP8B,YAAa,sCACbS,OAAQ,UACR7D,MAAO,IACPkD,aAjBe,WACnBkD,EAAcjE,QAAQ,wBAAyB,IAC/CiE,EAAcjE,QAAQ,uBAAwB,GAC/C,GAKC,UAYE,SAAC,UAAD,CACEuE,MAAOF,EACPF,aAAcA,EACdjD,QAASnC,EAAMmC,QACf+C,cAAeA,MAItB,C,6lBC7DKK,GAAAA,EAAAA,EAAAA,IAMJ,WAAYE,GAAW,IAAD,oQAQtBC,mBAAqB,WACnB,OAAO,SAAP,KACD,EAVqB,KAatBC,WAAa,SAACC,EAAWC,GACvB,OAA0B,KAAb,OAATD,QAAS,IAATA,OAAA,EAAAA,EAAWE,SAAwC,KAAb,OAAXD,QAAW,IAAXA,OAAA,EAAAA,EAAaC,QACnC,MAEF,SAAI,GAAJ,GAAcC,SAAS9B,MAAK,SAAC+B,GAClC,OAAOA,EAAQC,QAAUL,GAAaI,EAAQE,OAASL,CACxD,GACF,EApBqB,KA2BtBM,UAAY,SAACP,EAAWC,EAAaO,EAAmBC,GAEtD,IAAML,EAAU,EAAKL,WAAWC,EAAWC,GAM3C,MAAkB,KAAdQ,GAAoBL,EAAQM,gBACvB,SAAP,MAAmCN,EAASI,EAAmBC,IAG1D,SAAP,MAA8BL,EAASI,EACxC,EAxCqB,gDA4CI,SAACJ,EAASI,EAAmBC,GAGrD,IAAIE,EAAa,2EAAuEF,EAAvE,KAEjB,IAAK,EAAKG,wBAAwBR,GAAU,CAE1C,IAAMS,GAAU,SAAI,GAAJ,GAAmBC,0BAEnCH,GAAa,UAAOP,EAAQW,aAAf,YAA+BF,EAA/B,IACd,CAKD,OAJAL,EAAkBQ,SAAQ,SAACC,GACzBN,GAAa,kBAAO,EAAP,MAAyCM,GAAzC,IACd,IAEMN,CACR,IA5DqB,gDA+DS,SAACM,GAAe,IAAD,YAC5C,OAAQA,EAAUzF,MAChB,IAAK,SACL,IAAK,gBACL,IAAK,SACL,IAAK,OACL,IAAK,WAEH,MAAM,GAAN,OAAUyF,EAAUX,KAApB,gCACEW,EAAUC,aADZ,QACqBD,EAAUE,oBAD/B,QAC+C,IAEjD,IAAK,UACL,IAAK,iBAEH,IAAMC,EAAa,oBAAGH,EAAUC,aAAb,QAAsBD,EAAUE,oBAAhC,QAAgD,GAEnE,OAA6B,IAAzBC,EAAclB,OACV,GAAN,OAAUe,EAAUX,KAApB,KAGa,UAAMW,EAAUX,KAAhB,YAAwBc,EAAcC,KAAK,MAE5D,IAAK,eAEH,IAAQH,EAAU,EAAKI,2BAA2BL,GAA1CC,MACR,MAAM,GAAN,OAAUD,EAAUX,KAApB,YAA4BY,GAC9B,QAEE,2BAAOD,EAAUC,aAAjB,QAA0BD,EAAUE,oBAApC,QAAoD,GAEzD,IA7FqB,KAkGtBP,wBAA0B,SAACR,GACzB,OACGA,IACAA,EAAQW,cACgB,KAAzBX,EAAQW,cACiB,SAAzBX,EAAQW,YAEX,EAzGqB,gDA+GP,SAACQ,GAEd,OAAyB,IAArBA,EACK,EAIFC,OAAO,KAAD,OAAM,IAAIC,SAASF,EAAkB,MACnD,IAvHqB,KA2HtBD,2BAA6B,SAACL,GAAe,IAAD,EAEpCS,GAAI,OAAG,EAAH,MAAqBT,EAAUM,kBAMzC,MAAO,CAAEL,MAHE,UACTD,EAAUC,aADD,QACU,EAAKS,sBAAsBV,EAAWS,GAE3CA,KAAAA,EACjB,EApIqB,KAwItBC,sBAAwB,SAACV,EAAWS,GAClC,OAAOT,EAAUW,iBACbX,EAAUY,QAAUH,EACpBT,EAAUY,OACf,EA5IqB,KAgJtBC,sBAAwB,SAACb,EAAWS,GAClC,OAAOT,EAAUc,iBACbd,EAAUe,QAAUN,EACpBT,EAAUe,OACf,EApJqB,gDAyJD,SAACf,GAAe,IAAD,YAClC,OAAQA,EAAUzF,MAChB,IAAK,SACL,IAAK,gBACL,IAAK,SACL,IAAK,OACL,IAAK,WAEH,2BAAOyF,EAAUC,aAAjB,QAA0BD,EAAUE,oBAApC,QAAoD,GACtD,IAAK,UACL,IAAK,iBAEH,2BAAOF,EAAUC,aAAjB,QAA0BD,EAAUE,oBAApC,QAAoD,GACtD,IAAK,eAEH,IAAQD,EAAU,EAAKI,2BAA2BL,GAA1CC,MACR,OAAOA,EACT,QAEE,2BAAOD,EAAUC,aAAjB,QAA0BD,EAAUE,oBAApC,QAAoD,GAEzD,IA9KqB,gDAkLC,SAACf,EAASI,GAE/B,IAAMyB,EAAmB,GAEzB,IAAK,EAAKrB,wBAAwBR,GAAU,CAE1C,IAAMS,GAAU,SAAI,GAAJ,GAAmBC,0BAEnCmB,EAAiBC,KAAK,CAAE5B,KAAMF,EAAQW,aAAcG,MAAOL,GAC5D,CAOD,OALAL,EAAkBQ,SAAQ,SAACC,GACzB,IAAMC,GAAK,OAAG,EAAH,MAA2BD,GACtCgB,EAAiBC,KAAK,CAAE5B,KAAMW,EAAUX,KAAMY,MAAOA,GACtD,IAEMe,CACR,IAnMqB,KAuMtBE,sBAAwB,SAACC,EAAYpC,EAAWC,GAE9C,IAAMG,EAAU,EAAKL,WAAWC,EAAWC,GAE3C,OAAKG,EAKEgC,EAAWC,QAAO,SAACpB,GACxB,OAAOA,EAAUX,OAASF,EAAQW,YACnC,IANQ,EAOV,EAnNqB,KAqNtBuB,WAAa,SAACtC,EAAWC,GAAiB,IAAD,EAEjCG,EAAU,EAAKL,WAAWC,EAAWC,GAE3C,OAAKG,GAIL,UAAOA,EAAQmC,eAAf,QAHS,EAIV,EA9NqB,KAiOtBC,qBAAuB,SAACxC,EAAWC,GAEjC,IAAMG,EAAU,EAAKL,WAAWC,EAAWC,GAE3C,QAAKG,GAKEA,EAAQM,cAChB,EA3OqB,KA8OtB+B,aAAe,SAACC,GACd,GAA2B,kBAAhBA,EACT,OAAO,EAGT,MADe,eACDC,KAAKD,EACpB,EApPqB,KAuPtBE,qBAvPsB,mCAuPC,WAAO5C,EAAWC,GAAlB,gFAGfG,EAAU,EAAKL,WAAWC,EAAWC,GAHtB,yCAKZ,CAAE4C,OAAO,EAAMT,WAAY,KALf,cAQfU,GARe,OAQT,EARS,MAQoB1C,GARpB,mBAWI2C,EAAAA,EAAAA,QAAOD,GAXX,cAWbE,EAXa,iBAYAA,EAASC,OAZT,eAYbC,EAZa,yBAaZ,CAAEL,OAAO,EAAOT,WAAYc,IAbhB,2DAeZ,CAAEL,OAAO,EAAMT,WAAY,KAff,0DAvPD,2IA6QF,WAAOhC,EAASI,GAAhB,wFAEZyB,GAFY,OAEO,EAFP,MAGhB7B,EACAI,GAGIsC,GAPY,OAON,EAPM,MAO8B1C,GAE1C+C,EAAOC,KAAKC,UAAU,CAAEC,oBAAqBrB,IATjC,mBAYOc,EAAAA,EAAAA,QAAOD,EAAK,CACjCS,OAAQ,OACRJ,KAAMA,EACNK,YAAa,cACbC,QAAS,CACP,eAAgB,sBAjBJ,cAYVT,EAZU,gBAoBGA,EAASC,OApBZ,cAoBVC,EApBU,yBAqBT,CAAEL,OAAO,EAAOa,MAAK,UAAER,EAAK/D,UAAP,QAAa,OArBzB,2DAuBT,CAAE0D,OAAO,EAAMa,MAAO,OAvBb,0DA7QE,6IAySG,WAAOtD,EAASI,EAAmBC,GAAnC,wFAEjBkD,GAFiB,OAEJ,EAFI,MAEwBvD,GAGzCwD,GALiB,OAKE,EALF,MAMrBxD,EACAI,EACAC,GARqB,mBAYEsC,EAAAA,EAAAA,QAAOY,EAAY,CACxCJ,OAAQ,OACRJ,KAAMS,EACNJ,YAAa,cACbC,QAAS,CACP,eAAgB,uCAjBC,cAYfT,EAZe,gBAoBFA,EAASC,OApBP,cAoBfC,EApBe,yBAqBd,CAAEL,OAAO,EAAOa,MAAK,iBAAER,QAAF,IAAEA,GAAF,UAAEA,EAAMW,uBAAR,aAAE,EAAuBC,aAAzB,QAAkC,OArBzC,2DAuBd,CAAEjB,OAAO,EAAMa,MAAO,OAvBR,0DAzSH,iEAqUtBK,iBArUsB,mCAqUH,WAAOL,GAAP,gFAEZA,EAFY,yCAGR,CAAEb,OAAO,EAAMmB,OAAQ,OAHf,cAMXlB,GANW,OAML,EANK,MAMwBY,GANxB,mBASQX,EAAAA,EAAAA,QAAOD,GATf,cASTE,EATS,gBAUIA,EAASC,OAVb,cAUTC,EAVS,yBAWR,CAAEL,OAAO,EAAOmB,OAAM,iBAAEd,QAAF,IAAEA,OAAF,EAAEA,EAAMc,cAAR,QAAkB,OAXhC,2DAaR,CAAEnB,OAAO,EAAMmB,OAAQ,OAbf,0DArUG,sGAuVI,SAAC5D,GACzB,MAAM,GAAN,eAAU,EAAV,mDACEA,EAAQ6D,WADV,kBAEU7D,EAAQ8D,UAFlB,eAGD,IA3VqB,gDA8VW,SAAC9D,GAChC,MAAM,GAAN,eACE,EADF,6DAE+CA,EAAQ6D,WAFvD,YAGE7D,EAAQ8D,UAHV,IAKD,IApWqB,gDAwWG,SAAC9D,GACxB,MAAM,GAAN,eAAU,EAAV,2CACEA,EAAQ6D,WADV,YAEI7D,EAAQ8D,UAFZ,IAGD,IA5WqB,gDAgXI,SAACR,GACzB,MAAM,GAAN,eACE,EADF,8DAEgDA,EAFhD,IAGD,KAnXC,OAAAvJ,KAAA,MAAgB0F,EAAStD,SACzB,OAAApC,KAAA,MAAuB0F,EAAS1E,IAAIS,OAAOuI,UAAUC,gBACrD,OAAAjK,KAAA,0BAAwB0F,EAAS1E,IAAIS,OAAOyI,mBAA5C,aAAwB,EAAiCC,YAAzD,QAAiE,IACjE,OAAAnK,KAAA,MAAqB0F,EAASL,YAC/B,IAiXH,W","sources":["components/Card.js","plugins/BaseWindowPlugin.js","plugins/FmeServer/FmeServer.js","plugins/FmeServer/models/FmeServerModel.js"],"sourcesContent":["import React from \"react\";\nimport propTypes from \"prop-types\";\nimport { styled } from \"@mui/material/styles\";\nimport {\n  Card as MUICard,\n  CardHeader,\n  CardActionArea,\n  Avatar,\n} from \"@mui/material\";\n\nconst StyledCard = styled(MUICard)(({ theme }) => ({\n  marginBottom: theme.spacing(1),\n  width: \"210px\",\n  [theme.breakpoints.down(\"sm\")]: {\n    boxShadow: \"none\",\n    borderBottom: \"1px solid #ccc\",\n    borderRadius: 0,\n    margin: 0,\n    width: \"100%\",\n    justifyContent: \"left\",\n  },\n}));\n\nconst StyledAvatar = styled(Avatar)(({ theme }) => ({\n  background: theme.palette.text.primary,\n}));\n\nclass Card extends React.PureComponent {\n  state = {\n    open: false,\n    text: \"\",\n  };\n\n  static propTypes = {\n    abstract: propTypes.string.isRequired,\n    icon: propTypes.object.isRequired,\n    onClick: propTypes.func.isRequired,\n    title: propTypes.string.isRequired,\n  };\n\n  static defaultProps = {\n    abstract: \"Beskrivning saknas\",\n    title: \"Titel saknas\",\n  };\n\n  render() {\n    const { abstract, icon, onClick, title } = this.props;\n\n    return (\n      <StyledCard onClick={onClick}>\n        <CardActionArea>\n          <CardHeader\n            avatar={<StyledAvatar>{icon}</StyledAvatar>}\n            title={title}\n            subheader={abstract}\n          />\n        </CardActionArea>\n      </StyledCard>\n    );\n  }\n}\n\nexport default Card;\n","import React from \"react\";\nimport propTypes from \"prop-types\";\nimport { isMobile } from \"./../utils/IsMobile\";\nimport { createPortal } from \"react-dom\";\nimport { Hidden, ListItem, ListItemIcon, ListItemText } from \"@mui/material\";\nimport Window from \"../components/Window.js\";\nimport Card from \"../components/Card.js\";\nimport PluginControlButton from \"../components/PluginControlButton\";\n\nclass BaseWindowPlugin extends React.PureComponent {\n  static propTypes = {\n    app: propTypes.object.isRequired,\n    children: propTypes.object.isRequired,\n    custom: propTypes.object.isRequired,\n    map: propTypes.object.isRequired,\n    options: propTypes.object.isRequired,\n    type: propTypes.string.isRequired,\n  };\n\n  constructor(props) {\n    super(props);\n    // 'type' is basically a unique identifier for each plugin\n    this.type = props.type.toLowerCase() || undefined;\n\n    // There will be defaults in props.custom, so that each plugin has own default title/description\n    this.description = props.options.description || props.custom.description;\n\n    // Should Window be visible at start?\n    const visibleAtStart =\n      (this.props.app.config.mapConfig.map.clean === false && // Never show in clean mode\n        (isMobile\n          ? props.options.visibleAtStartMobile\n          : props.options.visibleAtStart)) ||\n      false;\n\n    // If plugin is shown at start, we want to register it as shown in the Analytics module too.\n    // Normally, the event would be sent when user clicks on the button that activates the plugin,\n    // but in this case there won't be any click as the window will be visible at start.\n    if (visibleAtStart) {\n      this.props.app.globalObserver.publish(\"analytics.trackEvent\", {\n        eventName: \"pluginShown\",\n        pluginName: this.type,\n        activeMap: this.props.app.config.activeMap,\n      });\n    }\n\n    // Title and Color are kept in state and not as class properties. Keeping them in state\n    // ensures re-render when new props arrive and update the state variables (see componentDidUpdate() too).\n    this.state = {\n      title: props.options.title || props.custom.title || \"Unnamed plugin\",\n      color: props.options.color || props.custom.color || null,\n      windowVisible: visibleAtStart,\n    };\n\n    // Title is a special case: we want to use the state.title and pass on to Window in order\n    // to update Window's title dynamically. At the same time, we want all other occurrences,\n    // e.g. Widget or Drawer button's label to remain the same.\n    this.title = props.options.title || props.custom.title || \"Unnamed plugin\";\n\n    // Try to get values from admin's option. Fallback to customs from Plugin defaults, or finally to hard-coded values.\n    this.width = props.options.width || props.custom.width || 400;\n    this.height = props.options.height || props.custom.height || \"auto\";\n    this.position = props.options.position || props.custom.position || \"left\";\n\n    // Register Window in our global register\n    props.app.registerWindowPlugin(this);\n\n    // Subscribe to a global event that makes it possible to show/hide Windows.\n    // First we prepare a unique event name for each plugin so it looks like '{pluginName}.showWindow'.\n    const eventName = `${this.type}.showWindow`;\n    // Next, subscribe to that event, expect 'opts' array.\n    // To find all places where this event is publish, search for 'globalObserver.publish(\"show'\n    props.app.globalObserver.subscribe(eventName, (opts) => {\n      this.showWindow(opts);\n    });\n\n    // Same as above, but to close the window.\n    const closeEventName = `${this.type}.closeWindow`;\n\n    props.app.globalObserver.subscribe(closeEventName, () => {\n      this.closeWindow();\n    });\n  }\n\n  // Does not run on initial render, but runs on subsequential re-renders.\n  componentDidUpdate(prevProps) {\n    // Window's title and color can be updated on-the-flight, so we keep them\n    // in state and ensure that state is updated when new props arrive.\n    prevProps.custom.title !== this.props.custom.title &&\n      this.setState({ title: this.props.custom.title });\n\n    prevProps.custom.color !== this.props.custom.color &&\n      this.setState({ color: this.props.custom.color });\n  }\n\n  pluginIsWidget(target) {\n    return [\"left\", \"right\"].includes(target);\n  }\n\n  handleButtonClick = (e) => {\n    this.showWindow({\n      hideOtherPluginWindows: true,\n      runCallback: true,\n    });\n    this.props.app.globalObserver.publish(\"core.onlyHideDrawerIfNeeded\");\n  };\n\n  showWindow = (opts) => {\n    const hideOtherPluginWindows = opts.hideOtherPluginWindows || true,\n      runCallback = opts.runCallback || true;\n\n    // Let the App know which tool is currently active\n    this.props.app.activeTool = this.type;\n\n    // Tell the Analytics model about this\n    this.props.app.globalObserver.publish(\"analytics.trackEvent\", {\n      eventName: \"pluginShown\",\n      pluginName: this.type,\n      activeMap: this.props.app.config.activeMap,\n    });\n\n    // Don't continue if visibility hasn't changed\n    if (this.state.windowVisible === true) {\n      return null;\n    }\n\n    hideOtherPluginWindows === true && this.props.app.onWindowOpen(this);\n\n    this.setState(\n      {\n        windowVisible: true,\n      },\n      () => {\n        // If there's a callback defined in custom, run it\n        runCallback === true &&\n          typeof this.props.custom.onWindowShow === \"function\" &&\n          this.props.custom.onWindowShow();\n      }\n    );\n  };\n\n  closeWindow = () => {\n    // If closeWindow was initiated by the tool that is currently\n    // active, we should unset the activeTool property\n    if (this.type === this.props.app.activeTool)\n      this.props.app.activeTool = undefined;\n\n    this.setState(\n      {\n        windowVisible: false,\n      },\n      () => {\n        typeof this.props.custom.onWindowHide === \"function\" &&\n          this.props.custom.onWindowHide();\n      }\n    );\n  };\n  /**\n   * @summary Render the plugin and its buttons according to settings in admin.\n   * @description See comments in code to follow the rendering logic.\n   * @param {*} custom\n   * @returns {object} React.Component\n   * @memberof BaseWindowPlugin\n   */\n  renderWindow(custom) {\n    const { target } = this.props.options;\n    // BaseWindowPlugin, which calls this method, will supply an object.\n    // If that object contains a render() function, we want to call it\n    // and bypass any other functionality from this method.\n    return typeof custom?.render === \"function\" ? (\n      custom.render()\n    ) : (\n      // If there was not custom render method, we do \"normal\" rendering.\n      // That includes rendering the plugin Window itself, as well as a\n      // button (that will trigger opening of the plugin Window).\n      <>\n        <Window\n          globalObserver={this.props.app.globalObserver}\n          title={this.state.title}\n          color={this.state.color}\n          onClose={this.closeWindow}\n          open={this.state.windowVisible}\n          onResize={this.props.custom.onResize}\n          onMaximize={this.props.custom.onMaximize}\n          onMinimize={this.props.custom.onMinimize}\n          draggingEnabled={this.props.custom.draggingEnabled}\n          customPanelHeaderButtons={this.props.custom.customPanelHeaderButtons}\n          resizingEnabled={this.props.custom.resizingEnabled}\n          scrollable={this.props.custom.scrollable}\n          allowMaximizedWindow={this.props.custom.allowMaximizedWindow}\n          disablePadding={this.props.custom.disablePadding}\n          width={this.width}\n          height={this.height}\n          position={this.position}\n          mode=\"window\"\n          layerswitcherConfig={this.props.app.config.mapConfig.tools.find(\n            (t) => t.type === \"layerswitcher\"\n          )}\n        >\n          {/* We have to pass windowVisible down to the children so that we can conditionally render\n          the <Tabs /> component, since it does not accept components with display: \"none\". We use the\n          windowVisible-prop to make sure that we don't render the <Tabs /> when the window\n          is not visible.*/}\n          {React.cloneElement(this.props.children, {\n            windowVisible: this.state.windowVisible,\n          })}\n        </Window>\n        {/* Drawer buttons and Widget buttons should render a Drawer button. */}\n        {(target === \"toolbar\" || this.pluginIsWidget(target)) &&\n          this.renderDrawerButton()}\n        {/* Widget buttons must also render a Widget */}\n        {this.pluginIsWidget(target) &&\n          this.renderWidgetButton(`${target}-column`)}\n        {/* Finally, render a Control button if target has that value */}\n        {target === \"control\" && this.renderControlButton()}\n      </>\n    );\n  }\n\n  /**\n   * This is a bit of a special case. This method will render\n   * not only plugins specified as Drawer plugins (target===toolbar),\n   * but it will also render Widget plugins - given some special condition.\n   *\n   * Those special conditions are small screens, where there's no screen\n   * estate to render the Widget button in Map Overlay.\n   */\n  renderDrawerButton() {\n    return createPortal(\n      <Hidden mdUp={this.pluginIsWidget(this.props.options.target)}>\n        <ListItem\n          button\n          divider={true}\n          selected={this.state.windowVisible}\n          onClick={this.handleButtonClick}\n        >\n          <ListItemIcon>{this.props.custom.icon}</ListItemIcon>\n          <ListItemText primary={this.title} />\n        </ListItem>\n      </Hidden>,\n      document.getElementById(\"plugin-buttons\")\n    );\n  }\n\n  renderWidgetButton(id) {\n    return createPortal(\n      // Hide Widget button on small screens, see renderDrawerButton too\n      <Hidden mdDown>\n        <Card\n          icon={this.props.custom.icon}\n          onClick={this.handleButtonClick}\n          title={this.title}\n          abstract={this.description}\n        />\n      </Hidden>,\n      document.getElementById(id)\n    );\n  }\n\n  renderControlButton() {\n    return createPortal(\n      <PluginControlButton\n        icon={this.props.custom.icon}\n        onClick={this.handleButtonClick}\n        title={this.title}\n        abstract={this.description}\n      />,\n      document.getElementById(\"plugin-control-buttons\")\n    );\n  }\n\n  render() {\n    // Don't render if \"clean\" query param is specified, otherwise go on\n    return (\n      this.props.app.config.mapConfig.map.clean !== true &&\n      this.renderWindow(this.props.custom)\n    );\n  }\n}\n\nexport default BaseWindowPlugin;\n","import React from \"react\";\nimport Observer from \"react-event-observer\";\nimport FmeIcon from \"@mui/icons-material/BrokenImage\";\n\n// Views\nimport BaseWindowPlugin from \"../BaseWindowPlugin\";\nimport FmeView from \"./FmeServerView\";\n\n// Models\nimport FmeServerModel from \"./models/FmeServerModel\";\nimport MapViewModel from \"./models/MapViewModel\";\n\nconst FmeServer = (props) => {\n  // The local observer will handle the communication between models and views.\n  const localObserver = Observer();\n\n  // A model used to interact with the map. We want to keep the view free\n  // from direct map interactions.\n  const mapViewModel = new MapViewModel({\n    localObserver: localObserver,\n    map: props.map,\n    options: props.options,\n  });\n\n  // A model used to interact with the FME-server instance etc. We want to\n  // keep the view free from direct interactions with the server.\n  const fmeServerModel = new FmeServerModel({\n    localObserver: localObserver,\n    app: props.app,\n    mapViewModel: mapViewModel,\n    options: props.options,\n  });\n\n  // We're gonna need to catch if the user closes the window, and make sure to\n  // disable the draw interaction if it is active. Let's publish a couple events.\n  const onWindowHide = () => {\n    localObserver.publish(\"view.toggleDrawMethod\", \"\");\n    localObserver.publish(\"map.toggleDrawMethod\", \"\");\n  };\n\n  // We're rendering the view in a BaseWindowPlugin, since this is a\n  // \"standard\" plugin.\n  return (\n    <BaseWindowPlugin\n      {...props}\n      type=\"FmeServer\"\n      custom={{\n        icon: <FmeIcon />,\n        title: \"FME-server\",\n        description: \"Beställ jobb från FME-server.\",\n        height: \"dynamic\",\n        width: 400,\n        onWindowHide: onWindowHide,\n      }}\n    >\n      <FmeView\n        model={fmeServerModel}\n        mapViewModel={mapViewModel}\n        options={props.options}\n        localObserver={localObserver}\n      />\n    </BaseWindowPlugin>\n  );\n};\n\nexport default FmeServer;\n","import { hfetch } from \"../../../utils/FetchWrapper\";\n\nclass FmeServerModel {\n  #options;\n  #mapServiceBase;\n  #mapViewModel;\n  #activeUserEmail;\n\n  constructor(settings) {\n    this.#options = settings.options;\n    this.#mapServiceBase = settings.app.config.appConfig.mapserviceBase;\n    this.#activeUserEmail = settings.app.config.userDetails?.mail ?? \"\";\n    this.#mapViewModel = settings.mapViewModel;\n  }\n\n  // A get:er to return the active user:s email.\n  getActiveUserEmail = () => {\n    return this.#activeUserEmail;\n  };\n\n  // Returns the product matching the group and product name.\n  getProduct = (groupName, productName) => {\n    if (groupName?.length === 0 || productName?.length === 0) {\n      return null;\n    }\n    return this.#options.products.find((product) => {\n      return product.group === groupName && product.name === productName;\n    });\n  };\n\n  // Entry point for when user clicks the \"Order\" button.\n  // We're targeting different FME-server endpoints determined by wether\n  // The userEmail has been supplied or not. (If the userEmail is supplied\n  // it means that the admin has registered the product as an data-download\n  // product rather than a product that should target the regular FME-server REST-API).\n  makeOrder = (groupName, productName, productParameters, userEmail) => {\n    // We're gonna need the product\n    const product = this.getProduct(groupName, productName);\n    // If user email is supplied and prompted for, it means that we are dealing\n    // with data-download, not the ordinary REST-api.\n    // The user email might not be an empty string if AD-lookup is enabled\n    // and user-details are exposed to the client, which means that we must\n    // check that the product is set to prompt for email as well.\n    if (userEmail !== \"\" && product.promptForEmail) {\n      return this.#makeDataDownloadOrder(product, productParameters, userEmail);\n    }\n    // If it is not, we're dealing with the regular REST-application\n    return this.#makeRestApiOrder(product, productParameters);\n  };\n\n  // Creates a string to be used for the data-download request\n  // Built upon the userEmail and the parameterValues.\n  #createRequestUrlString = (product, productParameters, userEmail) => {\n    // We're gonna need some base information in the request string, let's add\n    // that first.\n    let requestString = `opt_servicemode=async&opt_responseformat=json&opt_requesteremail=${userEmail}&`;\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add it to the request string.\n      requestString += `${product.geoAttribute}=${geoJson}&`;\n    }\n    productParameters.forEach((parameter) => {\n      requestString += `${this.#getParameterNameValueString(parameter)}&`;\n    });\n    // Then we return the string!\n    return requestString;\n  };\n\n  // Returns a name value string for the supplied parameter\n  #getParameterNameValueString = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All above should be clean strings... TODO: Tests!\n        return `${parameter.name}=${\n          parameter.value ?? parameter.defaultValue ?? \"\"\n        }`;\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These should be array of strings...\n        const selectedArray = parameter.value ?? parameter.defaultValue ?? [];\n        // If the array is empty, we can return an empty string\n        if (selectedArray.length === 0) {\n          return `${parameter.name}=`;\n        }\n        // Otherwise we concatenate a string with all selected values.\n        const urlString = `${parameter.name}=${selectedArray.join(\",\")}`;\n        return urlString;\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return `${parameter.name}=${value}`;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Checks wether the geoAttribute contains a valid value.\n  // (An empty string or \"none\" is to be considered as no geoAttribute\n  // wa supplied).\n  noGeomAttributeSupplied = (product) => {\n    return (\n      !product ||\n      !product.geoAttribute ||\n      product.geoAttribute === \"\" ||\n      product.geoAttribute === \"none\"\n    );\n  };\n\n  // Returns a stepSize that corresponds to the supplied decimalPrecision\n  // E.g. decimalPrecision: 0 => step: 1,\n  //      decimalPrecision: 1 => step: 0.1,\n  //      decimalPrecision: 2 => step: 0.01\n  #getStepSize = (decimalPrecision) => {\n    // Special case, 0 precision should just return 1\n    if (decimalPrecision === 0) {\n      return 1;\n    }\n    // Otherwise we use the padStart string function to create\n    // a float with a fitting number of decimals.\n    return Number(`0.${\"1\".padStart(decimalPrecision, \"0\")}`);\n  };\n\n  // Calculates a fitting stepSize and fetches the current value for\n  // the range slider.\n  getRangeSliderValueAndStep = (parameter) => {\n    // First we get a stepSize that fits the decimalPrecision supplied\n    const step = this.#getStepSize(parameter.decimalPrecision);\n    // Then we get the parameter value (that might be set) or return the\n    // minimum (or the step over the minimum if that should be excluded).\n    const value =\n      parameter.value ?? this.getRangeSliderMinimum(parameter, step);\n    // And return everything\n    return { value, step };\n  };\n\n  // Returns the range slider minimum or the step above if\n  // minimum should be excluded.\n  getRangeSliderMinimum = (parameter, step) => {\n    return parameter.minimumExclusive\n      ? parameter.minimum + step\n      : parameter.minimum;\n  };\n\n  // Returns the range slider maximum or the step below if\n  // minimum should be excluded.\n  getRangeSliderMaximum = (parameter, step) => {\n    return parameter.maximumExclusive\n      ? parameter.maximum - step\n      : parameter.maximum;\n  };\n\n  // Returns the value of the parameter supplied.\n  // Since the parameter types expects different fallback values\n  // we'll have to handle them differently.\n  #getParameterValue = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All of the above expects a single string\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These expect an array of strings\n        return parameter.value ?? parameter.defaultValue ?? [];\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return value;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Returns all parameters with their values in the format that\n  // FME-server expects.\n  #getParametersToSend = (product, productParameters) => {\n    // Initiate an array where all parameter objects will be pushed\n    const parametersToSend = [];\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add the geoAttribute with it's GeoJSON to the array\n      parametersToSend.push({ name: product.geoAttribute, value: geoJson });\n    }\n    // Then we get all other values and add them to the array\n    productParameters.forEach((parameter) => {\n      const value = this.#getParameterValue(parameter);\n      parametersToSend.push({ name: parameter.name, value: value });\n    });\n    // And return the array.\n    return parametersToSend;\n  };\n\n  // Returns all parameters except the one parameter stated\n  // to be the one containing the geometry.\n  getParametersToRender = (parameters, groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty array\n    if (!product) {\n      return [];\n    }\n    // Otherwise we return the filtered parameters, where the parameter\n    // with the geomAttribute as name is removed.\n    return parameters.filter((parameter) => {\n      return parameter.name !== product.geoAttribute;\n    });\n  };\n\n  getInfoUrl = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty string\n    if (!product) {\n      return \"\";\n    }\n    // Then we'll return the infoUrl, or an empty string if it's missing.\n    return product.infoUrl ?? \"\";\n  };\n\n  // Checks wether we should prompt the user for their email or not\n  shouldPromptForEmail = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return false\n    if (!product) {\n      return false;\n    }\n    // Otherwise we return the parameter containing information regarding\n    // email prompting\n    return product.promptForEmail;\n  };\n\n  // Check wethers the provided string is a valid email\n  isValidEmail = (emailString) => {\n    if (typeof emailString !== \"string\") {\n      return false;\n    }\n    const regExp = /\\S+@\\S+\\.\\S+/;\n    return regExp.test(emailString);\n  };\n\n  // Fetches all product parameters from FME-server\n  getProductParameters = async (groupName, productName) => {\n    // If the product is missing for some reason, we return an\n    // error and an empty array.\n    const product = this.getProduct(groupName, productName);\n    if (!product) {\n      return { error: true, parameters: [] };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createGetParametersUrl(product);\n    // And then try to fetch the parameters using the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, parameters: data };\n    } catch (error) {\n      return { error: true, parameters: [] };\n    }\n  };\n\n  // Posts a request to run a workspace on FME-server via the REST-API.\n  // Returns an object containing eventual error and eventual\n  // jobId which can be used to check the status of the job.\n  #makeRestApiOrder = async (product, productParameters) => {\n    // First, we're gonna have to prepare the parameters to send.\n    const parametersToSend = this.#getParametersToSend(\n      product,\n      productParameters\n    );\n    // Let's create the request url\n    const url = this.#createSubmitProductRequestUrl(product);\n    // And the body containing all the parameters\n    const body = JSON.stringify({ publishedParameters: parametersToSend });\n    // And then try to submit the job using that url...\n    try {\n      const response = await hfetch(url, {\n        method: \"POST\",\n        body: body,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data.id ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Handles the data-download order\n  #makeDataDownloadOrder = async (product, productParameters, userEmail) => {\n    // Let's create the base-url for the request.\n    const requestUrl = this.#createDataDownloadUrl(product);\n    // The data-download does not expect the parameters to be be sent\n    // as json. So let's create a string instead TODO: Is this really true?\n    const requestUrlString = this.#createRequestUrlString(\n      product,\n      productParameters,\n      userEmail\n    );\n    // Then we try to fetch with this information\n    try {\n      const response = await hfetch(requestUrl, {\n        method: \"POST\",\n        body: requestUrlString,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data?.serviceResponse?.jobID ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Fetches the status for a submitted job\n  getJobStatusById = async (jobId) => {\n    // If the jobId is missing, we return an error.\n    if (!jobId) {\n      return { error: true, status: null };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createProductStatusUrl(jobId);\n    // And then try to fetch the status with the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, status: data?.status ?? null };\n    } catch (error) {\n      return { error: true, status: null };\n    }\n  };\n\n  // Returns the url needed to fetch the product parameters from FME-server.\n  #createGetParametersUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmerest/v3/repositories/${\n      product.repository\n    }/items/${product.workspace}/parameters/`;\n  };\n\n  // Returns the url needed to post a request to start a workspace.\n  #createSubmitProductRequestUrl = (product) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/submit/${product.repository}/${\n      product.workspace\n    }/`;\n  };\n\n  // Returns the base url used to post a request to submit a\n  // data-download job.\n  #createDataDownloadUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmedatadownload/${\n      product.repository\n    }/${product.workspace}/`;\n  };\n\n  // Returns the url needed to fetch information about a submitted job.\n  // The required parameter, jobId is a string returned when queuing a job.\n  #createProductStatusUrl = (jobId) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/jobs/id/${jobId}/`;\n  };\n}\nexport default FmeServerModel;\n"],"names":["StyledCard","styled","MUICard","theme","marginBottom","spacing","width","breakpoints","down","boxShadow","borderBottom","borderRadius","margin","justifyContent","StyledAvatar","Avatar","background","palette","text","primary","Card","state","open","this","props","abstract","icon","onClick","title","avatar","subheader","React","defaultProps","BaseWindowPlugin","handleButtonClick","e","showWindow","hideOtherPluginWindows","runCallback","app","globalObserver","publish","opts","activeTool","type","eventName","pluginName","activeMap","config","windowVisible","onWindowOpen","setState","custom","onWindowShow","closeWindow","undefined","onWindowHide","toLowerCase","description","options","visibleAtStart","mapConfig","map","clean","isMobile","visibleAtStartMobile","color","height","position","registerWindowPlugin","subscribe","closeEventName","prevProps","target","includes","render","onClose","onResize","onMaximize","onMinimize","draggingEnabled","customPanelHeaderButtons","resizingEnabled","scrollable","allowMaximizedWindow","disablePadding","mode","layerswitcherConfig","tools","find","t","children","pluginIsWidget","renderDrawerButton","renderWidgetButton","renderControlButton","createPortal","mdUp","button","divider","selected","document","getElementById","id","mdDown","renderWindow","localObserver","Observer","mapViewModel","MapViewModel","fmeServerModel","FmeServerModel","model","settings","getActiveUserEmail","getProduct","groupName","productName","length","products","product","group","name","makeOrder","productParameters","userEmail","promptForEmail","requestString","noGeomAttributeSupplied","geoJson","getAllFeaturesAsGeoJson","geoAttribute","forEach","parameter","value","defaultValue","selectedArray","join","getRangeSliderValueAndStep","decimalPrecision","Number","padStart","step","getRangeSliderMinimum","minimumExclusive","minimum","getRangeSliderMaximum","maximumExclusive","maximum","parametersToSend","push","getParametersToRender","parameters","filter","getInfoUrl","infoUrl","shouldPromptForEmail","isValidEmail","emailString","test","getProductParameters","error","url","hfetch","response","json","data","body","JSON","stringify","publishedParameters","method","credentials","headers","jobId","requestUrl","requestUrlString","serviceResponse","jobID","getJobStatusById","status","repository","workspace","appConfig","mapserviceBase","userDetails","mail"],"sourceRoot":""}