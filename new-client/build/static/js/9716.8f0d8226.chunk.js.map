{"version":3,"file":"static/js/9716.8f0d8226.chunk.js","mappings":"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","sources":["plugins/Location/LocationModel.js","../node_modules/ol/Geolocation.js"],"sourcesContent":["import Geolocation from \"ol/Geolocation.js\";\nimport Feature from \"ol/Feature.js\";\nimport Point from \"ol/geom/Point.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { easeOut } from \"ol/easing\";\nimport { getVectorContext } from \"ol/render\";\nimport { unByKey } from \"ol/Observable\";\nimport { Circle as CircleStyle, Fill, Stroke, Style } from \"ol/style.js\";\n\nclass LocationModel {\n  constructor(props) {\n    this.map = props.map;\n    this.localObserver = props.localObserver;\n    this.zoomToLocation = true;\n\n    // Create source and layer and add to map. Later on we'll draw features to this layer.\n    this.source = new VectorSource({ wrapX: false });\n    this.layer = new VectorLayer({\n      source: this.source,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginLocation\",\n      caption: \"Location layer\",\n    });\n    this.map.addLayer(this.layer);\n\n    // Create two features: one for position (point) and\n    // another one for position accuracy (outer ring)\n    this.accuracyFeature = new Feature();\n    this.positionFeature = new Feature();\n    this.positionFeature.setStyle(\n      new Style({\n        image: new CircleStyle({\n          radius: 6,\n          fill: new Fill({\n            color: \"#3399CC\",\n          }),\n          stroke: new Stroke({\n            color: \"#fff\",\n            width: 2,\n          }),\n        }),\n      })\n    );\n\n    // Init geolocation layer where the point will be drawn to\n    this.geolocation = new Geolocation({\n      trackingOptions: {\n        enableHighAccuracy: true,\n      },\n      projection: this.map.getView().getProjection(),\n    });\n\n    // Set up some event handlers for our Geolocation object\n    this.geolocation.on(\"change\", this.handleGeolocationChange);\n    this.geolocation.on(\"error\", this.handleGeolocationError);\n    this.geolocation.on(\n      \"change:accuracyGeometry\",\n      this.handleGeolocationChangeAccuracy\n    );\n    this.geolocation.on(\n      \"change:position\",\n      this.handleGeolocationChangePosition\n    );\n  }\n\n  handleGeolocationChange = (e) => {\n    this.localObserver.publish(\"geolocationChange\", {\n      accuracy: e.target.getAccuracy(),\n      altitude: e.target.getAltitude(),\n      altitudeAccuracy: e.target.getAltitudeAccuracy(),\n      heading: e.target.getHeading(),\n      speed: e.target.getSpeed(),\n    });\n  };\n\n  handleGeolocationError = (error) => {\n    this.localObserver.publish(\"locationStatus\", \"error\");\n    // Yeah, it's clumsy but we want to send another event\n    // with the error object, so the first event is not enough.\n    this.localObserver.publish(\"geolocationError\", error);\n  };\n\n  handleGeolocationChangeAccuracy = (e) => {\n    this.accuracyFeature.setGeometry(e.target.getAccuracyGeometry());\n  };\n\n  handleGeolocationChangePosition = (e) => {\n    const coordinates = e.target.getPosition();\n    this.positionFeature.setGeometry(\n      coordinates ? new Point(coordinates) : null\n    );\n\n    // If we've got new coordinates, make sure to hide the loading indicator\n    this.localObserver.publish(\"locationStatus\", \"on\");\n\n    if (this.zoomToLocation) {\n      const maxZoom = this.map.getView().getMaxZoom();\n      const minZoom = this.map.getView().getMinZoom();\n      const zoom = Math.ceil((maxZoom - minZoom) * 0.5); // Let's end up in the middle zoom\n      this.map.getView().animate({ duration: 2500, center: coordinates, zoom });\n      this.zoomToLocation = false;\n    }\n  };\n\n  toggleTracking = (active) => {\n    // Inform the View components that we're loading\n    this.localObserver.publish(\"locationStatus\", active ? \"loading\" : \"off\");\n\n    this.geolocation.setTracking(active);\n\n    // If deactivating, cleanup\n    if (active === false) {\n      // Remove features from map if tracking has been switched off\n      this.layer.getSource().clear();\n      // Make sure that we zoom to location next time tracking is activated\n      this.zoomToLocation = true;\n    }\n    // If activating, add two features to map:\n    // one for accuracy (the outer ring) and one for position (inner point)\n    else {\n      this.layer.getSource().addFeature(this.accuracyFeature);\n      this.layer.getSource().addFeature(this.positionFeature);\n\n      // Finally, start flashing the position feature\n      setInterval(() => {\n        this.flash(this.positionFeature);\n      }, 3000);\n    }\n  };\n\n  // Flash handler: sets up the animation and creats a handler for the postrender\n  flash = (feature) => {\n    // Helper: takes care of the actual animation.\n    const animate = (event) => {\n      // Event is the postrender event that happens - surprise - after render,\n      // because we actually tell the map to render (see at the end of this function)\n      const frameState = event.frameState;\n      const elapsed = frameState.time - start;\n      if (elapsed >= duration) {\n        // Remove the listener when time has elapsed\n        unByKey(listenerKey);\n        return;\n      }\n\n      // Grab the context that will hold our animated feature\n      const vectorContext = getVectorContext(event);\n      const elapsedRatio = elapsed / duration;\n\n      // Radius will be 5 at start and 30 at end\n      const radius = easeOut(elapsedRatio) * 25 + 5;\n      const opacity = easeOut(1 - elapsedRatio);\n\n      const style = new Style({\n        image: new CircleStyle({\n          radius: radius,\n          stroke: new Stroke({\n            color: \"rgba(255, 0, 0, \" + opacity + \")\",\n            width: 0.25 + opacity,\n          }),\n        }),\n      });\n\n      vectorContext.setStyle(style);\n      vectorContext.drawGeometry(flashGeom);\n\n      // This ensure that the listener for postrender will be triggered\n      this.map.render();\n    };\n\n    // Setup the animation\n    const duration = 3000;\n    const start = Date.now();\n    // Prepare the feature that will get animated\n    const flashGeom = feature.getGeometry().clone();\n    // Save the listener key so we can unsubscribe when animation is done\n    const listenerKey = this.layer.on(\"postrender\", animate);\n  };\n\n  enable() {\n    this.toggleTracking(true);\n  }\n\n  disable() {\n    this.toggleTracking(false);\n  }\n}\n\nexport default LocationModel;\n","/**\n * @module ol/Geolocation\n */\nimport BaseEvent from './events/Event.js';\nimport BaseObject from './Object.js';\nimport EventType from './events/EventType.js';\nimport {circular as circularPolygon} from './geom/Polygon.js';\nimport {\n  get as getProjection,\n  getTransformFromProjections,\n  identityTransform,\n} from './proj.js';\nimport {toRadians} from './math.js';\n\n/**\n * @enum {string}\n */\nconst Property = {\n  ACCURACY: 'accuracy',\n  ACCURACY_GEOMETRY: 'accuracyGeometry',\n  ALTITUDE: 'altitude',\n  ALTITUDE_ACCURACY: 'altitudeAccuracy',\n  HEADING: 'heading',\n  POSITION: 'position',\n  PROJECTION: 'projection',\n  SPEED: 'speed',\n  TRACKING: 'tracking',\n  TRACKING_OPTIONS: 'trackingOptions',\n};\n\n/**\n * @classdesc\n * Events emitted on Geolocation error.\n */\nclass GeolocationError extends BaseEvent {\n  /**\n   * @param {GeolocationPositionError} error error object.\n   */\n  constructor(error) {\n    super(EventType.ERROR);\n\n    /**\n     * @type {number}\n     */\n    this.code = error.code;\n\n    /**\n     * @type {string}\n     */\n    this.message = error.message;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [tracking=false] Start Tracking right after\n * instantiation.\n * @property {PositionOptions} [trackingOptions] Tracking options.\n * See https://www.w3.org/TR/geolocation-API/#position_options_interface.\n * @property {import(\"./proj.js\").ProjectionLike} [projection] The projection the position\n * is reported in.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|\n *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|\n *    'change:trackingOptions'} GeolocationObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<GeolocationObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").OnSignature<'error', GeolocationError, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|GeolocationObjectEventTypes|\n *     'error', Return>} GeolocationOnSignature\n */\n\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)\n * is used to locate a user's position.\n *\n * To get notified of position changes, register a listener for the generic\n * `change` event on your instance of {@link module:ol/Geolocation~Geolocation}.\n *\n * Example:\n *\n *     const geolocation = new Geolocation({\n *       // take the projection to use from the map's view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on('change', function(evt) {\n *       window.console.log(geolocation.getPosition());\n *     });\n *\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nclass Geolocation extends BaseObject {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GeolocationOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GeolocationOnSignature<void>}\n     */\n    this.un;\n\n    options = options || {};\n\n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {?import(\"./coordinate.js\").Coordinate}\n     */\n    this.position_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./proj.js\").TransformFunction}\n     */\n    this.transform_ = identityTransform;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.watchId_ = undefined;\n\n    this.addChangeListener(Property.PROJECTION, this.handleProjectionChanged_);\n    this.addChangeListener(Property.TRACKING, this.handleTrackingChanged_);\n\n    if (options.projection !== undefined) {\n      this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== undefined) {\n      this.setTrackingOptions(options.trackingOptions);\n    }\n\n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.setTracking(false);\n    super.disposeInternal();\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    const projection = this.getProjection();\n    if (projection) {\n      this.transform_ = getTransformFromProjections(\n        getProjection('EPSG:4326'),\n        projection\n      );\n      if (this.position_) {\n        this.set(Property.POSITION, this.transform_(this.position_));\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleTrackingChanged_() {\n    if ('geolocation' in navigator) {\n      const tracking = this.getTracking();\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(\n          this.positionChange_.bind(this),\n          this.positionError_.bind(this),\n          this.getTrackingOptions()\n        );\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPosition} position position event.\n   */\n  positionChange_(position) {\n    const coords = position.coords;\n    this.set(Property.ACCURACY, coords.accuracy);\n    this.set(\n      Property.ALTITUDE,\n      coords.altitude === null ? undefined : coords.altitude\n    );\n    this.set(\n      Property.ALTITUDE_ACCURACY,\n      coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy\n    );\n    this.set(\n      Property.HEADING,\n      coords.heading === null ? undefined : toRadians(coords.heading)\n    );\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    const projectedPosition = this.transform_(this.position_);\n    this.set(Property.POSITION, projectedPosition);\n    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);\n    const geometry = circularPolygon(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  }\n\n  /**\n   * @private\n   * @param {GeolocationPositionError} error error object.\n   */\n  positionError_(error) {\n    this.dispatchEvent(new GeolocationError(error));\n  }\n\n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAccuracy() {\n    return /** @type {number|undefined} */ (this.get(Property.ACCURACY));\n  }\n\n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?import(\"./geom/Polygon.js\").default} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n  getAccuracyGeometry() {\n    return /** @type {?import(\"./geom/Polygon.js\").default} */ (\n      this.get(Property.ACCURACY_GEOMETRY) || null\n    );\n  }\n\n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n  getAltitude() {\n    return /** @type {number|undefined} */ (this.get(Property.ALTITUDE));\n  }\n\n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n  getAltitudeAccuracy() {\n    return /** @type {number|undefined} */ (\n      this.get(Property.ALTITUDE_ACCURACY)\n    );\n  }\n\n  /**\n   * Get the heading as radians clockwise from North.\n   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`\n   * is set to `true` in the tracking options.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n  getHeading() {\n    return /** @type {number|undefined} */ (this.get(Property.HEADING));\n  }\n\n  /**\n   * Get the position of the device.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the projection associated with the position.\n   * @return {import(\"./proj/Projection.js\").default|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return /** @type {import(\"./proj/Projection.js\").default|undefined} */ (\n      this.get(Property.PROJECTION)\n    );\n  }\n\n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n  getSpeed() {\n    return /** @type {number|undefined} */ (this.get(Property.SPEED));\n  }\n\n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n  getTracking() {\n    return /** @type {boolean} */ (this.get(Property.TRACKING));\n  }\n\n  /**\n   * Get the tracking options.\n   * See https://www.w3.org/TR/geolocation-API/#position-options.\n   * @return {PositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  getTrackingOptions() {\n    return /** @type {PositionOptions|undefined} */ (\n      this.get(Property.TRACKING_OPTIONS)\n    );\n  }\n\n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {import(\"./proj.js\").ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(Property.PROJECTION, getProjection(projection));\n  }\n\n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n  setTracking(tracking) {\n    this.set(Property.TRACKING, tracking);\n  }\n\n  /**\n   * Set the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @param {PositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n  setTrackingOptions(options) {\n    this.set(Property.TRACKING_OPTIONS, options);\n  }\n}\n\nexport default Geolocation;\n"],"names":["LocationModel","props","handleGeolocationChange","e","localObserver","publish","accuracy","target","getAccuracy","altitude","getAltitude","altitudeAccuracy","getAltitudeAccuracy","heading","getHeading","speed","getSpeed","handleGeolocationError","error","handleGeolocationChangeAccuracy","accuracyFeature","setGeometry","getAccuracyGeometry","handleGeolocationChangePosition","coordinates","getPosition","positionFeature","Point","zoomToLocation","maxZoom","map","getView","getMaxZoom","minZoom","getMinZoom","zoom","Math","ceil","animate","duration","center","toggleTracking","active","geolocation","setTracking","layer","getSource","clear","addFeature","setInterval","flash","feature","start","Date","now","flashGeom","getGeometry","clone","listenerKey","on","event","elapsed","frameState","time","unByKey","vectorContext","getVectorContext","elapsedRatio","radius","easeOut","opacity","style","Style","image","CircleStyle","stroke","Stroke","color","width","setStyle","drawGeometry","render","this","source","VectorSource","wrapX","VectorLayer","layerType","zIndex","name","caption","addLayer","Feature","fill","Fill","Geolocation","trackingOptions","enableHighAccuracy","projection","getProjection","Property","GeolocationError","EventType","code","message","BaseEvent","options","once","un","position_","transform_","identityTransform","watchId_","undefined","addChangeListener","handleProjectionChanged_","handleTrackingChanged_","setProjection","setTrackingOptions","tracking","getTransformFromProjections","set","navigator","getTracking","watchPosition","positionChange_","bind","positionError_","getTrackingOptions","clearWatch","position","coords","toRadians","longitude","latitude","projectedPosition","geometry","circularPolygon","applyTransform","changed","dispatchEvent","get","BaseObject"],"sourceRoot":""}