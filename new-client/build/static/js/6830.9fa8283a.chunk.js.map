{"version":3,"file":"static/js/6830.9fa8283a.chunk.js","mappings":"0iBAoBqBA,EAAAA,WACnB,WAAYC,GAAW,IAAD,sCA6CtBC,gBAAkB,CAChB,IAAK,IACL,IAAK,EACL,IAAK,GACL,IAAK,GACL,IAAK,GACL,IAAM,GACN,IAAM,GACN,KAAM,IACN,IAAM,IACN,IAAO,IACP,KAAO,IACP,IAAO,KACP,IAAQ,IACR,IAAQ,KA3DY,KA8DtBC,aAAe,KA9DO,KA+DtBC,eAAiB,KA/DK,KAmEtBC,aAAe,IAnEO,KAqEtBC,qBAAuB,IArED,KAwEtBC,OAAS,EAxEa,KA0EtBC,gBAAkB,EA1EI,KA4EtBC,UAAY,EA5EU,KA+EtBC,qBAAuB,KA/ED,KAqGtBC,YAAc,WAIZ,EAAKC,UAAUC,QAAQ,EAAKC,aAAaC,WAGzC,IACEC,EAAM,EAAKJ,UAAUK,gBAAgBC,mBAIvC,OAFQ,EAAKN,UAAUO,gBAEVH,EAHM,OAFP,KAAO,IAMpB,EAlHqB,KAoHtBI,gBAAkB,WAEhB,IAAMC,EAAgB,EAAKV,cAG3B,OAAO,EAAKW,OAAOC,QAAO,SAACC,EAAMC,GAC/B,OAAOC,KAAKC,IAAIF,EAAOJ,GAAiBK,KAAKC,IAAIH,EAAOH,GACpDI,EACAD,CACL,GACF,EA9HqB,KAgItBI,cAAgB,WACd,EAAKxB,oBAAiByB,EACtB,EAAK1B,aAAa2B,YAAYC,QAC9B,EAAKC,IAAIC,kBAAkB,EAAKC,UACjC,EApIqB,KAsItBC,iBAAmB,WACjB,IAAMC,EAAS,EAAKhC,eAAeiC,cAAcC,YACjD,OAAOC,EAAAA,EAAAA,WAAUH,EAClB,EAzIqB,KA6ItBI,UAAY,SAACC,EAAUpC,GAErB,OAAOA,EADaqB,KAAKgB,IAAL,MAAAhB,MAAI,OAAQe,GAEjC,EAhJqB,KAoJtBE,YAAc,SAACC,EAAQC,GACrB,MAAuB,aAAhBA,GACH,OAAI,EAAKC,KAAKF,IAASG,UACvB,EAAKD,KAAKF,EACf,EAxJqB,KAuOtBI,qBAAuB,SAACC,EAAqBC,GACvCD,EACF,EAAKE,WAAWD,GAEhB,EAAKtB,eAER,EA7OqB,KAsPtBwB,wBAA0B,SAACC,GACzB,OAAO,IAAIC,SAAQ,SAACC,EAASC,GAC3B,IAAMC,EAAQ,IAAIC,MAClBD,EAAME,aAAa,cAAe,aAGlCF,EAAMG,QAAU,SAAUC,GACxBL,EAAOK,EACR,EAGDJ,EAAMK,OAAS,WACb,IAAMC,EAAYC,SAASC,cAAc,UACzCF,EAAUG,MAAQC,KAAKC,aACvBL,EAAUM,OAASF,KAAKG,cAGxBP,EAAUQ,WAAW,MAAMC,UAAUL,KAAM,EAAG,GAE9CZ,EAAQ,CACNkB,KAAMV,EAAUW,UAAU,aAC1BR,MAAOH,EAAUG,MACjBG,OAAQN,EAAUM,QAErB,EAGDZ,EAAMkB,IAAMtB,CACb,GACF,EAnRqB,KA2RtBuB,sBA3RsB,mCA2RE,WAAOvB,EAAKwB,GAAZ,mGAMZ,EAAKzB,wBAAwBC,GANjB,uBAGpBoB,EAHoB,EAGpBA,KACOK,EAJa,EAIpBZ,MACQa,EALY,EAKpBV,OAKIH,EAAQY,GADRE,EAAQH,EAAWC,GAEnBT,EAASU,EAAeC,EAXR,kBAYf,CAAEP,KAAAA,EAAMP,MAAAA,EAAOG,OAAAA,IAZA,4CA3RF,6DAqTtBY,aAAe,SACbC,EACAC,EACAC,EACAC,EACAC,GAIA,IAAM/E,EAAS,EAAKC,gBAAkB,EAAKD,OAEvCgF,EAAe,CAAEC,EAAG,EAAGC,EAAG,GAc9B,MAbkB,YAAdP,GACFK,EAAaC,EAAIjF,EACjBgF,EAAaE,EAAIlF,GACM,aAAd2E,GACTK,EAAaC,EAAIH,EAAWF,EAAe5E,EAC3CgF,EAAaE,EAAIlF,GACM,gBAAd2E,GACTK,EAAaC,EAAIH,EAAWF,EAAe5E,EAC3CgF,EAAaE,EAAIH,EAAYF,EAAgB7E,IAE7CgF,EAAaC,EAAIjF,EACjBgF,EAAaE,EAAIH,EAAYF,EAAgB7E,GAExCgF,CACR,EA/UqB,KAwVtBG,yBAA2B,SAACC,GAC1B,IAAMC,EAAS,EAAK1F,gBAAgByF,GACpC,OAAIC,IAGED,EAAQ,IACH,EACEA,EAAQ,KACF,IAARA,EAEQ,IAARA,EAGZ,EArWqB,KAwWtBE,cAAgB,SAACC,GACf,IAAIC,EAAQ,IAKZ,OAJID,EAAuB,MACzBA,GAAwB,IACxBC,EAAQ,MAEJ,GAAN,OAAUC,OAAOF,GAAsBG,eAAe,SAAtD,YAAkEF,EACnE,EA/WqB,KAiXtBG,aAAe,SACbC,EACAC,EACAC,EACAC,EACAX,EACAG,EACAlD,EACAC,GAEA,IAAM0D,EAAa,EAAKV,cAAcC,GACtCK,EAAIK,YAAY,GAChBL,EAAIM,QAAQ,YAAa,QACzBN,EAAIO,aAAaL,GACjBF,EAAIQ,aAAa,KACjBR,EAAIS,KACFL,EACAH,EAAiBZ,EAAIc,EAAiB,EACtCF,EAAiBX,EAAI,GAEvBU,EAAIK,YAAY,IAChBL,EAAIS,KAAJ,iBACY,EAAKC,qBACblB,GAFJ,iBAGY/C,EAAOkE,cAHnB,YAIoB,cAAhBjE,EAA8B,WAAa,aAJ/C,KAMEuD,EAAiBZ,EACjBY,EAAiBX,EAAI,GAGvBU,EAAIY,aAAaV,GACjBF,EAAIa,KACFZ,EAAiBZ,EACjBY,EAAiBX,EAAI,EACrBW,EAAiBZ,EAAIc,EACrBF,EAAiBX,EAAI,GAEvBU,EAAIa,KACFZ,EAAiBZ,EACjBY,EAAiBX,EAAI,EACrBW,EAAiBZ,EACjBY,EAAiBX,EAAI,GAEvBU,EAAIa,KACFZ,EAAiBZ,EAAIc,EACrBF,EAAiBX,EAAI,EACrBW,EAAiBZ,EAAIc,EACrBF,EAAiBX,EAAI,GAEvBU,EAAIa,KACFZ,EAAiBZ,EAAIc,EAAiB,EACtCF,EAAiBX,EAAI,IACrBW,EAAiBZ,EAAIc,EAAiB,EACtCF,EAAiBX,EAAI,IAExB,EAzaqB,KA2atBwB,YAAc,SACZd,EACAE,EACAV,EACAuB,EACAC,EACAC,EACAxE,EACAC,GAEA,IACMwE,EADqB,KACYH,EAAaE,EAC9CtB,EAAuB,EAAKJ,yBAAyBC,GAErDW,EAAiBR,EAAuBuB,EAGxCjB,EAAmB,EAAKnB,aAC5BkC,EACAb,EAAiB,EAJI,EAMrBH,EAAImB,SAASC,SAASrD,MACtBiC,EAAImB,SAASC,SAASlD,QAGxB,EAAK6B,aACHC,EACAC,EACAC,EACAC,EACAX,EACAG,EACAlD,EACAC,EAEH,EA9cqB,KAkdtB2E,sBAAwB,SAACtE,GACvB,IAAMgE,EAAahE,EAAQgE,WACrBvB,EAAQzC,EAAQyC,MAAQ,IAS9B,OAR0B,EAAK8B,mBAC7B9B,EACAuB,EACA,EAAKlF,IAAI0F,UAAUnF,cAKO,EAAK3B,UAAU+G,kBAC5C,EA9dqB,KAgetBF,mBAAqB,SAAC9B,EAAOuB,EAAYU,GACvC,OACEjC,GACAkC,EAAAA,EAAAA,IACE,EAAK7F,IAAI0F,UAAUzG,gBACnBiG,EAAa,KACbU,EAGL,EAzeqB,KA8etBE,sBAAwB,WACtB,IAAMC,EACJ/D,SAASgE,eAAe,OAAOC,MAAMC,gBACvC,MAAkC,KAA3BH,EAAgCA,EAAyB,OACjE,EAlfqB,KAqftBI,6BAA+B,WAC7B,OAAO,EAAKnG,IACToG,YACAC,WACAC,QAAO,SAACC,GACP,OAAOA,EAAMC,cAAgB,EAAKC,wBAAwBF,EAC3D,GACJ,EA5fqB,KA+ftBE,wBAA0B,SAACF,GACzB,OACGA,aAAiBG,EAAAA,GAAaH,EAAMzG,sBAAuB6G,EAAAA,GAC3DJ,aAAiBK,EAAAA,GAAcL,EAAMzG,sBAAuB+G,EAAAA,CAEhE,EApgBqB,KAugBtBC,sBAAwB,WACtB,OAAO,EAAK9G,IACToG,YACAC,WACAC,QAAO,SAACC,GACP,OACEA,EAAMC,cACND,aAAiBK,EAAAA,GACjBL,EAAMzG,sBAAuB+G,EAAAA,CAEhC,GACJ,EAlhBqB,KAshBtBE,uBAAyB,SAACR,GACxB,OAAO,EAAKvG,IACToG,YACAC,WACArG,KAAI,SAACgH,GAAD,OAAOA,EAAEC,IAAI,OAAb,IACJC,QAAQX,EAAMU,IAAI,QACtB,EA5hBqB,KAmiBtBE,cAAgB,SAACZ,GAEf,IAAK,IAAD,IAGFA,EAAMa,YAAW,GAGjB,EAAKC,aAAaC,IAAIf,GAEtB,IAAMgB,EAAShB,EAAMzG,YAKf0H,EAAc,IAAIX,EAAAA,GAAJ,kBACfU,EAAOE,iBADQ,IAElBC,WAAYH,EAAOtI,gBACnB0I,YAAW,UAAEJ,EAAOI,mBAAT,QAAwB,YACnCC,QAAO,UAAML,EAAOM,aACpB7E,MAAO,EACP8E,OAAO,KAIHC,EAAY,UAAGxB,EAAMyB,oBAAT,QAAyB,EAErCC,EAAa,IAAIrB,EAAAA,EAAW,CAChCsB,QAASH,EACTR,OAAQC,IAIJW,EAAiB,EAAKpB,uBAAuBR,GAEnD,EAAKvG,IAAIoG,YAAYgC,SAASD,EAAgBF,GAG9C,EAAKI,YAAYf,IAAIW,EAKtB,CAJC,MAAOK,GACPC,QAAQD,MAAR,2EACsEA,GAEvE,CACF,EA/kBqB,KAmlBtBE,sBAAwB,SAACnH,GACvB,OAAOA,EAAIoH,aACRxB,IAAI,QACJyB,MAAM,KACN1I,KAAI,SAAC2I,GAAD,OAAWC,WAAWD,EAAtB,GACR,EAxlBqB,KA2lBtBE,cAAgB,SAACC,EAAQC,GAEvB,IAAMC,EAAMF,EAAOvG,WAAW,MAEtBlB,EAAqC0H,EAArC1H,IAAKmC,EAAgCuF,EAAhCvF,EAAGC,EAA6BsF,EAA7BtF,EAAGwF,EAA0BF,EAA1BE,UAAWC,EAAeH,EAAfG,WAE9B,OAAO,IAAI5H,SAAQ,SAACC,EAASC,GAE3B,IAAM2H,EAAOnH,SAASC,cAAc,OACpCkH,EAAKrH,OAAS,WAEZkH,EAAIxG,UAAU2G,EAAM3F,EAAGC,EAAGwF,EAAWC,GAGrC3H,GACD,EAED4H,EAAKvH,QAAU,WACbJ,GACD,EAED2H,EAAKxB,YAAc,YAEnBwB,EAAKxG,IAAMtB,CACZ,GACF,EApnBqB,KAwnBtB+H,cAAgB,SAACC,EAAc7F,EAAGyF,GAIhC,IAFA,IAAMK,EAAQ,KAED,CAGX,IAAMC,EAAYD,EAAM/J,QAAO,SAACiK,EAAK/J,GAAN,OAAe+J,EAAM/J,EAAKyJ,UAA1B,GAAsC,GAErE,GAAIK,GAAaF,EAAc,OAAOC,EAEtC,IAAMG,EAAkBJ,EAAeE,EAEjCL,EACJO,EAAkB,EAAKC,YAAc,EAAKA,YAAcD,EAEpDhG,EAAI4F,EAAeE,EAAYL,EAErCI,EAAMK,KAAK,CACTnG,EAAAA,EACAC,EAAAA,EACAwF,UAAAA,EACAC,WAAAA,GAEH,CACF,EAjpBqB,KAypBtBU,2BAA6B,SAACT,EAAMU,EAAMxH,EAAQH,GAGhD,IAAM4H,GAA0BD,EAAK,GAAKA,EAAK,IAAMxH,EAC/C0H,GAAyBF,EAAK,GAAKA,EAAK,IAAM3H,EAMpD,MAAM,GAAN,OACE2H,EAAK,GAAKC,GAA0BzH,EAAS8G,EAAK1F,EAAI0F,EAAKD,YAD7D,YAEIW,EAAK,GAAKE,EAAwBZ,EAAK3F,EAF3C,YAGEqG,EAAK,GAAKC,GAA0BzH,EAAS8G,EAAK1F,GAHpD,aAIKoG,EAAK,GAAKE,GAAyBZ,EAAK3F,EAAI2F,EAAKF,WACvD,EAxqBqB,KA6qBtBe,yBAA2B,SAACb,EAAMU,EAAMxH,EAAQH,GAG9C,IAAM4H,GAA0BD,EAAK,GAAKA,EAAK,IAAMxH,EAC/C0H,GAAyBF,EAAK,GAAKA,EAAK,IAAM3H,EAMpD,MAAM,GAAN,OAAU2H,EAAK,GAAKE,EAAwBZ,EAAK3F,EAAjD,YACEqG,EAAK,GAAKC,GAA0BzH,EAAS8G,EAAK1F,EAAI0F,EAAKD,YAD7D,YAEIW,EAAK,GAAKE,GAAyBZ,EAAK3F,EAAI2F,EAAKF,WAFrD,YAGEY,EAAK,GAAKC,GAA0BzH,EAAS8G,EAAK1F,GAErD,EA5rBqB,KA+rBtBwG,kBAAoB,SAACX,EAAOO,EAAMxH,EAAQH,EAAOgI,GAAe,gBAM3CZ,GAN2C,IAM9D,2BAA0B,CAAC,IAAhBH,EAAe,QAItBA,EAAKU,KADY,UAAfK,EACU,EAAKN,2BAA2BT,EAAMU,EAAMxH,EAAQH,GAGpD,EAAK8H,yBAAyBb,EAAMU,EAAMxH,EAAQH,EAEjE,CAf6D,+BAgB/D,EA/sBqB,KAotBtBiI,mBAAqB,SAAC9H,EAAQH,EAAOb,GAanC,IAXA,IAAMiI,EAAQ,GAGRO,EAAO,EAAKrB,sBAAsBnH,GAGlC6I,EAAa7I,EAAIoH,aAAaxB,IAAI,WAIpCmD,EAAW,IAGTA,GAAYlI,IAFL,CAIX,IAAMmI,EAAiBnI,EAAQkI,EAIzBnB,EACJoB,EAAiB,EAAKX,YAAc,EAAKA,YAAcW,EAEzDf,EAAMK,KAAN,MAAAL,GAAK,OAAS,EAAKF,cAAc/G,EAAQ+H,EAAUnB,KAEnDmB,GAAYnB,CACb,CAKD,OAFA,EAAKgB,kBAAkBX,EAAOO,EAAMxH,EAAQH,EAAOgI,GAE5CZ,CACR,EArvBqB,KA0vBtBgB,kBAAoB,SAAC/D,EAAOrF,GAE1B,IAEiBqF,EAAMzG,YAGdyK,sBAAqB,SAAC9I,EAAOkB,GAElC,IAAMtB,EAAM,IAAImJ,IAAI7H,GACd8F,EAAepH,EAAIoH,aAEzBA,EAAagC,IAAI,MAAOvJ,EAAQgE,YAChCuD,EAAagC,IAAI,iBAAkBvJ,EAAQgE,YAC3CuD,EAAagC,IAAI,iBAAjB,cAA0CvJ,EAAQgE,aAIlD,IAAM7C,EAASuG,WAAWH,EAAaxB,IAAI,YAAc,EACnD/E,EAAQ0G,WAAWH,EAAaxB,IAAI,WAAa,EAIvD,GAAIvH,KAAKgB,IAAI2B,EAAQH,GAAS,EAAKwH,YAAa,CAG9C,IAAMJ,EAAQ,EAAKa,mBAAmB9H,EAAQH,EAAOb,GAE/CyH,EAAS9G,SAASC,cAAc,UAEtC6G,EAAO5G,MAAQA,EACf4G,EAAOzG,OAASA,EAGhB,IAX8C,EAWxCqI,EAAW,GAX6B,UAc3BpB,GAd2B,IAc9C,2BAA0B,CAAC,IAAhBH,EAAe,QAClBwB,EAAU,IAAIH,IAAInJ,EAAIuJ,YAC5BD,EAAQlC,aAAagC,IAAI,OAAQtB,EAAKU,MACtCc,EAAQlC,aAAagC,IAAI,SAAUtB,EAAKD,YACxCyB,EAAQlC,aAAagC,IAAI,QAAStB,EAAKF,WAEvCyB,EAASf,KACP,EAAKd,cAAcC,GAAnB,kBAAgCK,GAAhC,IAAsC9H,IAAKsJ,EAAQC,cAEtD,CAvB6C,+BA0B9CtJ,QAAQuJ,WAAWH,GAAUI,MAAK,WAChCrJ,EAAMsJ,WAAWpI,IAAMmG,EAAOpG,WAC/B,GACF,MAECjB,EAAMsJ,WAAWpI,IAAMtB,EAAIuJ,UAE9B,GAKF,CAJC,MAAOtC,GACPC,QAAQD,MAAR,gGAC2FA,GAE5F,CACF,EAxzBqB,KAm0BtB0C,4BAA8B,SAAC9J,GAAY,gBAErB,EAAKiF,gCAFgB,IAEzC,2BAAyD,CAAC,IAA/CI,EAA8C,QACvD,EAAKY,cAAcZ,EAAOrF,EAC3B,CAJwC,+CAQhB,EAAK4F,yBARW,IAQzC,2BAAuD,CAAC,IAA7CmB,EAA4C,QACrD,EAAKqC,kBAAkBrC,EAAY/G,EACpC,CAVwC,+BAW1C,EA90BqB,KAk1BtB+J,iBAAmB,WAAM,gBAIH,EAAK5D,cAJF,IAIvB,2BAAuC,SAC/BD,YAAW,EAClB,CANsB,+CAQH,EAAKiB,aARF,IAQvB,2BAAsC,CAAC,IAA5B9B,EAA2B,QACpC,EAAKvG,IAAIkL,YAAY3E,EACtB,CAVsB,+BAavB,EAAKc,aAAe,IAAI8D,IACxB,EAAK9C,YAAc,IAAI8C,GACxB,EAj2BqB,KAm2BtBC,MAAQ,SAAClK,GACP,IAAMN,EAASM,EAAQN,OACjBC,EAAcK,EAAQL,YACtBqE,EAAahE,EAAQgE,WACrBvB,EAAQzC,EAAQyC,MAAQ,IAGxB0H,EACY,aAAhBxK,GACI,OAAI,EAAKC,KAAKF,IAASG,UACvB,EAAKD,KAAKF,GAEVsB,EAAQxC,KAAK4L,MAAOD,EAAI,GAAKnG,EAAc,MAC3C7C,EAAS3C,KAAK4L,MAAOD,EAAI,GAAKnG,EAAc,MAMlD,EAAKqG,sBAAwB,EAAKP,4BAA4B9J,GAI9D,EAAKtC,UAAU4M,UAAU,EAAK1M,aAAayB,aAC3C,EAAKP,IAAIyL,QAAQ,EAAK7M,WAGtB,EAAK8M,gBAAkB,EAAK1L,IAAI2L,UAEhC,IAAMvG,EAAkB,EAAKK,mBAC3B9B,EACAuB,EACA,EAAKlF,IAAI0F,UAAUnF,aAKrB,EAAKP,IAAI4L,KAAK,kBAAd,iBAAgC,8HACI,IAA9B,EAAKlN,qBADqB,uBAE5B,EAAKA,sBAAuB,EAFA,mBAGrB,GAHqB,wBASxBmN,EAAAA,EAAAA,OAAM,KATkB,WAYxBC,EAAY9J,SAASC,cAAc,WAG/BC,MAAQA,EAClB4J,EAAUzJ,OAASA,EAEb0J,EAAaD,EAAUvJ,WAAW,MAClC2D,EAAkB,EAAKJ,wBAC7BiG,EAAWC,UAAY9F,EACvB6F,EAAWE,SAAS,EAAG,EAAG/J,EAAOG,GAGjCL,SAASkK,iBAAiB,uBAAuBC,SAAQ,SAACrD,GACxD,GAAIA,EAAO5G,MAAQ,EAAG,CACpB,IAAMgG,EAAUY,EAAOsD,WAAWnG,MAAMiC,QAGxC,GAFA6D,EAAWM,YAA0B,KAAZnE,EAAiB,EAAIlE,OAAOkE,GAEjDY,EAAO7C,MAAMqG,UAAW,CAC1B,IAAMC,EAASzD,EAAO7C,MAAMqG,UACzBE,MAAM,uBAAuB,GAC7B9D,MAAM,KACN1I,IAAIgE,QAEPyI,yBAAyBC,UAAUC,aAAaC,MAC9Cb,EACAQ,EAEH,CACDR,EAAWvJ,UAAUsG,EAAQ,EAAG,EACjC,CACF,KAGK3E,EAAM,IAAI0I,EAAAA,GAAM,CACpBhM,YAAAA,EACAD,OAAAA,EACAkM,kBAAkB,EAClBC,UAAU,KAIRC,SAASlB,EAAW,OAAQ,EAAG,EAAGT,EAAI,GAAIA,EAAI,IAG9C,EAAK9M,OAAS,IAGZ2C,EAAQ+L,qBACV9I,EAAIQ,aAA8B,EAAjB,EAAKlG,WAEtB0F,EAAIQ,aAA2B,EAAd,EAAKpG,QAGxB4F,EAAIY,aAAa,OAEb7D,EAAQ+L,qBACV9I,EAAI+I,KAAK,EAAG,EAAG7B,EAAI,GAAIA,EAAI,GAAI,QAO/BnK,EAAQiM,aAAe,EAAKC,QAAQC,OAAOzJ,QAAU,GA3E3B,4CAiFhB,EAAKhB,sBAAsB,EAAKwK,QAAS,EAAKE,cAjF9B,iBA8ElBC,EA9EkB,EA8ExB9K,KACO+K,EA/EiB,EA+ExBtL,MACQuL,EAhFgB,EAgFxBpL,OAGEqL,EAAgB,EAAKzK,aACvB/B,EAAQwM,cACRF,EACAC,EACApC,EAAI,GACJA,EAAI,IAGNlH,EAAI6I,SACFO,EACA,MACAG,EAAclK,EACdkK,EAAcjK,EACd+J,EACAC,GAjGwB,mDAqG1B,EAAKE,cAAcC,QAAQ,4BArGD,aAyG1B1M,EAAQ2M,mBAAqB,EAAKC,cAAcT,OAAOzJ,QAAU,GAzGvC,4CA+GhB,EAAKhB,sBAAsB,EAAKkL,cAAe,IA/G/B,iBA4GlBC,EA5GkB,EA4GxBtL,KACOuL,EA7GiB,EA6GxB9L,MACQ+L,EA9GgB,EA8GxB5L,OAGI6L,EAAiB,EAAKjL,aAC1B/B,EAAQiN,oBACRH,EACAC,EACA5C,EAAI,GACJA,EAAI,IAGNlH,EAAI6I,SACFe,EACA,MACAG,EAAe1K,EACf0K,EAAezK,EACfuK,EACAC,GA/HwB,mDAmI1B,EAAKN,cAAcC,QAAQ,6BAnID,QAuI1B1M,EAAQkN,iBACV,EAAKnJ,YACHd,EACAjD,EAAQmN,aACRnN,EAAQyC,MACRzC,EAAQgE,WACRhE,EAAQiE,kBACRC,EACAlE,EAAQN,OACRM,EAAQL,aAKRK,EAAQoN,SAASjB,OAAOzJ,OAAS,IAC/B2K,EAAOrN,EAAQ+L,qBAAuB,GAAK,GAAK,EAAK1O,OACzD4F,EAAIK,YAAY,IAChBL,EAAIO,aAAaxD,EAAQmN,cACzBlK,EAAIS,KAAK1D,EAAQoN,SAAUjD,EAAI,GAAK,EAAGkD,EAAM,CAC3CC,MAAO,YAKPtN,EAAQuN,aAAapB,OAAOzJ,OAAS,IACnC2K,EAAOrN,EAAQ+L,qBAAuB,GAAK,GAAK,EAAK1O,OACzD4F,EAAIK,YAAY,IAChBL,EAAIO,aAAaxD,EAAQmN,cACzBlK,EAAIS,KAAK1D,EAAQuN,aAAcpD,EAAI,GAAK,EAAGkD,EAAM,CAC/CC,MAAO,YAKP,EAAKE,UAAU9K,OAAS,IACtB2K,EAAOrN,EAAQ+L,qBAAuB,EAAI,EAAK1O,OACnD4F,EAAIK,YAAY,GAChBL,EAAIO,aAAaxD,EAAQmN,cACzBlK,EAAIS,KAAK,EAAK8J,UAAWrD,EAAI,GAAK,EAAIkD,EAAMlD,EAAI,GAAK,EAAIkD,EAAM,CAC7DC,MAAO,WAKP,EAAKG,WAAW/K,OAAS,IACvB2K,EAAOrN,EAAQ+L,qBAAuB,EAAI,EAAK1O,OACnD4F,EAAIK,YAAY,GAChBL,EAAIO,aAAaxD,EAAQmN,cACrBO,EAAYzK,EAAI0K,gBAClB,EAAKF,WACLtD,EAAI,GAAK,EAAI,EAAK9M,OAAS,GAEzBuQ,EAAgB3K,EAAI4K,kBAAkBH,EAAW,CAAEI,SAAU,IACjE7K,EAAIS,KACFgK,EACAvD,EAAI,GAAK,EAAIkD,EACblD,EAAI,GAAK,EAAIkD,EAAOO,EAAcG,EAClC,CACET,MAAO,WAOb,EAAKjD,sBAAwB,EAAKN,mBAGlC,EAAKiE,WAAW/K,EAAKjC,EAAOhB,EAAQiO,YACjCrE,MAAK,WACJ,EAAK6C,cAAcC,QAAQ,kBAC5B,IACAwB,OAAM,SAAC9G,GACNC,QAAQ8G,KAAK/G,GACb,EAAKqF,cAAcC,QAAQ,uBAC5B,IACA0B,SAAQ,WAEP,EAAKC,qBACN,IAtN2B,oEA0NhC,IAAMC,GAAcjP,EAAAA,EAAAA,WAClB,EAAKnC,eAAeiC,cAAcC,aAIpC,EAAKnC,aAAaiJ,YAAW,GAI7B,EAAKpH,IAAIyP,mBAAmBxJ,MAAM/D,MAAlC,UAA6CA,EAA7C,MACA,EAAKlC,IAAIyP,mBAAmBxJ,MAAM5D,OAAlC,UAA8CA,EAA9C,MACA,EAAKrC,IAAI0P,aACT,EAAK1P,IAAI0F,UAAU8F,UAAUgE,GAC7B,EAAKxP,IAAI0F,UAAUiK,cAAcvK,EAClC,EAhnCqB,KAknCtBmK,oBAAsB,WACpB,EAAKpR,aAAaiJ,YAAW,GAC7B,EAAKpH,IAAI4P,QAAQ,EAAKlE,iBACtB,EAAK1L,IAAIyP,mBAAmBxJ,MAAM/D,MAAQ,GAC1C,EAAKlC,IAAIyP,mBAAmBxJ,MAAM5D,OAAS,GAC3C,EAAKrC,IAAI0P,aACT,EAAK1P,IAAIyL,QAAQ,EAAK3M,aACvB,EAznCqB,mFA4nCA,6GAEE,8DAFF,cAEZ+Q,EAFY,yBAGX,CAAEA,MAAAA,IAHS,sCAKZ,IAAIC,MAAJ,gEALY,yDA5nCA,0IAwoCT,WAAO3L,EAAK4L,GAAZ,0EAET5L,EAAI6L,KAAJ,UAAYD,EAAZ,SAFS,qDAIH,IAAID,MAAJ,4CAJG,wDAxoCS,6IAmpCT,WAAO3L,EAAK4L,EAAU7N,GAAtB,4GAGe,EAHf,yBAGD2N,EAHC,EAGDA,OAGFI,oBAAoBC,UAA1B,kDAAiFL,EAAMM,QAAvF,kBAEMC,EAAKjM,EAAIkM,OAAO,eAOtBR,EAAMS,YAAY,CAAE7N,KAAM2N,IAAMG,QAAQzF,MAAK,SAAC3G,GAG5CA,EAAIqM,QAAQ,GAAG1F,MAAK,SAAC2F,GAEnB,IAAI3H,EAAS9G,SAASC,cAAc,UAChC+G,EAAMF,EAAOvG,WAAW,MAEtBmO,EAAWD,EAAKE,YAAY,CAAEhN,MAAO,IACrCA,EAAQzB,EAAQwO,EAASxO,MACzB0O,EAAiBH,EAAKE,YAAY,CAAEhN,MAAOA,IAE3CkN,EAAgB,CACpBC,cAAe9H,EACf0H,SAAUE,GAGZ9H,EAAOzG,OAASuO,EAAevO,OAC/ByG,EAAO5G,MAAQ0O,EAAe1O,MAE9BuO,EAAKM,OAAOF,GAAeN,QAAQzF,MAAK,WACtChC,EAAOkI,QAAO,SAACC,IACbC,EAAAA,EAAAA,QAAOD,EAAD,UAAUlB,EAAV,QACP,GACF,GACF,GACF,IAzCQ,wDA2CH,IAAID,MAAJ,4CA3CG,0DAnpCS,iEAmsCtBZ,WAnsCsB,mCAmsCT,WAAO/K,EAAKjC,EAAOiP,GAAnB,uEAELpB,EAFK,wBAEsB,IAAIqB,MAAOnN,kBAFjC,cAKDkN,EALC,OAMF,QANE,OAQF,QARE,uDAOE,EAPF,MAOkBhN,EAAK4L,IAPvB,wCASE,EATF,MASkB5L,EAAK4L,EAAU7N,IATjC,aAWC,IAAI4N,MAAJ,oEACyDqB,EADzD,kDAXD,+DAgBH,IAAIrB,MAAJ,wCAhBG,0DAnsCS,+DAutCtBuB,YAAc,WAEZ,EAAK3S,sBAAuB,EAG5B,EAAK6Q,sBAGL,EAAKhE,sBAAwB,EAAKN,kBACnC,EAhuCqB,KAwuCtBpG,qBAAuB,SAAClB,GACtB,MAAM,KAAN,OAAYK,OAAOL,GAAOM,eAAe,SAC1C,EAzuCC9B,KAAKnC,IAAM/B,EAAS+B,IACpBmC,KAAKrB,KAAO7C,EAAS6C,KACrBqB,KAAKiL,QAAL,UAAenP,EAASiD,QAAQoQ,YAAhC,QAAwC,GACxCnP,KAAK2L,cAAL,UAAqB7P,EAASiD,QAAQqQ,kBAAtC,QAAoD,GACpDpP,KAAKmL,aAAerP,EAASiD,QAAQoM,aACrCnL,KAAK7C,OAASrB,EAASiD,QAAQ5B,OAC/B6C,KAAKuM,UAAL,UAAiBzQ,EAASiD,QAAQwN,iBAAlC,QAA+C,GAC/CvM,KAAKwM,WAAL,UAAkB1Q,EAASiD,QAAQyN,kBAAnC,QAAiD,GACjDxM,KAAKwL,cAAgB1P,EAAS0P,cAC9BxL,KAAKqP,UAAYvT,EAASuT,UAI1BrP,KAAKoJ,qBAAL,UAA4BtN,EAASiD,QAAQqK,4BAA7C,SAIApJ,KAAKuH,YAAczL,EAASiD,QAAQwI,aAAe,KAInDvH,KAAKrD,aAAeqD,KAAKnC,IAAI0F,UAC7BvD,KAAKuJ,gBAAkB,KAIvBvJ,KAAKkF,aAAe,IAAI8D,IACxBhJ,KAAKkG,YAAc,IAAI8C,IAKvBhJ,KAAKvD,UAAY,IAAI6S,EAAAA,GAAK,CACxB7L,OAAQzD,KAAKrD,aAAayB,YAC1BmR,oBAAqBvP,KAAKqP,UAAUE,oBACpCC,qBAAqB,EACrBC,QAAS,GACTC,QAAS,EACTnK,WAAYvF,KAAKrD,aAAaG,gBAC9B6S,YAAa3P,KAAKqP,UAAUO,eAC5BC,KAAM7P,KAAKrD,aAAaC,WAE3B,CA0LA,OA1LA,uCAsCD,WACEoD,KAAKhE,aAAe,IAAI8T,EAAAA,EAAO,CAC7B1K,OAAQ,IAAI2K,EAAAA,EACZC,UAAW,SACXC,OAAQ,IACRC,KAAM,cACNC,QAAS,cACTrM,MAAO,IAAIsM,EAAAA,GAAM,CACfC,OAAQ,IAAIC,EAAAA,EAAO,CACjBpO,MAAO,qBACPnC,MAAO,IAETwQ,KAAM,IAAIC,EAAAA,EAAK,CACbtO,MAAO,gCAIblC,KAAKnC,IAAI4S,SAASzQ,KAAKhE,aACxB,2BAuDD,SAAW+C,GACT,IAAMyC,EAAQzC,EAAQyC,MAChB/C,EAASM,EAAQN,OACjBC,EAAcK,EAAQL,YACtBgS,EAAY3R,EAAQ2R,UAIpB5F,IAAuB4F,GACzB3R,EAAQ+L,qBAGN5B,EAAMlJ,KAAKxB,YAAYC,EAAQC,GAErCsB,KAAK5D,OAASsU,EAAY1Q,KAAK3B,UAAU6K,EAAKlJ,KAAK9D,cAAgB,EAInE8D,KAAK3D,gBAAkByO,EAAuB,EAAI,EAElD9K,KAAK1D,UAAYwO,EACb9K,KAAK3B,UAAU6K,EAAKlJ,KAAK7D,sBACzB,EAEJ,IAKMwU,EALmB,KAGY,IAGjCC,EACF7R,EAAQ2R,WAAa3R,EAAQ+L,qBAAuB5B,EAAI,GAAK,GAAKA,EAAI,GAOlE2H,GAJI3H,EAAI,GAAmB,EAAdlJ,KAAK5D,QAAc,KAKhBuU,EADhBE,GAHKD,EAA2B,EAAd5Q,KAAK5D,QAAc,KAKnBuU,EAGlBlN,EAASzD,KAAK/D,gBAChBmC,EAAAA,EAAAA,WAAU4B,KAAK/D,eAAeiC,cAAcC,aAC5C6B,KAAKnC,IAAI0F,UAAUnF,YAIrB0S,EAAOD,EAAcF,EAFX,MAEwBnP,EAAS,EADtC,EAELF,EAAOuP,EAAeF,EAHZ,MAGyBnP,EAAS,EAFvC,EAGLuP,EAAS,CACP,CACE,CAACtN,EAAO,GAAKqN,EAAGrN,EAAO,GAAKnC,GAC5B,CAACmC,EAAO,GAAKqN,EAAGrN,EAAO,GAAKnC,GAC5B,CAACmC,EAAO,GAAKqN,EAAGrN,EAAO,GAAKnC,GAC5B,CAACmC,EAAO,GAAKqN,EAAGrN,EAAO,GAAKnC,GAC5B,CAACmC,EAAO,GAAKqN,EAAGrN,EAAO,GAAKnC,KAGhC0P,EAAU,IAAIC,EAAAA,EAAQ,CACpBC,SAAU,IAAIC,EAAAA,GAAQJ,KAK1B/Q,KAAKvC,gBAGLuC,KAAK/D,eAAiB+U,EACtBhR,KAAKhE,aAAa2B,YAAYyT,WAAWJ,GACzChR,KAAKjC,UAAY,IAAIsT,EAAAA,EAAU,CAC7BC,SAAU,IAAIC,EAAAA,EAAW,CAACP,MAE5BhR,KAAKnC,IAAI2T,eAAexR,KAAKjC,UAC9B,OAtOkBlC,E","sources":["plugins/Print/PrintModel.js"],"sourcesContent":["import { delay } from \"../../utils/Delay\";\nimport { getPointResolution } from \"ol/proj\";\nimport { getCenter } from \"ol/extent\";\nimport jsPDF from \"jspdf\";\nimport { saveAs } from \"file-saver\";\n\nimport Vector from \"ol/layer/Vector.js\";\nimport View from \"ol/View\";\nimport VectorSource from \"ol/source/Vector.js\";\nimport Polygon from \"ol/geom/Polygon\";\nimport Feature from \"ol/Feature.js\";\nimport { Translate } from \"ol/interaction.js\";\nimport Collection from \"ol/Collection\";\nimport { Style, Stroke, Fill } from \"ol/style.js\";\n\nimport ImageLayer from \"ol/layer/Image\";\nimport TileLayer from \"ol/layer/Tile\";\nimport TileWMS from \"ol/source/TileWMS\";\nimport ImageWMS from \"ol/source/ImageWMS\";\n\nexport default class PrintModel {\n  constructor(settings) {\n    this.map = settings.map;\n    this.dims = settings.dims;\n    this.logoUrl = settings.options.logo ?? \"\";\n    this.northArrowUrl = settings.options.northArrow ?? \"\";\n    this.logoMaxWidth = settings.options.logoMaxWidth;\n    this.scales = settings.options.scales;\n    this.copyright = settings.options.copyright ?? \"\";\n    this.disclaimer = settings.options.disclaimer ?? \"\";\n    this.localObserver = settings.localObserver;\n    this.mapConfig = settings.mapConfig;\n    // If we want the printed tiles to have correct styling, we have to use\n    // custom loaders to make sure that the requests has all the required parameters.\n    // If for some reason these tile-loaders shouldn't be used, a setting is exposed.\n    this.useCustomTileLoaders = settings.options.useCustomTileLoaders ?? true;\n    // Since the WMS-servers cannot handle enormous requests, we have to\n    // limit Image-WMS requests. The size below is the maximum tile-size allowed.\n    // This max-size is only used if the custom-tile-loaders are used.\n    this.maxTileSize = settings.options.maxTileSize || 4096;\n\n    // Let's keep track of the original view, since we're gonna change the view\n    // under the print-process. (And we want to be able to change back to the original one).\n    this.originalView = this.map.getView();\n    this.originalMapSize = null; // Needed to restore view. It is set when print().\n\n    // Since we will be hiding all tile-layers during the print-process, and add image-layers\n    // instead, we have to keep track of what we hide and show.\n    this.hiddenLayers = new Set(); // Contains all tile-layers that have been exchanged with image-layers.\n    this.addedLayers = new Set(); // Contains the tile-layer-replacements.\n\n    // We must initiate a \"print-view\" that includes potential \"hidden\" resolutions.\n    // These \"hidden\" resolutions allows the print-process to zoom more than what the\n    // users are allowed (which is required if we want to print in high resolutions).\n    this.printView = new View({\n      center: this.originalView.getCenter(),\n      constrainOnlyCenter: this.mapConfig.constrainOnlyCenter,\n      constrainResolution: false,\n      maxZoom: 24,\n      minZoom: 0,\n      projection: this.originalView.getProjection(),\n      resolutions: this.mapConfig.allResolutions, // allResolutions includes the \"hidden\" resolutions\n      zoom: this.originalView.getZoom(),\n    });\n  }\n\n  scaleBarLengths = {\n    100: 2.5,\n    200: 5,\n    250: 10,\n    400: 20,\n    500: 25,\n    1000: 50,\n    2000: 75,\n    2500: 100,\n    5000: 250,\n    10000: 500,\n    25000: 1000,\n    50000: 2500,\n    100000: 5000,\n    200000: 10000,\n  };\n\n  previewLayer = null;\n  previewFeature = null;\n\n  // Used to calculate the margin around the map-image. Change this value to get\n  // more or less margin.\n  marginAmount = 0.03;\n\n  textIconMarginAmount = 0.06;\n\n  // Used to store the calculated margin.\n  margin = 0;\n\n  textIconsMargin = 0;\n\n  mapMargin = 0;\n\n  // A flag that's used in \"rendercomplete\" to ensure that user has not cancelled the request\n  pdfCreationCancelled = null;\n\n  addPreviewLayer() {\n    this.previewLayer = new Vector({\n      source: new VectorSource(),\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginPrint\",\n      caption: \"Print layer\",\n      style: new Style({\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.7)\",\n          width: 2,\n        }),\n        fill: new Fill({\n          color: \"rgba(255, 145, 20, 0.4)\",\n        }),\n      }),\n    });\n    this.map.addLayer(this.previewLayer);\n  }\n\n  getMapScale = () => {\n    // We have to make sure to get (and set on the printView) the current zoom\n    //  of the \"original\" view. Otherwise, the scale calculation could be wrong\n    // since it depends on the static zoom of the printView.\n    this.printView.setZoom(this.originalView.getZoom());\n    // When this is updated, we're ready to calculate the scale, which depends on the\n    // dpi, mpu, inchPerMeter, and resolution. (TODO: (@hallbergs) Clarify these calculations).\n    const dpi = 25.4 / 0.28,\n      mpu = this.printView.getProjection().getMetersPerUnit(),\n      inchesPerMeter = 39.37,\n      res = this.printView.getResolution();\n\n    return res * mpu * inchesPerMeter * dpi;\n  };\n\n  getFittingScale = () => {\n    //Get map scale\n    const proposedScale = this.getMapScale();\n\n    //Get the scale closest to the proposed scale.\n    return this.scales.reduce((prev, curr) => {\n      return Math.abs(curr - proposedScale) < Math.abs(prev - proposedScale)\n        ? curr\n        : prev;\n    });\n  };\n\n  removePreview = () => {\n    this.previewFeature = undefined;\n    this.previewLayer.getSource().clear();\n    this.map.removeInteraction(this.translate);\n  };\n\n  getPreviewCenter = () => {\n    const extent = this.previewFeature.getGeometry().getExtent();\n    return getCenter(extent);\n  };\n\n  // Calculates the margin around the map-image depending on\n  // the paper dimensions\n  getMargin = (paperDim, marginAmount) => {\n    const longestSide = Math.max(...paperDim);\n    return marginAmount * longestSide;\n  };\n\n  // Returns an array with the paper dimensions with the selected\n  // format and orientation.\n  getPaperDim = (format, orientation) => {\n    return orientation === \"portrait\"\n      ? [...this.dims[format]].reverse()\n      : this.dims[format];\n  };\n\n  addPreview(options) {\n    const scale = options.scale;\n    const format = options.format;\n    const orientation = options.orientation;\n    const useMargin = options.useMargin;\n\n    // If the user wants text and icons in the margins and outside the map image\n    // we should only allow that if margins are used\n    const useTextIconsInMargin = useMargin\n      ? options.useTextIconsInMargin\n      : false;\n\n    const dim = this.getPaperDim(format, orientation);\n\n    this.margin = useMargin ? this.getMargin(dim, this.marginAmount) : 0;\n\n    //We need a different margin value for text and icons to be placed in the margins,\n    //because \"this.margin\" (above) is sometimes used independently\n    this.textIconsMargin = useTextIconsInMargin ? 0 : 6;\n\n    this.mapMargin = useTextIconsInMargin\n      ? this.getMargin(dim, this.textIconMarginAmount)\n      : 0;\n\n    const inchInMillimeter = 25.4;\n    // We should take pixelRatio into account? What happens when we have\n    // pr=2? PixelSize will be 0.14?\n    const defaultPixelSizeInMillimeter = 0.28;\n\n    const dpi = inchInMillimeter / defaultPixelSizeInMillimeter; // ~90\n    let sizeHeight =\n      options.useMargin && options.useTextIconsInMargin ? dim[1] - 35 : dim[1];\n\n    const size = {\n      width: (dim[0] - this.margin * 2) / 25.4,\n      height: (sizeHeight - this.margin * 2) / 25.4,\n    };\n\n    const paper = {\n      width: size.width * dpi,\n      height: size.height * dpi,\n    };\n\n    const center = this.previewFeature\n      ? getCenter(this.previewFeature.getGeometry().getExtent())\n      : this.map.getView().getCenter();\n\n    const ipu = 39.37,\n      sf = 1,\n      w = (((paper.width / dpi / ipu) * scale) / 2) * sf,\n      y = (((paper.height / dpi / ipu) * scale) / 2) * sf,\n      coords = [\n        [\n          [center[0] - w, center[1] - y],\n          [center[0] - w, center[1] + y],\n          [center[0] + w, center[1] + y],\n          [center[0] + w, center[1] - y],\n          [center[0] - w, center[1] - y],\n        ],\n      ],\n      feature = new Feature({\n        geometry: new Polygon(coords),\n      });\n\n    // Each time print settings change, we actually render a new preview feature,\n    // so first let's remove the old one.\n    this.removePreview();\n\n    // Now re-add feature, source and interaction to map.\n    this.previewFeature = feature;\n    this.previewLayer.getSource().addFeature(feature);\n    this.translate = new Translate({\n      features: new Collection([feature]),\n    });\n    this.map.addInteraction(this.translate);\n  }\n\n  renderPreviewFeature = (previewLayerVisible, options) => {\n    if (previewLayerVisible) {\n      this.addPreview(options);\n    } else {\n      this.removePreview();\n    }\n  };\n\n  /**\n   * @summary Returns a Promise which resolves if image loading succeeded.\n   * @description The Promise will contain an object with data blob of the loaded image. If loading fails, the Promise rejects\n   *\n   * @param {*} url\n   * @returns {Promise}\n   */\n  getImageDataBlobFromUrl = (url) => {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      image.setAttribute(\"crossOrigin\", \"anonymous\"); //getting images from external domain\n\n      // We must resolve the promise even if\n      image.onerror = function (err) {\n        reject(err);\n      };\n\n      // When load succeeds\n      image.onload = function () {\n        const imgCanvas = document.createElement(\"canvas\");\n        imgCanvas.width = this.naturalWidth;\n        imgCanvas.height = this.naturalHeight;\n\n        // Draw the image on canvas so that we can read the data blob later on\n        imgCanvas.getContext(\"2d\").drawImage(this, 0, 0);\n\n        resolve({\n          data: imgCanvas.toDataURL(\"image/png\"), // read data blob from canvas\n          width: imgCanvas.width, // also return dimensions so we can use them later\n          height: imgCanvas.height,\n        });\n      };\n\n      // Go, load!\n      image.src = url;\n    });\n  };\n  /**\n   * @summary Helper function that takes a URL and max width and returns the ready data blob as well as width/height which fit into the specified max value.\n   *\n   * @param {*} url\n   * @param {*} maxWidth\n   * @returns {Object} image data blob, image width, image height\n   */\n  getImageForPdfFromUrl = async (url, maxWidth) => {\n    // Use the supplied logo URL to get img data blob and dimensions\n    const {\n      data,\n      width: sourceWidth,\n      height: sourceHeight,\n    } = await this.getImageDataBlobFromUrl(url);\n\n    // We must ensure that the logo will be printed with a max width of X, while keeping the aspect ratio between width and height\n    const ratio = maxWidth / sourceWidth;\n    const width = sourceWidth * ratio;\n    const height = sourceHeight * ratio;\n    return { data, width, height };\n  };\n\n  /**\n   * @summary Returns an object stating the x and y position\n   * @description Helper function that takes some content and calculates where it should be placed on the canvas\n   *\n   * @param {*} placement chosen placement on the canvas\n   * @param {*} contentWidth\n   * @param {*} contentHeight\n   * @param {*} pdfWidth\n   * @param {*} pdfHeight\n   * @returns {Object} x-axis and y-axis placement in mm\n   */\n  getPlacement = (\n    placement,\n    contentWidth,\n    contentHeight,\n    pdfWidth,\n    pdfHeight\n  ) => {\n    // We must take the potential margin around the map-image into account (this.margin)\n\n    const margin = this.textIconsMargin + this.margin;\n\n    let pdfPlacement = { x: 0, y: 0 };\n    if (placement === \"topLeft\") {\n      pdfPlacement.x = margin;\n      pdfPlacement.y = margin;\n    } else if (placement === \"topRight\") {\n      pdfPlacement.x = pdfWidth - contentWidth - margin;\n      pdfPlacement.y = margin;\n    } else if (placement === \"bottomRight\") {\n      pdfPlacement.x = pdfWidth - contentWidth - margin;\n      pdfPlacement.y = pdfHeight - contentHeight - margin;\n    } else {\n      pdfPlacement.x = margin;\n      pdfPlacement.y = pdfHeight - contentHeight - margin;\n    }\n    return pdfPlacement;\n  };\n\n  /**\n   * @summary Returns fitting scale bar length depending on the scale\n   * @description Helper function that returns a fitting number of meters for the supplied scale.\n   *\n   * @param {*} scale\n   * @returns {Float} Fitting number of meters for current scale.\n   */\n  getFittingScaleBarLength = (scale) => {\n    const length = this.scaleBarLengths[scale];\n    if (length) {\n      return length;\n    } else {\n      if (scale < 250) {\n        return 5;\n      } else if (scale < 2500) {\n        return scale * 0.02;\n      } else {\n        return scale * 0.05;\n      }\n    }\n  };\n\n  //Formats the text for the scale bar\n  getLengthText = (scaleBarLengthMeters) => {\n    let units = \"m\";\n    if (scaleBarLengthMeters > 1000) {\n      scaleBarLengthMeters /= 1000;\n      units = \"km\";\n    }\n    return `${Number(scaleBarLengthMeters).toLocaleString(\"sv-SE\")} ${units}`;\n  };\n\n  drawScaleBar = (\n    pdf,\n    scaleBarPosition,\n    color,\n    scaleBarLength,\n    scale,\n    scaleBarLengthMeters,\n    format,\n    orientation\n  ) => {\n    const lengthText = this.getLengthText(scaleBarLengthMeters);\n    pdf.setFontSize(8);\n    pdf.setFont(\"helvetica\", \"bold\");\n    pdf.setTextColor(color);\n    pdf.setLineWidth(0.25);\n    pdf.text(\n      lengthText,\n      scaleBarPosition.x + scaleBarLength + 1,\n      scaleBarPosition.y + 4\n    );\n    pdf.setFontSize(10);\n    pdf.text(\n      `Skala: ${this.getUserFriendlyScale(\n        scale\n      )} (vid ${format.toUpperCase()} ${\n        orientation === \"landscape\" ? \"liggande\" : \"stående\"\n      })`,\n      scaleBarPosition.x,\n      scaleBarPosition.y + 1\n    );\n\n    pdf.setDrawColor(color);\n    pdf.line(\n      scaleBarPosition.x,\n      scaleBarPosition.y + 3,\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 3\n    );\n    pdf.line(\n      scaleBarPosition.x,\n      scaleBarPosition.y + 2,\n      scaleBarPosition.x,\n      scaleBarPosition.y + 4\n    );\n    pdf.line(\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 2,\n      scaleBarPosition.x + scaleBarLength,\n      scaleBarPosition.y + 4\n    );\n    pdf.line(\n      scaleBarPosition.x + scaleBarLength / 2,\n      scaleBarPosition.y + 2.5,\n      scaleBarPosition.x + scaleBarLength / 2,\n      scaleBarPosition.y + 3.5\n    );\n  };\n\n  addScaleBar = (\n    pdf,\n    color,\n    scale,\n    resolution,\n    scaleBarPlacement,\n    scaleResolution,\n    format,\n    orientation\n  ) => {\n    const millimetersPerInch = 25.4;\n    const pixelSize = millimetersPerInch / resolution / scaleResolution;\n    const scaleBarLengthMeters = this.getFittingScaleBarLength(scale);\n\n    const scaleBarLength = scaleBarLengthMeters * pixelSize;\n    const scaleBarHeight = 6;\n\n    const scaleBarPosition = this.getPlacement(\n      scaleBarPlacement,\n      scaleBarLength + 9,\n      scaleBarHeight,\n      pdf.internal.pageSize.width,\n      pdf.internal.pageSize.height\n    );\n\n    this.drawScaleBar(\n      pdf,\n      scaleBarPosition,\n      color,\n      scaleBarLength,\n      scale,\n      scaleBarLengthMeters,\n      format,\n      orientation\n    );\n  };\n\n  // Make sure the desired resolution (depending on scale and dpi)\n  // works with the current map-setup.\n  desiredPrintOptionsOk = (options) => {\n    const resolution = options.resolution;\n    const scale = options.scale / 1000;\n    const desiredResolution = this.getScaleResolution(\n      scale,\n      resolution,\n      this.map.getView().getCenter()\n    );\n\n    // The desired options are OK if they result in a resolution bigger than the minimum\n    // resolution of the print-view.\n    return desiredResolution >= this.printView.getMinResolution();\n  };\n\n  getScaleResolution = (scale, resolution, center) => {\n    return (\n      scale /\n      getPointResolution(\n        this.map.getView().getProjection(),\n        resolution / 25.4,\n        center\n      )\n    );\n  };\n\n  // If the user has selected one of the \"special\" backgroundLayers (white or black)\n  // the backgroundColor of the mapCanvas has changed. We must keep track of this\n  // to make sure that the print-results has the same appearance.\n  getMapBackgroundColor = () => {\n    const currentBackgroundColor =\n      document.getElementById(\"map\").style.backgroundColor;\n    return currentBackgroundColor !== \"\" ? currentBackgroundColor : \"white\";\n  };\n\n  // Returns all currently active tile-, and image-layers as an array\n  getVisibleTileAndImageLayers = () => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return layer.getVisible() && this.layerIsTileOrImageLayer(layer);\n      });\n  };\n\n  // Returns true if the supplied layer is a tiled or an image-based layer.\n  layerIsTileOrImageLayer = (layer) => {\n    return (\n      (layer instanceof TileLayer && layer.getSource() instanceof TileWMS) ||\n      (layer instanceof ImageLayer && layer.getSource() instanceof ImageWMS)\n    );\n  };\n\n  // Returns all currently active image-layers as an array\n  getVisibleImageLayers = () => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .filter((layer) => {\n        return (\n          layer.getVisible() &&\n          layer instanceof ImageLayer &&\n          layer.getSource() instanceof ImageWMS\n        );\n      });\n  };\n\n  // Returns the layer placement (index) in the array of map-layers.\n  // The placement is generally the draw-order (unless z-index is set on the layer).\n  getLayerPlacementIndex = (layer) => {\n    return this.map\n      .getLayers()\n      .getArray()\n      .map((l) => l.get(\"name\"))\n      .indexOf(layer.get(\"name\"));\n  };\n\n  // Hides the supplied layer and adds another layer with appropriate settings for\n  // printing. The added layer is always an image-layer. Why exchange the sources\n  // with only image sources? Well, it seems as if OL does some funky stuff with all the tiled sources,\n  // leading to an excess of loaded tiles. By making sure to only use image-layers during print, we can\n  // make sure we're not requesting too many tiles, and also that the wms-style is applied properly.\n  exchangeLayer = (layer) => {\n    // Let's run this in a try-catch just in case\n    try {\n      // Since we're adding a \"print-layer\", we want to make sure to hide\n      // the \"real\" layer so that we don't show the same information twice.\n      layer.setVisible(false);\n      // We have to keep track of all the layers that we have hidden, so that\n      // we can show them again when the printing is done.\n      this.hiddenLayers.add(layer);\n      // When we create the new layer, we're gonna need the original source!\n      const source = layer.getSource();\n      // Let's create a new image-source containing all the options from the supplied source\n      // along with some additional settings. We make sure to set the ratio to one (1) so that\n      // OL does not load more data than necessary, and we also make sure to disable hiDpi!\n      // (Otherwise the print-process will fetch more pixels than necessary).\n      const imageSource = new ImageWMS({\n        ...source.getProperties(),\n        projection: source.getProjection(),\n        crossOrigin: source.crossOrigin ?? \"anonymous\",\n        params: { ...source.getParams() },\n        ratio: 1,\n        hidpi: false,\n      });\n      // We have to make sure to check the current layer-opacity and use that\n      // opacity-value on the new layer.\n      const layerOpacity = layer.getOpacity() ?? 1;\n      // Then we can create the new image-layer with the new image-source.\n      const imageLayer = new ImageLayer({\n        opacity: layerOpacity,\n        source: imageSource,\n      });\n      // Finally we add the new layer to the map... First we have to check where\n      // the original layer was placed (so that it keeps its draw-order).\n      const layerPlacement = this.getLayerPlacementIndex(layer);\n      // Then we can add the layer...\n      this.map.getLayers().insertAt(layerPlacement, imageLayer);\n      // ... and update the array containing the added layers so that we can remove\n      // them when the printing process is completed.\n      this.addedLayers.add(imageLayer);\n    } catch (error) {\n      console.error(\n        `Failed to exchange the supplied layer with a print-layer! Error: ${error}`\n      );\n    }\n  };\n\n  // Returns an array of floats representing the bounding box found\n  // in the 'BBOX' query-parameter in the supplied url.\n  getBoundingBoxFromUrl = (url) => {\n    return url.searchParams\n      .get(\"BBOX\")\n      .split(\",\")\n      .map((coord) => parseFloat(coord));\n  };\n\n  // Loads an image (tile) and draws it on the supplied canvas-context\n  loadImageTile = (canvas, tileOptions) => {\n    // We have to get the context so that we can draw the image\n    const ctx = canvas.getContext(\"2d\");\n    // Then we need some tile-information\n    const { url, x, y, tileWidth, tileHeight } = tileOptions;\n    // Let's return a promise...\n    return new Promise((resolve, reject) => {\n      // Let's create an image-element\n      const tile = document.createElement(\"img\");\n      tile.onload = () => {\n        // When the tile has loaded, we can draw the tile on the canvas.\n        ctx.drawImage(tile, x, y, tileWidth, tileHeight);\n        // The promise can be resolved when the tile has been fetched and\n        // drawn on the canvas.\n        resolve();\n      };\n      // If the fetch fails, we have to reject the promise.\n      tile.onerror = () => {\n        reject();\n      };\n      // Let's set the cross-origin-attribute to prevent cors-problems\n      tile.crossOrigin = \"anonymous\";\n      // Then we'll set the url so that the image can be fetched.\n      tile.src = url;\n    });\n  };\n\n  // Creates tile-information-objects for a column (all tiles needed to fill\n  // up to the target-height).\n  getTileColumn = (targetHeight, x, tileWidth) => {\n    // We're gonna need to store the tile-information in an array\n    const tiles = [];\n    // We'll iterate (and push tiles to the tile-array) until...\n    while (true) {\n      // ... we've reached the target-height. Let's summarize all tile-height\n      // so that we can check if we're done.\n      const accHeight = tiles.reduce((acc, curr) => acc + curr.tileHeight, 0);\n      // If we are, we can return the array of tile-information\n      if (accHeight >= targetHeight) return tiles;\n      // Otherwise we'll calculate how many pixels are left...\n      const remainingHeight = targetHeight - accHeight;\n      // And either create a tile with that height (or the max-height if the remainder is too large).\n      const tileHeight =\n        remainingHeight > this.maxTileSize ? this.maxTileSize : remainingHeight;\n      // Then we have to calculate where the tile is to be placed on the canvas later.\n      const y = targetHeight - accHeight - tileHeight;\n      // And finally we'll push the information to the array.\n      tiles.push({\n        x,\n        y,\n        tileWidth,\n        tileHeight,\n      });\n    }\n  };\n\n  // Returns a string representing the bounding-box for the supplied tile.\n  // (WMS-version 1.3.0)\n  // If the WMS-version is set to 1.3.0 the axis-orientation should be set by the\n  // definition of the projection. However, in 'ConfigMapper.js' we specify the\n  // axis-direction as 'NEU' (northing, easting, up). This means we can assume\n  // that the axis-direction is 'NEU' when dealing with version 1.3.0.\n  getVersionThreeBoundingBox = (tile, bBox, height, width) => {\n    // We have to know how much the northing and easting change per pixel, so that we\n    // can calculate proper bounding-boxes for the new tiles.\n    const northingChangePerPixel = (bBox[2] - bBox[0]) / height;\n    const eastingChangePerPixel = (bBox[3] - bBox[1]) / width;\n    // Then we can construct the bounding-box-string:\n    // The bounding-box is calculated by combining how much the bounding-box\n    // changes per pixel, along with the supplied tile height, width, and position\n    // (presented as pixel-values). For information regarding x, and y, see:\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage\n    return `${\n      bBox[0] + northingChangePerPixel * (height - tile.y - tile.tileHeight)\n    },${bBox[1] + eastingChangePerPixel * tile.x},${\n      bBox[0] + northingChangePerPixel * (height - tile.y)\n    }, ${bBox[1] + eastingChangePerPixel * (tile.x + tile.tileWidth)}`;\n  };\n\n  // Returns a string representing the bounding-box for the supplied tile.\n  // (WMS-version 1.1.1)\n  // In version 1.1.1 the axis orientation is always 'ENU' (easting-northing-up).\n  getVersionOneBoundingBox = (tile, bBox, height, width) => {\n    // We have to know how much the northing and easting change per pixel, so that we\n    // can calculate proper bounding-boxes for the new tiles.\n    const northingChangePerPixel = (bBox[3] - bBox[1]) / height;\n    const eastingChangePerPixel = (bBox[2] - bBox[0]) / width;\n    // Then we can construct the bounding-box-string:\n    // The bounding-box is calculated by combining how much the bounding-box\n    // changes per pixel, along with the supplied tile height, width, and position\n    // (presented as pixel-values). For information regarding x, and y, see:\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage\n    return `${bBox[0] + eastingChangePerPixel * tile.x},${\n      bBox[1] + northingChangePerPixel * (height - tile.y - tile.tileHeight)\n    },${bBox[0] + eastingChangePerPixel * (tile.x + tile.tileWidth)},${\n      bBox[1] + northingChangePerPixel * (height - tile.y)\n    }`;\n  };\n\n  // Appends a bounding-box to each tile-information-object.\n  appendBoundingBox = (tiles, bBox, height, width, wmsVersion) => {\n    // The bounding-box calculations might seem a bit messy... One reason for that\n    // is that the x- and y-values for the tiles are set to match how images are added\n    // to a canvas, and those coordinates go the opposite direction compared to the map-coordinate-axels.\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage for more info.\n    // Let's calculate and set the bounding-box for each tile-information-object.\n    for (const tile of tiles) {\n      // We have to make sure to check if we're dealing with version 1.3.0 or 1.1.1\n      // so that we can handle the axis-orientation properly.\n      if (wmsVersion === \"1.3.0\") {\n        tile.bBox = this.getVersionThreeBoundingBox(tile, bBox, height, width);\n      } else {\n        // If we're not dealing with version 1.3.0, we're probably dealing with 1.1.1\n        tile.bBox = this.getVersionOneBoundingBox(tile, bBox, height, width);\n      }\n    }\n  };\n\n  // Returns an array of objects containing information regarding the tiles\n  // that should be created to comply with the supplied 'MAX_TILE_SIZE' and\n  // also 'fill' the image.\n  getTileInformation = (height, width, url) => {\n    // We're gonna want to return an array containing the tile-objects\n    const tiles = [];\n    // We're also gonna need to keep track of the original bounding box. This bounding-box\n    // will be used to calculate the new bounding-boxes for each tile that we're about to create.\n    const bBox = this.getBoundingBoxFromUrl(url);\n    // Since the northing and easting axels are flipped in version 1.1.0 vs 1.3.0 we\n    // have to make sure to check which WMS-version we are dealing with.\n    const wmsVersion = url.searchParams.get(\"VERSION\");\n    // To gather all the required tile-information we will work with 'columns'. This means\n    // we will create all necessary images at a fixed width, and then move to the next width.\n    // We'll do this until we've created enough columns to fill the entire width.\n    let accWidth = 0;\n    while (true) {\n      // If we've created enough columns to fill the supplied width, we can break.\n      if (accWidth >= width) break;\n      // Otherwise we'll check how many pixels remain until we do...\n      const remainingWidth = width - accWidth;\n      // We'll use a tile-width that is either:\n      // - The remaining amount of pixels\n      // - The max tile-size\n      const tileWidth =\n        remainingWidth > this.maxTileSize ? this.maxTileSize : remainingWidth;\n      // Then we'll create a column of tiles\n      tiles.push(...this.getTileColumn(height, accWidth, tileWidth));\n      // And bump the current width\n      accWidth += tileWidth;\n    }\n    // When the tile-information is created, we can append the bounding-box-information\n    // to each tile. The bounding-box-information will be used to fetch the tiles later.\n    this.appendBoundingBox(tiles, bBox, height, width, wmsVersion);\n    // Finally we can return the tile-information.\n    return tiles;\n  };\n\n  // Updates the parameters of the supplied layer to make sure we\n  // request the images in the correct DPI for the print! This function\n  // only handles image-layers.\n  prepareImageLayer = (layer, options) => {\n    // Let's run this in a try-catch just in case\n    try {\n      // We're gonna need to grab the layer-source\n      const source = layer.getSource();\n      // We have to update the image-loading-function (so that the current print-DPI is taken\n      // into consideration).\n      source.setImageLoadFunction((image, src) => {\n        // Let's create an URL-object so that we can easily grab and alter search-parameters.\n        const url = new URL(src);\n        const searchParams = url.searchParams;\n        // We have to make sure to update the search-parameters to include dpi-settings.\n        searchParams.set(\"DPI\", options.resolution);\n        searchParams.set(\"MAP_RESOLUTION\", options.resolution);\n        searchParams.set(\"FORMAT_OPTIONS\", `dpi:${options.resolution}`);\n        // We're gonna need to grab the width and height so that we can make sure the\n        // requested image is not too large for the WMS-server to render. (If we're requesting\n        // too many pixels at a high DPI the server will not be able to create the image).\n        const height = parseFloat(searchParams.get(\"HEIGHT\")) || 1;\n        const width = parseFloat(searchParams.get(\"WIDTH\")) || 1;\n        // What will be too complex for the WMS-servers? Good question. For now,\n        // we say that the image is too complex if either the height or width is larger than\n        // 'this.maxTileSize' (around 4096 probably).\n        if (Math.max(height, width) > this.maxTileSize) {\n          // If the image is too complex, we have to create tiles that are no more than 'this.maxTileSize'\n          // wide or high. Let's gather some tile-information to begin with.\n          const tiles = this.getTileInformation(height, width, url);\n          // Then we'll create a canvas that we can use to draw the tile-images on.\n          const canvas = document.createElement(\"canvas\");\n          // The canvas must be as big as the originally requested image was.\n          canvas.width = width;\n          canvas.height = height;\n          // Let's declare an array that we can use to store all the promises created when\n          // requesting the tile-images.\n          const promises = [];\n          // Then, for each tile-information-object, we'll create a request-url containing the\n          // information that we've gathered (such as the size and bounding-box).\n          for (const tile of tiles) {\n            const tileUrl = new URL(url.toString());\n            tileUrl.searchParams.set(\"BBOX\", tile.bBox);\n            tileUrl.searchParams.set(\"HEIGHT\", tile.tileHeight);\n            tileUrl.searchParams.set(\"WIDTH\", tile.tileWidth);\n            // Then we'll fetch the images from the WMS-server\n            promises.push(\n              this.loadImageTile(canvas, { ...tile, url: tileUrl.toString() })\n            );\n          }\n          // When all image-promises has settled, we can set the image to the canvas on which we've\n          // added all the tile-images.\n          Promise.allSettled(promises).then(() => {\n            image.getImage().src = canvas.toDataURL();\n          });\n        } else {\n          // If the request is not too complex, we can fetch it right away.\n          image.getImage().src = url.toString();\n        }\n      });\n    } catch (error) {\n      console.error(\n        `Failed to update the DPI-options while creating print-image (Single-tile WMS). Error: ${error}`\n      );\n    }\n  };\n\n  // Since we're allowing the user to print the map with different DPI-options,\n  // the layers that are about to be printed must be prepared. The preparation consists\n  // of settings the DPI-parameters so that we ensure that we are sending proper WMS-requests.\n  // (If we would print with 300 dpi, and just let OL send an ordinary request, the images returned\n  // from the server would not show the correct layout for 300 DPI usage).\n  // To do this, we first make sure to exchange all visible layers with \"prepared image-layers\". This is done since\n  // OL seems to do some funky stuff to the tile-layers, and image-layers gives us more control.\n  // TODO: Vector-layers, for example from the draw-plugin, must be handled as well. Otherwise, the text\n  // on vector-layers will be very small when printing with high DPI.\n  prepareActiveLayersForPrint = (options) => {\n    // First we have to exchange all visible tile-, and image-layers for \"print-image-layers\".\n    for (const layer of this.getVisibleTileAndImageLayers()) {\n      this.exchangeLayer(layer, options);\n    }\n    // Then we have to \"prepare\" all currently visible image-layers. Note that all currently\n    // visible image-layers will be layers created in the method above! (Since all other image-layers\n    // has been turned off. They will be turned back on when the printing is complete).\n    for (const imageLayer of this.getVisibleImageLayers()) {\n      this.prepareImageLayer(imageLayer, options);\n    }\n  };\n\n  // Since we've been adding and hiding layers while printing, we have to make sure to reset\n  // everything back to normal!\n  resetPrintLayers = () => {\n    // Since we have been hiding all tile- and image-layers and exchanged them with\n    // \"print-image-layers\", we have to make sure to:\n    // 1. Show the original layers again\n    for (const layer of this.hiddenLayers) {\n      layer.setVisible(true);\n    }\n    // 2. Remove the added image-layers\n    for (const layer of this.addedLayers) {\n      this.map.removeLayer(layer);\n    }\n    // When all layers has been reset and so on, we'll have to reset the collections\n    // containing the added/hidden layers.\n    this.hiddenLayers = new Set();\n    this.addedLayers = new Set();\n  };\n\n  print = (options) => {\n    const format = options.format;\n    const orientation = options.orientation;\n    const resolution = options.resolution;\n    const scale = options.scale / 1000;\n\n    // Our dimensions are for landscape orientation by default. Flip the values if portrait orientation requested.\n    const dim =\n      orientation === \"portrait\"\n        ? [...this.dims[format]].reverse()\n        : this.dims[format];\n\n    const width = Math.round((dim[0] * resolution) / 25.4);\n    const height = Math.round((dim[1] * resolution) / 25.4);\n\n    // Since we're allowing the users to choose which DPI they want to print the map\n    // in, we have to make sure to prepare the layers so that they are fetched with\n    // the correct DPI-settings! We're only doing this if we're supposed to. An admin\n    // might choose not to use this functionality (useCustomTileLoaders set to false).\n    this.useCustomTileLoaders && this.prepareActiveLayersForPrint(options);\n\n    // Before we're printing we must make sure to change the map-view from the\n    // original one, to the print-view.\n    this.printView.setCenter(this.originalView.getCenter());\n    this.map.setView(this.printView);\n\n    // Store mapsize, it's needed when map is restored after print or cancel.\n    this.originalMapSize = this.map.getSize();\n\n    const scaleResolution = this.getScaleResolution(\n      scale,\n      resolution,\n      this.map.getView().getCenter()\n    );\n\n    // Save some of our values that are necessary to use if user want to cancel the process\n\n    this.map.once(\"rendercomplete\", async () => {\n      if (this.pdfCreationCancelled === true) {\n        this.pdfCreationCancelled = false;\n        return false;\n      }\n\n      // This is needed to prevent some buggy output from some browsers\n      // when a lot of tiles are being rendered (it could result in black\n      // canvas PDF)\n      await delay(500);\n\n      // Create the map canvas that will hold all of our map tiles\n      const mapCanvas = document.createElement(\"canvas\");\n\n      // Set canvas dimensions to the newly calculated ones that take user's desired resolution etc into account\n      mapCanvas.width = width;\n      mapCanvas.height = height;\n\n      const mapContext = mapCanvas.getContext(\"2d\");\n      const backgroundColor = this.getMapBackgroundColor(); // Make sure we use the same background-color as the map\n      mapContext.fillStyle = backgroundColor;\n      mapContext.fillRect(0, 0, width, height);\n\n      // Each canvas element inside OpenLayer's viewport should get printed\n      document.querySelectorAll(\".ol-viewport canvas\").forEach((canvas) => {\n        if (canvas.width > 0) {\n          const opacity = canvas.parentNode.style.opacity;\n          mapContext.globalAlpha = opacity === \"\" ? 1 : Number(opacity);\n          // Get the transform parameters from the style's transform matrix\n          if (canvas.style.transform) {\n            const matrix = canvas.style.transform\n              .match(/^matrix\\(([^(]*)\\)$/)[1]\n              .split(\",\")\n              .map(Number);\n            // Apply the transform to the export map context\n            CanvasRenderingContext2D.prototype.setTransform.apply(\n              mapContext,\n              matrix\n            );\n          }\n          mapContext.drawImage(canvas, 0, 0);\n        }\n      });\n\n      // Initiate the PDF object\n      const pdf = new jsPDF({\n        orientation,\n        format,\n        putOnlyUsedFonts: true,\n        compress: true,\n      });\n\n      // Add our map canvas to the PDF, start at x/y=0/0 and stretch for entire width/height of the canvas\n      pdf.addImage(mapCanvas, \"JPEG\", 0, 0, dim[0], dim[1]);\n\n      // Add potential margin around the image\n      if (this.margin > 0) {\n        // The lineWidth increases the line width equally to \"both sides\",\n        // therefore, we must have a line width two times the margin we want.\n        if (options.useTextIconsInMargin) {\n          pdf.setLineWidth(this.mapMargin * 2);\n        } else {\n          pdf.setLineWidth(this.margin * 2);\n        }\n        // We always want a white margin\n        pdf.setDrawColor(\"red\");\n        // Draw the border (margin) around the entire image\n        if (options.useTextIconsInMargin) {\n          pdf.rect(0, 0, dim[0], dim[1], \"S\");\n        } else {\n          pdf.rect(0, 0, dim[0], dim[1], \"S\");\n        }\n      }\n\n      // If logo URL is provided, add the logo to the map\n      if (options.includeLogo && this.logoUrl.trim().length >= 5) {\n        try {\n          const {\n            data: logoData,\n            width: logoWidth,\n            height: logoHeight,\n          } = await this.getImageForPdfFromUrl(this.logoUrl, this.logoMaxWidth);\n\n          let logoPlacement = this.getPlacement(\n            options.logoPlacement,\n            logoWidth,\n            logoHeight,\n            dim[0],\n            dim[1]\n          );\n\n          pdf.addImage(\n            logoData,\n            \"PNG\",\n            logoPlacement.x,\n            logoPlacement.y,\n            logoWidth,\n            logoHeight\n          );\n        } catch (error) {\n          // The image loading may fail due to e.g. wrong URL, so let's catch the rejected Promise\n          this.localObserver.publish(\"error-loading-logo-image\");\n        }\n      }\n\n      if (options.includeNorthArrow && this.northArrowUrl.trim().length >= 5) {\n        try {\n          const {\n            data: arrowData,\n            width: arrowWidth,\n            height: arrowHeight,\n          } = await this.getImageForPdfFromUrl(this.northArrowUrl, 10);\n\n          const arrowPlacement = this.getPlacement(\n            options.northArrowPlacement,\n            arrowWidth,\n            arrowHeight,\n            dim[0],\n            dim[1]\n          );\n\n          pdf.addImage(\n            arrowData,\n            \"PNG\",\n            arrowPlacement.x,\n            arrowPlacement.y,\n            arrowWidth,\n            arrowHeight\n          );\n        } catch (error) {\n          // The image loading may fail due to e.g. wrong URL, so let's catch the rejected Promise\n          this.localObserver.publish(\"error-loading-arrow-image\");\n        }\n      }\n\n      if (options.includeScaleBar) {\n        this.addScaleBar(\n          pdf,\n          options.mapTextColor,\n          options.scale,\n          options.resolution,\n          options.scaleBarPlacement,\n          scaleResolution,\n          options.format,\n          options.orientation\n        );\n      }\n\n      // Add map title if user supplied one\n      if (options.mapTitle.trim().length > 0) {\n        let yPos = options.useTextIconsInMargin ? 16 : 12 + this.margin;\n        pdf.setFontSize(24);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(options.mapTitle, dim[0] / 2, yPos, {\n          align: \"center\",\n        });\n      }\n\n      // Add print comment if user supplied one\n      if (options.printComment.trim().length > 0) {\n        let yPos = options.useTextIconsInMargin ? 22 : 18 + this.margin;\n        pdf.setFontSize(11);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(options.printComment, dim[0] / 2, yPos, {\n          align: \"center\",\n        });\n      }\n\n      // Add potential copyright text\n      if (this.copyright.length > 0) {\n        let yPos = options.useTextIconsInMargin ? 6 : this.margin;\n        pdf.setFontSize(8);\n        pdf.setTextColor(options.mapTextColor);\n        pdf.text(this.copyright, dim[0] - 4 - yPos, dim[1] - 4 - yPos, {\n          align: \"right\",\n        });\n      }\n\n      // Add potential disclaimer text\n      if (this.disclaimer.length > 0) {\n        let yPos = options.useTextIconsInMargin ? 6 : this.margin;\n        pdf.setFontSize(8);\n        pdf.setTextColor(options.mapTextColor);\n        let textLines = pdf.splitTextToSize(\n          this.disclaimer,\n          dim[0] / 2 - this.margin - 8\n        );\n        let textLinesDims = pdf.getTextDimensions(textLines, { fontSize: 8 });\n        pdf.text(\n          textLines,\n          dim[0] - 4 - yPos,\n          dim[1] - 6 - yPos - textLinesDims.h,\n          {\n            align: \"right\",\n          }\n        );\n      }\n\n      // Since we've been messing with the layer-settings while printing, we have to\n      // make sure to reset these settings. (Should only be done if custom loaders has been used).\n      this.useCustomTileLoaders && this.resetPrintLayers();\n\n      // Finally, save the PDF (or PNG)\n      this.saveToFile(pdf, width, options.saveAsType)\n        .then(() => {\n          this.localObserver.publish(\"print-completed\");\n        })\n        .catch((error) => {\n          console.warn(error);\n          this.localObserver.publish(\"print-failed-to-save\");\n        })\n        .finally(() => {\n          // Reset map to how it was before print\n          this.restoreOriginalView();\n        });\n    });\n\n    // Get print center from preview feature's center coordinate\n    const printCenter = getCenter(\n      this.previewFeature.getGeometry().getExtent()\n    );\n\n    // Hide our preview feature so it won't get printed\n    this.previewLayer.setVisible(false);\n\n    // Set map size and resolution, this will initiate print, as we have a listener for renderComplete.\n    // (Which will fire when the new size and resolution has been set and the new tiles has been loaded).\n    this.map.getTargetElement().style.width = `${width}px`;\n    this.map.getTargetElement().style.height = `${height}px`;\n    this.map.updateSize();\n    this.map.getView().setCenter(printCenter);\n    this.map.getView().setResolution(scaleResolution);\n  };\n\n  restoreOriginalView = () => {\n    this.previewLayer.setVisible(true);\n    this.map.setSize(this.originalMapSize);\n    this.map.getTargetElement().style.width = \"\";\n    this.map.getTargetElement().style.height = \"\";\n    this.map.updateSize();\n    this.map.setView(this.originalView);\n  };\n\n  // Imports and returns the dependencies required to create a PNG-print-export.\n  #getPngDependencies = async () => {\n    try {\n      const pdfjs = await import(\"pdfjs-dist/build/pdf\");\n      return { pdfjs };\n    } catch (error) {\n      throw new Error(\n        `Failed to import required dependencies. Error: ${error}`\n      );\n    }\n  };\n\n  // Saves the supplied PDF with the supplied file-name.\n  #saveToPdf = async (pdf, fileName) => {\n    try {\n      pdf.save(`${fileName}.pdf`);\n    } catch (error) {\n      throw new Error(`Failed to save PDF. Error: ${error}`);\n    }\n  };\n\n  // Saves the supplied PDF *as a PNG* with the supplied file-name.\n  // The width of the document has to be supplied since some calculations\n  // must be done in order to create a PNG with the correct resolution etc.\n  #saveToPng = async (pdf, fileName, width) => {\n    try {\n      // First we'll dynamically import the required dependencies.\n      const { pdfjs } = await this.#getPngDependencies();\n      // Then we'll set up the pdfJS-worker. TODO: Terrible?! PDF-js does not seem to have a better solution for the\n      // source-map-errors that occur from setting the worker the ordinary way.\n      pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`;\n      // We'll output the PDF as an array-buffer that can be used to create the PNG.\n      const ab = pdf.output(\"arraybuffer\");\n      // We'll use the PDF-JS library to create a new \"PDF-JS-PDF\". (Wasteful? Yes very, but the JS-PDF-library\n      // does not support export to any other format than PDF, and the PDF-JS-library does.) Notice that\n      // JS-PDF and PDF-JS are two different libraries, both with their pros and cons.\n      // - PDF-JS: Pro => Can export to PNG, Con: Cannot create as nice of an image as JS-PDF.\n      // - JS-PDF: Pro => Creates good-looking PDFs, Con: Cannot export to PNG.\n      // - Conclusion: We use both...\n      pdfjs.getDocument({ data: ab }).promise.then((pdf) => {\n        // So, when the PDF-JS-PDF is created, we get the first page, and then render\n        // it on a canvas so that we can export it as a PNG.\n        pdf.getPage(1).then((page) => {\n          // We're gonna need a canvas and its context.\n          let canvas = document.createElement(\"canvas\");\n          let ctx = canvas.getContext(\"2d\");\n          // Scale the viewport to match current resolution\n          const viewport = page.getViewport({ scale: 1 });\n          const scale = width / viewport.width;\n          const scaledViewport = page.getViewport({ scale: scale });\n          // Create the render-context-object.\n          const renderContext = {\n            canvasContext: ctx,\n            viewport: scaledViewport,\n          };\n          // Set the canvas dimensions to the correct width and height.\n          canvas.height = scaledViewport.height;\n          canvas.width = scaledViewport.width;\n          // Then we'll render and save!\n          page.render(renderContext).promise.then(() => {\n            canvas.toBlob((blob) => {\n              saveAs(blob, `${fileName}.png`);\n            });\n          });\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to save PNG. Error: ${error}`);\n    }\n  };\n\n  // Saves the print-contents to file, either PDF, or PNG (depending on supplied type).\n  saveToFile = async (pdf, width, type) => {\n    // We're gonna need to create a file-name.\n    const fileName = `Kartexport - ${new Date().toLocaleString()}`;\n    // Then we'll try to save the contents in the format the user requested.\n    try {\n      switch (type) {\n        case \"PDF\":\n          return this.#saveToPdf(pdf, fileName);\n        case \"PNG\":\n          return this.#saveToPng(pdf, fileName, width);\n        default:\n          throw new Error(\n            `Supplied type could not be handled. The supplied type was ${type} and currently only PDF and PNG is supported.`\n          );\n      }\n    } catch (error) {\n      throw new Error(`Failed to save file... ${error}`);\n    }\n  };\n\n  cancelPrint = () => {\n    // Set this flag to prevent \"rendercomplete\" from firing\n    this.pdfCreationCancelled = true;\n\n    // Reset map to how it was before print\n    this.restoreOriginalView();\n    // Reset the layer-settings to how it was before print.\n    // (Should only be done if custom loaders has been used).\n    this.useCustomTileLoaders && this.resetPrintLayers();\n  };\n\n  /**\n   * @description Using toLocalString for sv-SE is the easiest way to get space as thousand separator.\n   *\n   * @param {*} scale Number that will be prefixed with \"1:\"\n   * @returns {string} Input parameter, prefixed by \"1:\" and with spaces as thousands separator, e.g \"5000\" -> \"1:5 000\".\n   */\n  getUserFriendlyScale = (scale) => {\n    return `1:${Number(scale).toLocaleString(\"sv-SE\")}`;\n  };\n}\n"],"names":["PrintModel","settings","scaleBarLengths","previewLayer","previewFeature","marginAmount","textIconMarginAmount","margin","textIconsMargin","mapMargin","pdfCreationCancelled","getMapScale","printView","setZoom","originalView","getZoom","mpu","getProjection","getMetersPerUnit","getResolution","getFittingScale","proposedScale","scales","reduce","prev","curr","Math","abs","removePreview","undefined","getSource","clear","map","removeInteraction","translate","getPreviewCenter","extent","getGeometry","getExtent","getCenter","getMargin","paperDim","max","getPaperDim","format","orientation","dims","reverse","renderPreviewFeature","previewLayerVisible","options","addPreview","getImageDataBlobFromUrl","url","Promise","resolve","reject","image","Image","setAttribute","onerror","err","onload","imgCanvas","document","createElement","width","this","naturalWidth","height","naturalHeight","getContext","drawImage","data","toDataURL","src","getImageForPdfFromUrl","maxWidth","sourceWidth","sourceHeight","ratio","getPlacement","placement","contentWidth","contentHeight","pdfWidth","pdfHeight","pdfPlacement","x","y","getFittingScaleBarLength","scale","length","getLengthText","scaleBarLengthMeters","units","Number","toLocaleString","drawScaleBar","pdf","scaleBarPosition","color","scaleBarLength","lengthText","setFontSize","setFont","setTextColor","setLineWidth","text","getUserFriendlyScale","toUpperCase","setDrawColor","line","addScaleBar","resolution","scaleBarPlacement","scaleResolution","pixelSize","internal","pageSize","desiredPrintOptionsOk","getScaleResolution","getView","getMinResolution","center","getPointResolution","getMapBackgroundColor","currentBackgroundColor","getElementById","style","backgroundColor","getVisibleTileAndImageLayers","getLayers","getArray","filter","layer","getVisible","layerIsTileOrImageLayer","TileLayer","TileWMS","ImageLayer","ImageWMS","getVisibleImageLayers","getLayerPlacementIndex","l","get","indexOf","exchangeLayer","setVisible","hiddenLayers","add","source","imageSource","getProperties","projection","crossOrigin","params","getParams","hidpi","layerOpacity","getOpacity","imageLayer","opacity","layerPlacement","insertAt","addedLayers","error","console","getBoundingBoxFromUrl","searchParams","split","coord","parseFloat","loadImageTile","canvas","tileOptions","ctx","tileWidth","tileHeight","tile","getTileColumn","targetHeight","tiles","accHeight","acc","remainingHeight","maxTileSize","push","getVersionThreeBoundingBox","bBox","northingChangePerPixel","eastingChangePerPixel","getVersionOneBoundingBox","appendBoundingBox","wmsVersion","getTileInformation","accWidth","remainingWidth","prepareImageLayer","setImageLoadFunction","URL","set","promises","tileUrl","toString","allSettled","then","getImage","prepareActiveLayersForPrint","resetPrintLayers","removeLayer","Set","print","dim","round","useCustomTileLoaders","setCenter","setView","originalMapSize","getSize","once","delay","mapCanvas","mapContext","fillStyle","fillRect","querySelectorAll","forEach","parentNode","globalAlpha","transform","matrix","match","CanvasRenderingContext2D","prototype","setTransform","apply","jsPDF","putOnlyUsedFonts","compress","addImage","useTextIconsInMargin","rect","includeLogo","logoUrl","trim","logoMaxWidth","logoData","logoWidth","logoHeight","logoPlacement","localObserver","publish","includeNorthArrow","northArrowUrl","arrowData","arrowWidth","arrowHeight","arrowPlacement","northArrowPlacement","includeScaleBar","mapTextColor","mapTitle","yPos","align","printComment","copyright","disclaimer","textLines","splitTextToSize","textLinesDims","getTextDimensions","fontSize","h","saveToFile","saveAsType","catch","warn","finally","restoreOriginalView","printCenter","getTargetElement","updateSize","setResolution","setSize","pdfjs","Error","fileName","save","GlobalWorkerOptions","workerSrc","version","ab","output","getDocument","promise","getPage","page","viewport","getViewport","scaledViewport","renderContext","canvasContext","render","toBlob","blob","saveAs","type","Date","cancelPrint","logo","northArrow","mapConfig","View","constrainOnlyCenter","constrainResolution","maxZoom","minZoom","resolutions","allResolutions","zoom","Vector","VectorSource","layerType","zIndex","name","caption","Style","stroke","Stroke","fill","Fill","addLayer","useMargin","dpi","sizeHeight","paper","w","coords","feature","Feature","geometry","Polygon","addFeature","Translate","features","Collection","addInteraction"],"sourceRoot":""}