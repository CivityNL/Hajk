{"version":3,"file":"static/js/9565.02bb058b.chunk.js","mappings":"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","sources":["plugins/Measure/MeasureModel.js","../node_modules/ol/Overlay.js"],"sourcesContent":["import { Circle as CircleStyle, Fill, Stroke, Style, Text } from \"ol/style.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\nimport { LineString, Polygon } from \"ol/geom.js\";\nimport Draw from \"ol/interaction/Draw.js\";\n\nimport Overlay from \"ol/Overlay\";\n\nclass MeasureModel {\n  constructor(settings) {\n    this.map = settings.map;\n    this.app = settings.app;\n    this.localObserver = settings.localObserver;\n    this.source = new VectorSource();\n    this.vector = new VectorLayer({\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginMeasure\",\n      caption: \"Measure layer\",\n      source: this.source,\n      style: this.createStyle,\n    });\n    this.map.addLayer(this.vector);\n    this.type = \"LineString\";\n    this.createMeasureTooltip();\n  }\n\n  createStyle = (feature, resolution) => {\n    const fillColor = \"rgba(255, 255, 255, 0.3)\";\n    const strokeColor = \"rgba(0, 0, 0, 0.5)\";\n    return [\n      new Style({\n        fill: new Fill({\n          color: fillColor,\n        }),\n        stroke: new Stroke({\n          color: strokeColor,\n          width: 3,\n        }),\n        image: new CircleStyle({\n          radius: 5,\n          stroke: new Stroke({\n            color: strokeColor,\n          }),\n          fill: new Fill({\n            color: fillColor,\n          }),\n        }),\n        text: new Text({\n          textAlign: \"center\",\n          textBaseline: \"middle\",\n          font: \"12pt sans-serif\",\n          fill: new Fill({ color: \"#FFF\" }),\n          text: this.getLabelText(feature),\n          overflow: true,\n          stroke: new Stroke({\n            color: strokeColor,\n            width: 3,\n          }),\n          offsetX: 0,\n          offsetY: -10,\n          rotation: 0,\n          scale: 1,\n        }),\n      }),\n    ];\n  };\n\n  clear = () => {\n    this.source.clear();\n    this.measureTooltip.setPosition(undefined);\n  };\n\n  handleDrawStart = (e) => {\n    e.feature.getGeometry().on(\"change\", (e) => {\n      var toolTip = \"\",\n        coord = undefined,\n        pointerCoord;\n\n      if (this.active) {\n        if (this.pointerPosition) {\n          pointerCoord = this.pointerPosition.coordinate;\n        }\n\n        if (e.target instanceof LineString) {\n          toolTip = this.formatLabel(\"length\", e.target.getLength());\n          coord = e.target.getLastCoordinate();\n        }\n\n        if (e.target instanceof Polygon) {\n          toolTip = this.formatLabel(\"area\", e.target.getArea());\n          coord = pointerCoord || e.target.getFirstCoordinate();\n        }\n\n        this.measureTooltipElement.innerHTML = toolTip;\n        this.measureTooltip.setPosition(coord);\n      }\n    });\n  };\n\n  handleDrawEnd = (e) => {\n    this.setFeaturePropertiesFromGeometry(e.feature);\n    this.measureTooltip.setPosition(undefined);\n  };\n\n  setType(type) {\n    this.type = type;\n    this.removeInteraction();\n    this.addInteraction();\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  setFeaturePropertiesFromGeometry(feature) {\n    if (!feature) return;\n    var geom,\n      type = \"\",\n      length = 0,\n      radius = 0,\n      area = 0,\n      position = {\n        n: 0,\n        e: 0,\n      };\n    geom = feature.getGeometry();\n    type = geom.getType();\n    switch (type) {\n      case \"Point\":\n        position = {\n          n: Math.round(geom.getCoordinates()[1]),\n          e: Math.round(geom.getCoordinates()[0]),\n        };\n        break;\n      case \"LineString\":\n        if (geom.getLength() < 1000) {\n          length = Math.round(geom.getLength() * 10) / 10;\n        } else {\n          length = Math.round(geom.getLength());\n        }\n        break;\n      case \"Polygon\":\n        area = Math.round(geom.getArea());\n        break;\n      case \"Circle\":\n        radius = Math.round(geom.getRadius());\n        break;\n      default:\n        break;\n    }\n    feature.setProperties({\n      type: type,\n      length: length,\n      area: area,\n      radius: radius,\n      position: position,\n    });\n  }\n\n  formatLabel(type, value) {\n    let label;\n\n    if (type === \"point\") {\n      label = \"Nord: \" + value.n + \" Öst: \" + value.e;\n    }\n\n    if (typeof value === \"number\") {\n      if (type === \"length\" && value < 1000) {\n        value = Math.round(value * 10) / 10;\n      } else {\n        value = Math.round(value);\n      }\n    }\n\n    if (type === \"circle\") {\n      let unit = \" m\";\n      let squareUnit = \" m²\";\n      if (value >= 1000) {\n        unit = \" km\";\n        value = value / 1000;\n      }\n      label =\n        \"R = \" +\n        Number(value).toLocaleString() +\n        unit +\n        \" \\nA = \" +\n        (Math.round(value * value * Math.PI * 1000) / 1000).toLocaleString() +\n        squareUnit;\n    }\n\n    if (type === \"area\") {\n      if (value > 100000) {\n        label =\n          Number(Math.round((value / 1000000) * 100) / 100).toLocaleString() +\n          \" km²\";\n      } else {\n        label = Number(Math.round(value * 100) / 100).toLocaleString() + \" m²\";\n      }\n    }\n\n    if (type === \"length\") {\n      let unit = \" m\";\n      if (value >= 1000) {\n        unit = \" km\";\n        value = value / 1000;\n      }\n      label = Number(value).toLocaleString() + unit;\n    }\n\n    return label;\n  }\n\n  createMeasureTooltip() {\n    if (this.measureTooltipElement) {\n      this.measureTooltipElement.parentNode.removeChild(\n        this.measureTooltipElement\n      );\n    }\n    this.measureTooltipElement = document.createElement(\"div\");\n    this.measureTooltipElement.className = \"tooltip-draw tooltip-measure\";\n    this.measureTooltip = new Overlay({\n      element: this.measureTooltipElement,\n      offset: [0, -15],\n      positioning: \"bottom-center\",\n    });\n    this.map.addOverlay(this.measureTooltip);\n  }\n\n  getLabelText(feature) {\n    const props = feature.getProperties();\n    const type = feature.getProperties().type;\n    switch (type) {\n      case \"Point\":\n        return this.formatLabel(\"point\", props.position);\n      case \"LineString\":\n        return this.formatLabel(\"length\", props.length);\n      case \"Circle\":\n        return this.formatLabel(\"circle\", props.radius);\n      case \"Polygon\":\n        return this.formatLabel(\"area\", props.area);\n      default:\n        return \"\";\n    }\n  }\n\n  addInteraction() {\n    this.draw = new Draw({\n      source: this.source,\n      type: this.type,\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 255, 255, 0.2)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(0, 0, 0, 0.5)\",\n          lineDash: [10, 10],\n          width: 2,\n        }),\n        image: new CircleStyle({\n          radius: 5,\n          stroke: new Stroke({\n            color: \"rgba(0, 0, 0, 0.7)\",\n          }),\n          fill: new Fill({\n            color: \"rgba(255, 255, 255, 0.2)\",\n          }),\n        }),\n      }),\n    });\n    this.draw.on(\"drawstart\", this.handleDrawStart);\n    this.draw.on(\"drawend\", this.handleDrawEnd);\n    this.map.addInteraction(this.draw);\n\n    // Add snap interactions AFTER measure source has been added\n    // this will allow us to snap to the newly added source too\n    this.map.snapHelper.add(\"measure\");\n  }\n\n  removeInteraction() {\n    this.measureTooltip.setPosition(undefined);\n    this.map.snapHelper.delete(\"measure\");\n    this.map.removeInteraction(this.draw);\n  }\n\n  eventHandler = (event) => {\n    const key = event.key; // Or const {key} = event; in ES6+\n    if (key === \"Escape\") {\n      this.draw.finishDrawing();\n    }\n  };\n\n  setActive(active) {\n    if (active && !this.active) {\n      document.addEventListener(\"keydown\", this.eventHandler);\n      this.addInteraction();\n      this.map.clickLock.add(\"measure\");\n    }\n    if (active === false) {\n      document.removeEventListener(\"keydown\", this.eventHandler);\n      this.removeInteraction();\n      this.map.clickLock.delete(\"measure\");\n    }\n    this.active = active;\n  }\n\n  getMap() {\n    return this.map;\n  }\n}\n\nexport default MeasureModel;\n","/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport {CLASS_SELECTABLE} from './css.js';\nimport {containsExtent} from './extent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {outerHeight, outerWidth, removeChildren, removeNode} from './dom.js';\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nconst Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning',\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nclass Overlay extends BaseObject {\n  /**\n   * @param {Options} options Overlay options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst =\n      options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = document.createElement('div');\n    this.element.className =\n      options.className !== undefined\n        ? options.className\n        : 'ol-overlay-container ' + CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      transform_: '',\n      visible: true,\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n\n    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);\n    this.addChangeListener(Property.MAP, this.handleMapChanged);\n    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);\n    this.addChangeListener(Property.POSITION, this.handlePositionChanged);\n    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n\n    this.setPositioning(options.positioning || 'top-left');\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  getElement() {\n    return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n  }\n\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id;\n  }\n\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./Map.js\").default|null} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n  getMap() {\n    return /** @type {import(\"./Map.js\").default|null} */ (\n      this.get(Property.MAP) || null\n    );\n  }\n\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n  getOffset() {\n    return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n  }\n\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the current positioning of this overlay.\n   * @return {Positioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  getPositioning() {\n    return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n  }\n\n  /**\n   * @protected\n   */\n  handleElementChanged() {\n    removeChildren(this.element);\n    const element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      removeNode(this.element);\n      unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    const map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = listen(\n        map,\n        MapEventType.POSTRENDER,\n        this.render,\n        this\n      );\n      this.updatePixelPosition();\n      const container = this.stopEvent\n        ? map.getOverlayContainerStopEvent()\n        : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handleOffsetChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositionChanged() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositioningChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  setElement(element) {\n    this.set(Property.ELEMENT, element);\n  }\n\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./Map.js\").default|null} map The map that the\n   * overlay is part of. Pass `null` to just remove the overlay from the current map.\n   * @observable\n   * @api\n   */\n  setMap(map) {\n    this.set(Property.MAP, map);\n  }\n\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  }\n\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  setPosition(position) {\n    this.set(Property.POSITION, position);\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary) using the configured autoPan parameters\n   * @protected\n   */\n  performAutoPan() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n   * @api\n   */\n  panIntoView(panIntoViewOptions) {\n    const map = this.getMap();\n\n    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n      return;\n    }\n\n    const mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    const element = this.getElement();\n    const overlayRect = this.getRect(element, [\n      outerWidth(element),\n      outerHeight(element),\n    ]);\n\n    panIntoViewOptions = panIntoViewOptions || {};\n\n    const myMargin =\n      panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n    if (!containsExtent(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      const offsetLeft = overlayRect[0] - mapRect[0];\n      const offsetRight = mapRect[2] - overlayRect[2];\n      const offsetTop = overlayRect[1] - mapRect[1];\n      const offsetBottom = mapRect[3] - overlayRect[3];\n\n      const delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        const center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n          map.getView().getCenterInternal()\n        );\n        const centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n\n        const panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement} element The element.\n   * @param {import(\"./size.js\").Size} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n  getRect(element, size) {\n    const box = element.getBoundingClientRect();\n    const offsetX = box.left + window.pageXOffset;\n    const offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  }\n\n  /**\n   * Set the positioning for this overlay.\n   * @param {Positioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  }\n\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  }\n\n  /**\n   * Update pixel position.\n   * @protected\n   */\n  updatePixelPosition() {\n    const map = this.getMap();\n    const position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    const pixel = map.getPixelFromCoordinate(position);\n    const mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  }\n\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n  updateRenderedPosition(pixel, mapSize) {\n    const style = this.element.style;\n    const offset = this.getOffset();\n\n    const positioning = this.getPositioning();\n\n    this.setVisible(true);\n\n    const x = Math.round(pixel[0] + offset[0]) + 'px';\n    const y = Math.round(pixel[1] + offset[1]) + 'px';\n    let posX = '0%';\n    let posY = '0%';\n    if (\n      positioning == 'bottom-right' ||\n      positioning == 'center-right' ||\n      positioning == 'top-right'\n    ) {\n      posX = '-100%';\n    } else if (\n      positioning == 'bottom-center' ||\n      positioning == 'center-center' ||\n      positioning == 'top-center'\n    ) {\n      posX = '-50%';\n    }\n    if (\n      positioning == 'bottom-left' ||\n      positioning == 'bottom-center' ||\n      positioning == 'bottom-right'\n    ) {\n      posY = '-100%';\n    } else if (\n      positioning == 'center-left' ||\n      positioning == 'center-center' ||\n      positioning == 'center-right'\n    ) {\n      posY = '-50%';\n    }\n    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;\n    if (this.rendered.transform_ != transform) {\n      this.rendered.transform_ = transform;\n      style.transform = transform;\n    }\n  }\n\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n  getOptions() {\n    return this.options;\n  }\n}\n\nexport default Overlay;\n"],"names":["MeasureModel","settings","createStyle","feature","resolution","fillColor","strokeColor","Style","fill","Fill","color","stroke","Stroke","width","image","CircleStyle","radius","text","Text","textAlign","textBaseline","font","getLabelText","overflow","offsetX","offsetY","rotation","scale","clear","source","measureTooltip","setPosition","undefined","handleDrawStart","e","getGeometry","on","pointerCoord","toolTip","coord","active","pointerPosition","coordinate","target","LineString","formatLabel","getLength","getLastCoordinate","Polygon","getArea","getFirstCoordinate","measureTooltipElement","innerHTML","handleDrawEnd","setFeaturePropertiesFromGeometry","eventHandler","event","key","draw","finishDrawing","this","map","app","localObserver","VectorSource","vector","VectorLayer","layerType","zIndex","name","caption","style","addLayer","type","createMeasureTooltip","removeInteraction","addInteraction","geom","length","area","position","n","getType","Math","round","getCoordinates","getRadius","setProperties","value","label","unit","Number","toLocaleString","PI","parentNode","removeChild","document","createElement","className","Overlay","element","offset","positioning","addOverlay","props","getProperties","Draw","lineDash","snapHelper","add","delete","addEventListener","clickLock","removeEventListener","Property","options","once","un","id","insertFirst","stopEvent","CLASS_SELECTABLE","pointerEvents","autoPan","rendered","transform_","visible","mapPostrenderListenerKey","addChangeListener","handleElementChanged","handleMapChanged","handleOffsetChanged","handlePositionChanged","handlePositioningChanged","setElement","setOffset","setPositioning","get","removeChildren","getElement","appendChild","removeNode","unlistenByKey","getMap","listen","MapEventType","render","updatePixelPosition","container","getOverlayContainerStopEvent","getOverlayContainer","insertBefore","childNodes","performAutoPan","set","panIntoView","panIntoViewOptions","getTargetElement","mapRect","getRect","getSize","overlayRect","outerWidth","outerHeight","myMargin","margin","containsExtent","offsetLeft","offsetRight","offsetTop","offsetBottom","delta","abs","center","getView","getCenterInternal","centerPx","getPixelFromCoordinateInternal","newCenterPx","panOptions","animation","animateInternal","getCoordinateFromPixelInternal","duration","easing","size","box","getBoundingClientRect","left","window","pageXOffset","top","pageYOffset","display","getPosition","isRendered","pixel","getPixelFromCoordinate","mapSize","updateRenderedPosition","setVisible","getOffset","getPositioning","x","y","posX","posY","transform","BaseObject"],"sourceRoot":""}