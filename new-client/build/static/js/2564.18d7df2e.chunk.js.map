{"version":3,"file":"static/js/2564.18d7df2e.chunk.js","mappings":"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","sources":["plugins/FmeServer/models/FmeServerModel.js"],"sourcesContent":["import { hfetch } from \"../../../utils/FetchWrapper\";\n\nclass FmeServerModel {\n  #options;\n  #mapServiceBase;\n  #mapViewModel;\n  #activeUserEmail;\n\n  constructor(settings) {\n    this.#options = settings.options;\n    this.#mapServiceBase = settings.app.config.appConfig.mapserviceBase;\n    this.#activeUserEmail = settings.app.config.userDetails?.mail ?? \"\";\n    this.#mapViewModel = settings.mapViewModel;\n  }\n\n  // A get:er to return the active user:s email.\n  getActiveUserEmail = () => {\n    return this.#activeUserEmail;\n  };\n\n  // Returns the product matching the group and product name.\n  getProduct = (groupName, productName) => {\n    if (groupName?.length === 0 || productName?.length === 0) {\n      return null;\n    }\n    return this.#options.products.find((product) => {\n      return product.group === groupName && product.name === productName;\n    });\n  };\n\n  // Entry point for when user clicks the \"Order\" button.\n  // We're targeting different FME-server endpoints determined by wether\n  // The userEmail has been supplied or not. (If the userEmail is supplied\n  // it means that the admin has registered the product as an data-download\n  // product rather than a product that should target the regular FME-server REST-API).\n  makeOrder = (groupName, productName, productParameters, userEmail) => {\n    // We're gonna need the product\n    const product = this.getProduct(groupName, productName);\n    // If user email is supplied and prompted for, it means that we are dealing\n    // with data-download, not the ordinary REST-api.\n    // The user email might not be an empty string if AD-lookup is enabled\n    // and user-details are exposed to the client, which means that we must\n    // check that the product is set to prompt for email as well.\n    if (userEmail !== \"\" && product.promptForEmail) {\n      return this.#makeDataDownloadOrder(product, productParameters, userEmail);\n    }\n    // If it is not, we're dealing with the regular REST-application\n    return this.#makeRestApiOrder(product, productParameters);\n  };\n\n  // Creates a string to be used for the data-download request\n  // Built upon the userEmail and the parameterValues.\n  #createRequestUrlString = (product, productParameters, userEmail) => {\n    // We're gonna need some base information in the request string, let's add\n    // that first.\n    let requestString = `opt_servicemode=async&opt_responseformat=json&opt_requesteremail=${userEmail}&`;\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add it to the request string.\n      requestString += `${product.geoAttribute}=${geoJson}&`;\n    }\n    productParameters.forEach((parameter) => {\n      requestString += `${this.#getParameterNameValueString(parameter)}&`;\n    });\n    // Then we return the string!\n    return requestString;\n  };\n\n  // Returns a name value string for the supplied parameter\n  #getParameterNameValueString = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All above should be clean strings... TODO: Tests!\n        return `${parameter.name}=${\n          parameter.value ?? parameter.defaultValue ?? \"\"\n        }`;\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These should be array of strings...\n        const selectedArray = parameter.value ?? parameter.defaultValue ?? [];\n        // If the array is empty, we can return an empty string\n        if (selectedArray.length === 0) {\n          return `${parameter.name}=`;\n        }\n        // Otherwise we concatenate a string with all selected values.\n        const urlString = `${parameter.name}=${selectedArray.join(\",\")}`;\n        return urlString;\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return `${parameter.name}=${value}`;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Checks wether the geoAttribute contains a valid value.\n  // (An empty string or \"none\" is to be considered as no geoAttribute\n  // wa supplied).\n  noGeomAttributeSupplied = (product) => {\n    return (\n      !product ||\n      !product.geoAttribute ||\n      product.geoAttribute === \"\" ||\n      product.geoAttribute === \"none\"\n    );\n  };\n\n  // Returns a stepSize that corresponds to the supplied decimalPrecision\n  // E.g. decimalPrecision: 0 => step: 1,\n  //      decimalPrecision: 1 => step: 0.1,\n  //      decimalPrecision: 2 => step: 0.01\n  #getStepSize = (decimalPrecision) => {\n    // Special case, 0 precision should just return 1\n    if (decimalPrecision === 0) {\n      return 1;\n    }\n    // Otherwise we use the padStart string function to create\n    // a float with a fitting number of decimals.\n    return Number(`0.${\"1\".padStart(decimalPrecision, \"0\")}`);\n  };\n\n  // Calculates a fitting stepSize and fetches the current value for\n  // the range slider.\n  getRangeSliderValueAndStep = (parameter) => {\n    // First we get a stepSize that fits the decimalPrecision supplied\n    const step = this.#getStepSize(parameter.decimalPrecision);\n    // Then we get the parameter value (that might be set) or return the\n    // minimum (or the step over the minimum if that should be excluded).\n    const value =\n      parameter.value ?? this.getRangeSliderMinimum(parameter, step);\n    // And return everything\n    return { value, step };\n  };\n\n  // Returns the range slider minimum or the step above if\n  // minimum should be excluded.\n  getRangeSliderMinimum = (parameter, step) => {\n    return parameter.minimumExclusive\n      ? parameter.minimum + step\n      : parameter.minimum;\n  };\n\n  // Returns the range slider maximum or the step below if\n  // minimum should be excluded.\n  getRangeSliderMaximum = (parameter, step) => {\n    return parameter.maximumExclusive\n      ? parameter.maximum - step\n      : parameter.maximum;\n  };\n\n  // Returns the value of the parameter supplied.\n  // Since the parameter types expects different fallback values\n  // we'll have to handle them differently.\n  #getParameterValue = (parameter) => {\n    switch (parameter.type) {\n      case \"CHOICE\":\n      case \"LOOKUP_CHOICE\":\n      case \"STRING\":\n      case \"TEXT\":\n      case \"PASSWORD\":\n        // All of the above expects a single string\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n      case \"LISTBOX\":\n      case \"LOOKUP_LISTBOX\":\n        // These expect an array of strings\n        return parameter.value ?? parameter.defaultValue ?? [];\n      case \"RANGE_SLIDER\":\n        // This one expects a number\n        const { value } = this.getRangeSliderValueAndStep(parameter);\n        return value;\n      default:\n        // Let's default to a string.\n        return parameter.value ?? parameter.defaultValue ?? \"\";\n    }\n  };\n\n  // Returns all parameters with their values in the format that\n  // FME-server expects.\n  #getParametersToSend = (product, productParameters) => {\n    // Initiate an array where all parameter objects will be pushed\n    const parametersToSend = [];\n    // Let's check wether their will be a geometry to send\n    if (!this.noGeomAttributeSupplied(product)) {\n      // If there is, we get the geometries as GeoJSON\n      const geoJson = this.#mapViewModel.getAllFeaturesAsGeoJson();\n      // And add the geoAttribute with it's GeoJSON to the array\n      parametersToSend.push({ name: product.geoAttribute, value: geoJson });\n    }\n    // Then we get all other values and add them to the array\n    productParameters.forEach((parameter) => {\n      const value = this.#getParameterValue(parameter);\n      parametersToSend.push({ name: parameter.name, value: value });\n    });\n    // And return the array.\n    return parametersToSend;\n  };\n\n  // Returns all parameters except the one parameter stated\n  // to be the one containing the geometry.\n  getParametersToRender = (parameters, groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty array\n    if (!product) {\n      return [];\n    }\n    // Otherwise we return the filtered parameters, where the parameter\n    // with the geomAttribute as name is removed.\n    return parameters.filter((parameter) => {\n      return parameter.name !== product.geoAttribute;\n    });\n  };\n\n  getInfoUrl = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return an empty string\n    if (!product) {\n      return \"\";\n    }\n    // Then we'll return the infoUrl, or an empty string if it's missing.\n    return product.infoUrl ?? \"\";\n  };\n\n  // Checks wether we should prompt the user for their email or not\n  shouldPromptForEmail = (groupName, productName) => {\n    // We must fetch the product\n    const product = this.getProduct(groupName, productName);\n    // And make sure it exists. If it doesn't we return false\n    if (!product) {\n      return false;\n    }\n    // Otherwise we return the parameter containing information regarding\n    // email prompting\n    return product.promptForEmail;\n  };\n\n  // Check wethers the provided string is a valid email\n  isValidEmail = (emailString) => {\n    if (typeof emailString !== \"string\") {\n      return false;\n    }\n    const regExp = /\\S+@\\S+\\.\\S+/;\n    return regExp.test(emailString);\n  };\n\n  // Fetches all product parameters from FME-server\n  getProductParameters = async (groupName, productName) => {\n    // If the product is missing for some reason, we return an\n    // error and an empty array.\n    const product = this.getProduct(groupName, productName);\n    if (!product) {\n      return { error: true, parameters: [] };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createGetParametersUrl(product);\n    // And then try to fetch the parameters using the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, parameters: data };\n    } catch (error) {\n      return { error: true, parameters: [] };\n    }\n  };\n\n  // Posts a request to run a workspace on FME-server via the REST-API.\n  // Returns an object containing eventual error and eventual\n  // jobId which can be used to check the status of the job.\n  #makeRestApiOrder = async (product, productParameters) => {\n    // First, we're gonna have to prepare the parameters to send.\n    const parametersToSend = this.#getParametersToSend(\n      product,\n      productParameters\n    );\n    // Let's create the request url\n    const url = this.#createSubmitProductRequestUrl(product);\n    // And the body containing all the parameters\n    const body = JSON.stringify({ publishedParameters: parametersToSend });\n    // And then try to submit the job using that url...\n    try {\n      const response = await hfetch(url, {\n        method: \"POST\",\n        body: body,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data.id ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Handles the data-download order\n  #makeDataDownloadOrder = async (product, productParameters, userEmail) => {\n    // Let's create the base-url for the request.\n    const requestUrl = this.#createDataDownloadUrl(product);\n    // The data-download does not expect the parameters to be be sent\n    // as json. So let's create a string instead TODO: Is this really true?\n    const requestUrlString = this.#createRequestUrlString(\n      product,\n      productParameters,\n      userEmail\n    );\n    // Then we try to fetch with this information\n    try {\n      const response = await hfetch(requestUrl, {\n        method: \"POST\",\n        body: requestUrlString,\n        credentials: \"same-origin\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n      });\n      const data = await response.json();\n      return { error: false, jobId: data?.serviceResponse?.jobID ?? null };\n    } catch (error) {\n      return { error: true, jobId: null };\n    }\n  };\n\n  // Fetches the status for a submitted job\n  getJobStatusById = async (jobId) => {\n    // If the jobId is missing, we return an error.\n    if (!jobId) {\n      return { error: true, status: null };\n    }\n    // If not, let's create the url used to fetch the parameters.\n    const url = this.#createProductStatusUrl(jobId);\n    // And then try to fetch the status with the url...\n    try {\n      const response = await hfetch(url);\n      const data = await response.json();\n      return { error: false, status: data?.status ?? null };\n    } catch (error) {\n      return { error: true, status: null };\n    }\n  };\n\n  // Returns the url needed to fetch the product parameters from FME-server.\n  #createGetParametersUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmerest/v3/repositories/${\n      product.repository\n    }/items/${product.workspace}/parameters/`;\n  };\n\n  // Returns the url needed to post a request to start a workspace.\n  #createSubmitProductRequestUrl = (product) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/submit/${product.repository}/${\n      product.workspace\n    }/`;\n  };\n\n  // Returns the base url used to post a request to submit a\n  // data-download job.\n  #createDataDownloadUrl = (product) => {\n    return `${this.#mapServiceBase}/fmeproxy/fmedatadownload/${\n      product.repository\n    }/${product.workspace}/`;\n  };\n\n  // Returns the url needed to fetch information about a submitted job.\n  // The required parameter, jobId is a string returned when queuing a job.\n  #createProductStatusUrl = (jobId) => {\n    return `${\n      this.#mapServiceBase\n    }/fmeproxy/fmerest/v3/transformations/jobs/id/${jobId}/`;\n  };\n}\nexport default FmeServerModel;\n"],"names":["FmeServerModel","settings","getActiveUserEmail","getProduct","groupName","productName","length","products","find","product","group","name","makeOrder","productParameters","userEmail","promptForEmail","requestString","noGeomAttributeSupplied","geoJson","getAllFeaturesAsGeoJson","geoAttribute","forEach","parameter","type","value","defaultValue","selectedArray","join","getRangeSliderValueAndStep","decimalPrecision","Number","padStart","step","getRangeSliderMinimum","minimumExclusive","minimum","getRangeSliderMaximum","maximumExclusive","maximum","parametersToSend","push","getParametersToRender","parameters","filter","getInfoUrl","infoUrl","shouldPromptForEmail","isValidEmail","emailString","test","getProductParameters","error","url","hfetch","response","json","data","body","JSON","stringify","publishedParameters","method","credentials","headers","jobId","id","requestUrl","requestUrlString","serviceResponse","jobID","getJobStatusById","status","repository","workspace","this","options","app","config","appConfig","mapserviceBase","userDetails","mail","mapViewModel"],"sourceRoot":""}