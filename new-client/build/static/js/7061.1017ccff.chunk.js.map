{"version":3,"file":"static/js/7061.1017ccff.chunk.js","mappings":"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","sources":["plugins/FmeServer/models/MapViewModel.js"],"sourcesContent":["import { Draw } from \"ol/interaction\";\nimport { Circle as CircleGeometry } from \"ol/geom.js\";\nimport { createBox, createRegularPolygon } from \"ol/interaction/Draw\";\nimport { Vector as VectorLayer } from \"ol/layer\";\nimport VectorSource from \"ol/source/Vector\";\nimport { Stroke, Style, Circle, Fill, Text } from \"ol/style\";\nimport Overlay from \"ol/Overlay.js\";\nimport GeoJSON from \"ol/format/GeoJSON\";\nimport { handleClick } from \"../../../models/Click\";\n\nclass MapViewModel {\n  #map;\n  #localObserver;\n  #options;\n  #drawStyleSettings;\n  #draw;\n  #drawSource;\n  #drawLayer;\n  #drawTooltipElement;\n  #drawTooltipElementStyle;\n  #drawTooltip;\n  #currentPointerCoordinate;\n  #activeProduct;\n\n  constructor(settings) {\n    this.#map = settings.map;\n    this.#localObserver = settings.localObserver;\n    this.#options = settings.options;\n    this.#draw = null;\n    this.#drawTooltipElement = null;\n    this.#drawTooltip = null;\n    this.#currentPointerCoordinate = null;\n    this.#activeProduct = null;\n    this.#drawTooltipElementStyle =\n      \"position: relative; background: rgba(0, 0, 0, 0.5); border-radius: 4px; color: white; padding: 4px 8px; opacity: 0.7; white-space: nowrap;\";\n\n    this.#drawStyleSettings = this.#getDrawStyleSettings();\n    this.#initDrawLayer();\n    this.#bindSubscriptions();\n    this.#createDrawTooltip();\n  }\n\n  // Initializes the layer in which the user will be adding their\n  // drawn geometries.\n  #initDrawLayer = () => {\n    // Let's grab a vector-source.\n    this.#drawSource = this.#getNewVectorSource();\n    // Let's create a layer\n    this.#drawLayer = this.#getNewVectorLayer(\n      this.#drawSource,\n      this.#getDrawStyle(),\n      {\n        layerType: \"system\",\n        zIndex: 5000,\n        name: \"pluginFmeServer\",\n      }\n    );\n    // Then we can add the layer to the map.\n    this.#map.addLayer(this.#drawLayer);\n  };\n\n  // We must make sure that we are listening to the appropriate events from\n  // the local observer.\n  #bindSubscriptions = () => {\n    // Will fire when the active product changes\n    this.#localObserver.subscribe(\"view.activeProductChange\", (product) => {\n      this.#activeProduct = product;\n    });\n    // Will fire when the user changes tool\n    this.#localObserver.subscribe(\n      \"map.toggleDrawMethod\",\n      this.#toggleDrawMethod\n    );\n    // Will fire when the user wants to reset the drawing.\n    this.#localObserver.subscribe(\"map.resetDrawing\", this.#resetDrawing);\n  };\n\n  // Creates the element and overlay used to display the area of the feature\n  // currently being drawn.\n  #createDrawTooltip = () => {\n    // If the element already exists in the dom (which it will if #drawTooltipElement\n    //  isn't nullish), we must make sure to remove it.\n    this.#removeEventualDrawTooltipElement();\n    // Let's crete a element that we can use in the overlay.\n    this.#drawTooltipElement = document.createElement(\"div\");\n    // Let's style the element a bit so it looks prettier...\n    this.#drawTooltipElement.setAttribute(\n      \"style\",\n      this.#drawTooltipElementStyle\n    );\n    // Then let's create the overlay...\n    this.#drawTooltip = new Overlay({\n      element: this.#drawTooltipElement,\n      offset: [30, -5],\n      positioning: \"bottom-center\",\n    });\n    // And add it to the map!\n    this.#map.addOverlay(this.#drawTooltip);\n  };\n\n  // We have to make sure that we remove eventual unused elements\n  // from the dom tree so they're not lurking around.\n  #removeEventualDrawTooltipElement = () => {\n    // Before we do anything else, we make sire that there actually is\n    // an element present.\n    if (this.#drawTooltipElement) {\n      // Then we can remove it\n      this.#drawTooltipElement.parentNode.removeElement(\n        this.#drawTooltipElement\n      );\n      // And clear the variable\n      this.#drawTooltipElement = null;\n    }\n  };\n\n  // We have to make sure that we leave no unused overlays behind\n  #removeEventualDrawTooltipOverlay = () => {\n    // Before anything else, we make sure that there is an overlay\n    // present.\n    if (this.#drawTooltip) {\n      // Then we can remove it\n      this.#map.removeOverlay(this.#drawTooltip);\n      // And clear the variable\n      this.#drawTooltip = null;\n    }\n  };\n\n  // Makes sure that we clean up after ourselves.\n  #cleanupMapOverlays = () => {\n    // Remove unused elements\n    this.#removeEventualDrawTooltipElement();\n    // REmove unused overlays\n    this.#removeEventualDrawTooltipOverlay();\n  };\n\n  // Returns the style settings used in the OL-style.\n  #getDrawStyleSettings = () => {\n    const strokeColor = this.#options.drawStrokeColor || \"rgba(74,74,74,0.5)\";\n    const fillColor = this.#options.drawFillColor || \"rgba(255,255,255,0.07)\";\n    return { strokeColor: strokeColor, fillColor: fillColor };\n  };\n\n  // Returns an OL style to be used in the draw-layer.\n  #getDrawStyle = () => {\n    return new Style({\n      stroke: new Stroke({\n        color: this.#drawStyleSettings.strokeColor,\n        width: 4,\n      }),\n      fill: new Fill({\n        color: this.#drawStyleSettings.fillColor,\n      }),\n      image: new Circle({\n        radius: 6,\n        stroke: new Stroke({\n          color: this.#drawStyleSettings.strokeColor,\n          width: 2,\n        }),\n      }),\n    });\n  };\n\n  // Returns the style that should be used on the drawn features\n  #getFeatureStyle = (feature) => {\n    // Let's start by grabbing the standard draw style as a baseline\n    const baseLineStyle = this.#getDrawStyle();\n    // Then we'll create a new text-style which will allow us to show\n    // the area of the drawn feature.\n    const textStyle = this.#getFeatureTextStyle(feature);\n    // Apply the text-style to the baseline style...\n    baseLineStyle.setText(textStyle);\n    // And return the finished style.\n    return baseLineStyle;\n  };\n\n  // Returns a text-style that shows the tooltip-label\n  // (i.e. the area of the feature in a readable format).\n  #getFeatureTextStyle = (feature) => {\n    return new Text({\n      textAlign: \"center\",\n      textBaseline: \"middle\",\n      font: \"12pt sans-serif\",\n      fill: new Fill({ color: \"#FFF\" }),\n      text: this.#getTooltipText(feature),\n      overflow: true,\n      stroke: new Stroke({\n        color: \"rgba(0, 0, 0, 0.5)\",\n        width: 3,\n      }),\n      offsetX: 0,\n      offsetY: 0,\n      rotation: 0,\n      scale: 1,\n    });\n  };\n\n  // Returns a new vector source.\n  #getNewVectorSource = () => {\n    return new VectorSource({ wrapX: false });\n  };\n\n  // Returns a new vector layer.\n  #getNewVectorLayer = (source, style, props = {}) => {\n    return new VectorLayer({\n      source: source,\n      style: style,\n      ...props,\n    });\n  };\n\n  // Removes the draw interaction if there is one active\n  #removeDrawInteraction = () => {\n    if (this.#draw) {\n      this.#map.removeInteraction(this.#draw);\n    }\n  };\n\n  // We have to make sure to remove all event listeners to avoid clogging.\n  #removeEventListeners = () => {\n    // Some listeners will exist even if the draw interaction is not existing.\n    // (The \"Select\" listeners)\n    this.#map.un(\"singleclick\", this.#handleSelectFeatureClick);\n    this.#drawSource.un(\"addfeature\", this.#handleDrawFeatureAdded);\n    // While some will only exist if draw is/has ever been active...\n    if (this.#draw) {\n      this.#draw.un(\"drawstart\", this.#handleDrawStart);\n      this.#draw.un(\"drawend\", this.#handleDrawEnd);\n      this.#map.un(\"pointermove\", this.#handlePointerMove);\n    }\n  };\n\n  // Toggles the draw method\n  #toggleDrawMethod = (drawMethod, freehand = false) => {\n    // We begin with removing potential existing draw\n    this.#removeDrawInteraction();\n    // And also remove potential event listeners\n    this.#removeEventListeners();\n    // We also want to make sure to remove the potential click-lock\n    this.#map.clickLock.delete(\"fmeServer\");\n    // If the interaction is \"Select\" we don't want a draw method\n    if (drawMethod === \"Select\") {\n      return this.#enableSelectFeaturesSearch();\n    }\n    // If the drawMethod is missing or equals an empty string, the user\n    // is toggling draw off.\n    if (drawMethod && drawMethod !== \"\") {\n      // If the drawMethod contains something, they want to toggle on!\n      this.#draw = new Draw({\n        source: this.#drawSource,\n        // Rectangles should be created with the \"Circle\" method\n        // apparently.\n        type: drawMethod === \"Rectangle\" ? \"Circle\" : drawMethod,\n        // We want freehand drawing for rectangles and circles\n        freehand: [\"Circle\", \"Rectangle\"].includes(drawMethod)\n          ? true\n          : freehand,\n        stopClick: true,\n        geometryFunction:\n          drawMethod === \"Rectangle\"\n            ? createBox()\n            : drawMethod === \"Circle\"\n            ? createRegularPolygon()\n            : null,\n        style: this.#getDrawStyle(),\n      });\n      // Let's add the clickLock to avoid the featureInfo\n      this.#map.clickLock.add(\"fmeServer\");\n      // Then we'll add a listener for when the drawing starts\n      this.#draw.on(\"drawstart\", this.#handleDrawStart);\n      // And a listener for when the drawing is complete\n      this.#draw.on(\"drawend\", this.#handleDrawEnd);\n      // We'll also want a handler for the pointer event to keep\n      // track of where the users pointer is located.\n      this.#map.on(\"pointermove\", this.#handlePointerMove);\n      // Then we'll add the interaction to the map!\n      this.#map.addInteraction(this.#draw);\n      // We need a listener for when a feature is added to the source.\n      this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n    }\n  };\n\n  // We're not only letting the user draw features in the map,\n  // they can also select existing features (from active layers).\n  #enableSelectFeaturesSearch = () => {\n    // We don't want the FeatureInfo to get in the way, so let's add\n    // the clickLock.\n    this.#map.clickLock.add(\"fmeServer\");\n    // Then we'll register the required event listeners\n    this.#map.on(\"singleclick\", this.#handleSelectFeatureClick);\n    this.#drawSource.on(\"addfeature\", this.#handleDrawFeatureAdded);\n  };\n\n  // Handles singleClick(s) in the map when the current draw method is set to \"Select\"\n  #handleSelectFeatureClick = (event) => {\n    handleClick(event, event.map, (response) => {\n      // The response will contain an array\n      const features = response.features;\n      // Which might contain features without geometry. We have to make sure\n      // we remove those.\n      const featuresWithGeom = features.filter((feature) => {\n        return feature.getGeometry();\n      });\n      // The resulting array might be empty, then we abort.\n      if (featuresWithGeom.length === 0) {\n        return;\n      }\n      // If we know that we are going to add a feature to the layer,\n      // we must make sure to remove the existing geometry if multiple\n      // geometries are not allowed.\n      this.#handlePotentialMultipleGeometriesException();\n      // But it might also contain several features that we should add to the map.\n      // However, we're only adding the first one, otherwise it might get messy if the\n      // user has 15 layers active at the same time.\n      this.#drawSource.addFeature(featuresWithGeom[0]);\n    });\n  };\n\n  // Handles the addfeature event\n  #handleDrawFeatureAdded = () => {\n    try {\n      // First we need to get all the drawn features\n      const features = this.#getDrawnFeatures();\n      // Then we'll calculate the total area\n      const totalArea = this.#getTotalArea(features);\n      // And publish the results\n      this.#localObserver.publish(\"map.featureAdded\", {\n        error: totalArea === 0,\n        features: features,\n        totalArea: totalArea,\n      });\n    } catch (error) {\n      // If we've error:ed we have to let the view know\n      this.#localObserver.publish(\"map.featureAdded\", {\n        error: true,\n        features: [],\n        totalArea: 0,\n      });\n    }\n  };\n\n  // Returns the combined area of all features supplied.\n  #getTotalArea = (features) => {\n    return features.reduce((acc, feature) => {\n      return acc + this.#getFeatureArea(feature);\n    }, 0);\n  };\n\n  // This handler has one job; add a change listener to the feature\n  // currently being drawn.\n  #handleDrawStart = (e) => {\n    const feature = e.feature;\n    feature.on(\"change\", this.#handleFeatureChange);\n  };\n\n  // This handler will make sure that the overlay will be removed\n  // when the feature is done. It also makes sure to remove previously\n  // drawn geometries if multiple geometries is not allowed.\n  // It also publishes an event in the case that the previously drawn geometry\n  // was removed.\n  #handleDrawEnd = (e) => {\n    // First we must make sure to handle and remove potential features\n    // that exceed the maximum allowance.\n    this.#handlePotentialMultipleGeometriesException();\n    // Then we make sure to remove the draw tooltip\n    const { feature } = e;\n    this.#drawTooltipElement.innerHTML = null;\n    this.#currentPointerCoordinate = null;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n    // And set a nice style on the feature to be added.\n    feature.setStyle(this.#getFeatureStyle(feature));\n  };\n\n  #handlePotentialMultipleGeometriesException = () => {\n    // First we must check if the currently active product allows for\n    // multiple geometries. We fallback on false if the config option\n    // is missing (since is more usual that only one geometry is allowed).\n    const multipleGeometriesAllowed =\n      this.#activeProduct.allowMultipleGeometries ?? false;\n    // Then we must check if the user has already drawn a geometry\n    const numFeaturesDrawn = this.#drawSource.getFeatures().length;\n    // If they had, and multiple geometries are not allowed, we remove\n    // the previously drawn geometry by clearing the draw source.\n    // Then we publish an event to let the user know that we removed\n    // a geometry from the map.\n    if (!multipleGeometriesAllowed && numFeaturesDrawn !== 0) {\n      this.#drawSource.clear();\n      this.#localObserver.publish(\"map.maxFeaturesExceeded\");\n    }\n  };\n\n  // This handler has one job; get the coordinate from the event,\n  // and store it for later use.\n  #handlePointerMove = (e) => {\n    this.#currentPointerCoordinate = e.coordinate;\n  };\n\n  // This handler will make sure that we keep the area calculation\n  // updated during the feature changes.\n  #handleFeatureChange = (e) => {\n    const feature = e.target;\n    const toolTipText = this.#getTooltipText(feature);\n\n    this.#drawTooltipElement.innerHTML = toolTipText;\n    this.#drawTooltip.setPosition(this.#currentPointerCoordinate);\n  };\n\n  // Calculates the area of the supplied feature.\n  // Accepts an OL-feature, and is tested for Circle and Polygon.\n  #getFeatureArea = (feature) => {\n    const geometry = feature.getGeometry();\n    // Apparently the circle geometry instance does not expose a\n    // getArea method. Here's a quick fix. (Remember that this area\n    // is only used as an heads-up for the user.)\n    if (geometry instanceof CircleGeometry) {\n      const radius = geometry.getRadius();\n      // We're rounding since precision isn't important when choosing the area.\n      return Math.round(Math.pow(radius, 2) * Math.PI);\n    }\n    // If we're not dealing with a circle, we can just return the area.\n    // We're rounding since precision isn't important when choosing the area.\n    return Math.round(geometry.getArea());\n  };\n\n  // Returns the area of the supplied feature in a readable format.\n  #getTooltipText = (feature) => {\n    // First we must get the feature area.\n    const featureArea = this.#getFeatureArea(feature);\n    // Let's check if we're dealing with a huge area.\n    if (featureArea >= 1e6) {\n      // If the area is larger than one square kilometer we show the result in km²\n      // Rounded to show 3 decimals.\n      return `${(featureArea / 1e6).toFixed(3)} km²`;\n    }\n    // Otherwise m² will do. (Displayed in local format).\n    return `${featureArea.toLocaleString()} m²`;\n  };\n\n  // Resets the draw-layer\n  #resetDrawing = () => {\n    this.#map.clickLock.delete(\"fmeServer\");\n    this.#drawSource.clear();\n    this.#removeDrawInteraction();\n    this.#removeEventListeners();\n    this.#cleanupMapOverlays();\n  };\n\n  // Returns all drawn features.\n  #getDrawnFeatures = () => {\n    return this.#drawSource.getFeatures();\n  };\n\n  // Returns all drawn features in GeoJSON format.\n  getAllFeaturesAsGeoJson = () => {\n    // First we need to get all the ol-features\n    const features = this.#getDrawnFeatures();\n    // If there are no features, we return null\n    if (features.length === 0) {\n      return null;\n    }\n    // If there's exactly one feature, we use the writeFeature method,\n    // otherwise we would get a featureCollection with one feature.\n    // (We rather want just the single feature, not a collection).\n    if (features.length === 1) {\n      return new GeoJSON().writeFeature(features[0]);\n    }\n    // If there's more than one feature, we use the writeFeatures method,\n    // which returns a featureCollection.\n    return new GeoJSON().writeFeatures(features);\n  };\n}\nexport default MapViewModel;\n"],"names":["MapViewModel","settings","layerType","zIndex","name","addLayer","subscribe","product","document","createElement","setAttribute","Overlay","element","offset","positioning","addOverlay","parentNode","removeElement","removeOverlay","strokeColor","drawStrokeColor","fillColor","drawFillColor","Style","stroke","Stroke","color","width","fill","Fill","image","Circle","radius","feature","baseLineStyle","textStyle","setText","Text","textAlign","textBaseline","font","text","overflow","offsetX","offsetY","rotation","scale","VectorSource","wrapX","source","style","props","VectorLayer","removeInteraction","un","drawMethod","freehand","clickLock","delete","Draw","type","includes","stopClick","geometryFunction","createBox","createRegularPolygon","add","on","addInteraction","event","handleClick","map","response","featuresWithGeom","features","filter","getGeometry","length","addFeature","totalArea","publish","error","reduce","acc","e","innerHTML","setPosition","setStyle","multipleGeometriesAllowed","allowMultipleGeometries","numFeaturesDrawn","getFeatures","clear","coordinate","target","toolTipText","geometry","CircleGeometry","getRadius","Math","round","pow","PI","getArea","featureArea","toFixed","toLocaleString","getAllFeaturesAsGeoJson","GeoJSON","writeFeature","writeFeatures","this","localObserver","options"],"sourceRoot":""}