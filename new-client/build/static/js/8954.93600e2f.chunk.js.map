{"version":3,"file":"static/js/8954.93600e2f.chunk.js","mappings":"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","sources":["models/KmlModel.js"],"sourcesContent":["import { Vector as VectorLayer } from \"ol/layer\";\nimport VectorSource from \"ol/source/Vector\";\nimport KML from \"ol/format/KML\";\nimport { Circle } from \"ol/geom\";\nimport { fromCircle } from \"ol/geom/Polygon\";\nimport { saveAs } from \"file-saver\";\nimport { Circle as CircleStyle, Fill, Stroke, Style, Text } from \"ol/style\";\n\n/*\n * A model supplying useful KML-functionality.\n * Required settings:\n * - layerName: (string): The name of the layer that should be connected to the KML-model.\n *   If it already exists a layer in the map with the same name, the model will be connected\n *   to that layer. Otherwise, a new vector-layer will be created and added to the map.\n * - map: (olMap): The current map-object.\n * Optional settings:\n * - enableDragAndDrop: (boolean): If true, drag-and-drop of .kml-files will be active.\n * - drawModel (DrawModel): If supplied, imported features will be drawn using the draw-model.\n *\n * Exposes a couple of methods:\n * - parseFeatures(kmlString, settings): Accepts a KML-string and tries to parse it to OL-features.\n * - import(kmlString, settings): Accepts a KML-string and adds the KML-features to the layer.\n * - export(): Exports all features in the current kml-layer.\n * - removeImportedFeatures(): Removes all imported features from the kml-source.\n * - zoomToCurrentExtent(): Zooms the map to the current extent of the kml-source.\n * - setLayer(layerName): Accepts a string containing a layer name. Will set current layer.\n * - getCurrentLayerName(): Returns the name of the vectorLayer that is currently connected to the model.\n * - getCurrentExtent(): Returns the current extent of the kml-source.\n */\nclass KmlModel {\n  #map;\n  #layerName;\n  #drawModel;\n  #observer;\n  #kmlSource;\n  #kmlLayer;\n  #parser;\n  #currentExtent;\n\n  constructor(settings) {\n    // Let's make sure that we don't allow initiation if required settings\n    // are missing.\n    if (!settings.map || !settings.layerName) {\n      return this.#handleInitiationParametersMissing();\n    }\n    // Make sure that we keep track of the supplied settings.\n    this.#map = settings.map;\n    this.#layerName = settings.layerName;\n    this.#drawModel = settings.drawModel || null;\n    this.#observer = settings.observer || null;\n    // If a setting to enable drag-and-drop has been passes, we have to initiate\n    // the listeners for that.\n    settings.enableDragAndDrop && this.#addMapDropListeners();\n    // We are gonna need a kml parser obviously.\n    this.#parser = new KML();\n    // We are going to be keeping track of the current extent of the kml-source.\n    this.#currentExtent = null;\n    // A KML-model is not really useful without a vector-layer, let's initiate it\n    // right away, either by creating a new layer, or connect to an existing layer.\n    this.#initiateKmlLayer();\n  }\n\n  // If required parameters are missing, we have to make sure we abort the\n  // initiation of the KML-model.\n  #handleInitiationParametersMissing = () => {\n    throw new Error(\n      \"Failed to initiate KML-model, - required parameters missing. \\n Required parameters: map, layerName\"\n    );\n  };\n\n  // We have to initiate a vector layer that can be used to display the imported features.\n  #initiateKmlLayer = () => {\n    if (this.#vectorLayerExists()) {\n      return this.#connectExistingVectorLayer();\n    }\n    return this.#createNewKmlLayer();\n  };\n\n  // Adds listeners so that .kml-files can be drag-and-dropped into the map,\n  // triggering an import.\n  #addMapDropListeners = () => {\n    const mapDiv = document.getElementById(\"map\");\n    [\"drop\", \"dragover\", \"dragend\", \"dragleave\", \"dragenter\"].forEach(\n      (eventName) => {\n        mapDiv.addEventListener(\n          eventName,\n          this.#preventDefaultDropBehavior,\n          false\n        );\n      }\n    );\n    // We're gonna need to add some more listeners (for dragEnter etc.).\n    mapDiv.addEventListener(\"drop\", this.#handleDrop, false);\n  };\n\n  // Prevents the default behaviors connected to drag-and-drop.\n  #preventDefaultDropBehavior = (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  // Handles the event when a file has been dropped. Tries to import the file as a .kml.\n  #handleDrop = async (e) => {\n    try {\n      for await (const file of e.dataTransfer.files) {\n        const fileType = file.type ? file.type : file.name.split(\".\").pop();\n        // Not sure about filetype for kml... Qgis- and Hajk-generated kml:s does not contain any information about type.\n        // The application/vnd is... a guess.\n        if (\n          fileType === \"kml\" ||\n          fileType === \"application/vnd.google-earth.kml+xml\"\n        ) {\n          this.#importDroppedKml(file);\n        }\n      }\n    } catch (error) {\n      console.error(`Error importing KML-file... ${error}`);\n    }\n  };\n\n  #importDroppedKml = (file) => {\n    const reader = new FileReader();\n    // We're gonna want to set a random id on all features belonging\n    // to the current file. That way we can keep track of which features\n    // belongs to each file.\n    const id = Math.random().toString(36).slice(2, 9);\n    // Let's handle the onload-event and import the features!\n    reader.onload = () => {\n      this.import(reader.result, {\n        zoomToExtent: true,\n        setProperties: { KML_ID: id },\n      });\n      // We also want to publish an event on the observer so that we can update potential views.\n      this.#observer && this.#observer.publish(\"kmlModel.fileImported\", { id });\n    };\n    reader.readAsText(file);\n  };\n\n  // Checks wether the layerName supplied when initiating the KML-model\n  // corresponds to an already existing vector-layer.\n  #vectorLayerExists = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Check wether any of the layers has the same name (type)\n    // as the supplied layerName. Also makes sure that the found\n    // layer is a vectorLayer. (We cannot add features to an imageLayer...).\n    return allMapLayers.some((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n  };\n\n  // Returns all layers connected to the map-object supplied\n  // when initiating the model.\n  #getAllMapLayers = () => {\n    return this.#map.getLayers().getArray();\n  };\n\n  // Checks wether the name (type) of the supplied layer matches\n  // the layerName supplied when initiating the model. Also makes\n  // sure that the layer is a vectorLayer.\n  #layerHasCorrectNameAndType = (layer) => {\n    return layer.get(\"name\") === this.#layerName && this.#isVectorLayer(layer);\n  };\n\n  // Checks wether the supplied layer is a vectorLayer or not.\n  #isVectorLayer = (layer) => {\n    return layer instanceof VectorLayer;\n  };\n\n  // Connects the private fields of the KML-model to an already existing\n  // vectorLayer.\n  #connectExistingVectorLayer = () => {\n    // Get all the layers from the map\n    const allMapLayers = this.#getAllMapLayers();\n    // Then we'll grab the layer corresponding to the supplied layerName.\n    const connectedLayer = allMapLayers.find((layer) => {\n      return this.#layerHasCorrectNameAndType(layer);\n    });\n    // Then we'll set the private fields\n    this.#kmlLayer = connectedLayer;\n    this.#kmlSource = connectedLayer.getSource();\n  };\n\n  // Creates a new vector layer that can be used to display KML-features.\n  #createNewKmlLayer = () => {\n    // Let's grab a vector-source.\n    this.#kmlSource = this.#getNewVectorSource();\n    // Let's create a layer\n    this.#kmlLayer = this.#getNewVectorLayer(this.#kmlSource);\n    // Make sure to set a unique name\n    this.#kmlLayer.set(\"name\", this.#layerName);\n    // Then we can add the layer to the map.\n    this.#map.addLayer(this.#kmlLayer);\n  };\n\n  // Returns a new vector source.\n  #getNewVectorSource = () => {\n    return new VectorSource({ wrapX: false });\n  };\n\n  // Returns a new vector layer connected to the supplied source.\n  #getNewVectorLayer = (source) => {\n    return new VectorLayer({\n      source: source,\n      layerType: \"system\",\n      zIndex: 5000,\n      caption: \"KML model\",\n    });\n  };\n\n  // Translates the supplied feature to the map-views coordinate system.\n  #translateFeatureToViewSrs = (feature) => {\n    // Let's get the geometry-type to begin with\n    const baseGeometryType = feature?.getGeometry?.().getType?.() ?? null;\n    // If no geometry-type could be fetched from the supplied feature, we make sure\n    // to terminate to avoid errors.\n    if (baseGeometryType === null) return null;\n    // We are going to be using the view of the map when translating, let's get it\n    const mapViewProjection = this.#map.getView().getProjection();\n    // Finally we translate the feature to the view-projection.\n    feature.getGeometry().transform(\"EPSG:4326\", mapViewProjection);\n  };\n\n  // Extracts style from the feature props or style func and applies it.\n  #setFeatureStyle = (feature) => {\n    if (!feature) {\n      console.warn(\n        \"Cannot apply a style on nothing. (Supplied feature is nullish).\"\n      );\n    }\n    // First, we try to get the style from the feature props\n    const styleProperty =\n      feature.get(\"EXTRACTED_STYLE\") || feature.get(\"style\") || null;\n    // If it exists, we apply the style using this prop.\n    if (styleProperty !== null) {\n      return this.#setFeatureStyleFromProps(feature, styleProperty);\n    }\n    // Otherwise the feature might contain a style-function. If it does, we can use that\n    // to style the feature.\n    const styleFunc = feature.getStyleFunction() ?? null;\n    if (styleFunc !== null) {\n      return this.#setStyleFromStyleFunction(feature, styleFunc);\n    }\n  };\n\n  // Extracts the feature style from its properties and applies it.\n  #setFeatureStyleFromProps = (feature, styleProperty) => {\n    try {\n      // Parse the string to a real object\n      const parsedStyle = JSON.parse(styleProperty);\n      // Get the geometry-type so that we can check if we're\n      // dealing with a text drawn with the draw-plugin. (The old draw-plugin used 'geometryType'\n      // and the new \"Sketch\"-plugin uses 'DRAW_METHOD').\n      const geometryType =\n        feature.get(\"DRAW_METHOD\") || feature.get(\"geometryType\") || null;\n      // If the type is set to text, we are dealing with a draw-plugin\n      // text, and we have to handle it separately. (We don't want to\n      // extract information from the point-object which is it built upon).\n      if (geometryType === \"Text\") {\n        this.#setFeatureTextProperties(feature, parsedStyle.text);\n      }\n      // Then we create a style and apply it on the feature to make\n      // sure the import looks like the features drawn in the draw-plugin.\n      feature.setStyle(this.#createFeatureStyle(parsedStyle));\n    } catch (error) {\n      console.error(\n        `KML-model: Style attribute could not be parsed. Error: ${error}`\n      );\n    }\n  };\n\n  // Extracts the style from the style function and applies it.\n  #setStyleFromStyleFunction = (feature, styleFunction) => {\n    // Let's create the style using the style function. The views resolution\n    // must be passed since the style might behave differently when resolution change.\n    const style = styleFunction(feature, this.#map.getView().getResolution());\n    // Checks if the fill is nullish, if it is, we must make sure to set _something_\n    // to avoid issues when adding the feature to the map.\n    if (this.#styleFillIsNullish(style)) {\n      style[0].setFill(\n        new Fill({\n          color: [0, 0, 0, 0],\n        })\n      );\n    }\n    // Finally, we apply the style on the feature.\n    feature.setStyle(style);\n  };\n\n  // Checks wether the supplied style exist and has a nullish fill.\n  #styleFillIsNullish = (style) => {\n    return style[0] && style[0].getFill && style[0].getFill() === null;\n  };\n\n  // Sets the user-text-properties on the supplied feature. This is required\n  // since we want to support text-features from Hajk2, and features drawn there does\n  // not have the same settings as the current draw-model.\n  #setFeatureTextProperties = (feature, text) => {\n    if (!feature.get(\"USER_TEXT\")) {\n      feature.set(\"USER_TEXT\", text);\n      feature.set(\"TEXT_SETTINGS\", {\n        backgroundColor: \"#000000\",\n        foregroundColor: \"#FFFFFF\",\n        size: 14,\n      });\n    }\n  };\n\n  // Creates a style-object from the special settings that are\n  // added when drawing features in the draw-plugin. E.g. stroke-dash\n  // and so on.\n  #createFeatureStyle = (parsedStyle) => {\n    return new Style({\n      fill: this.#getFillStyle(parsedStyle),\n      image: this.#getImageStyle(parsedStyle),\n      stroke: this.#getStrokeStyle(parsedStyle),\n      text: this.#getTextStyle(parsedStyle),\n    });\n  };\n\n  // Returns a fill-style based on the supplied settings.\n  // If the feature was created with the new draw-model, the settings\n  // will contain a fillStyle-object, and if it was created with Hajk2 it\n  // will only contain a fillColor-property.\n  #getFillStyle = (styleSettings) => {\n    const { fillStyle, fillColor } = styleSettings;\n    if (fillStyle) {\n      return new Fill({ color: fillStyle.color });\n    }\n    return new Fill({ color: fillColor });\n  };\n\n  // Returns an image-style based on the supplied settings.\n  // If the feature was created with the new draw-model, the settings\n  // will contain a imageStyle-object, and if it was created with Hajk2 it\n  // will only contain the pointColor property.\n  #getImageStyle = (styleSettings) => {\n    const { imageStyle, pointColor } = styleSettings;\n    // If the settings has the imageStyle-property, we create the style from that one.\n    if (imageStyle) {\n      return new CircleStyle({\n        radius: 6,\n        stroke: new Stroke({\n          color: imageStyle.strokeColor,\n          width: imageStyle.strokeWidth,\n          lineDash: imageStyle.dash,\n        }),\n        fill: new Fill({\n          color: imageStyle.fillColor,\n        }),\n      });\n    }\n    // Otherwise we use the pointColor property and some defaults.\n    return new CircleStyle({\n      radius: 6,\n      stroke: new Stroke({\n        color: \"#FFFFFF\",\n        width: 2,\n        lineDash: null,\n      }),\n      fill: new Fill({\n        color: pointColor,\n      }),\n    });\n  };\n\n  // Returns a stroke-style based on the supplied settings.\n  // If the feature was created with the new draw-model, the settings\n  // will contain a strokeStyle-object, and if it was created with Hajk2 it\n  // will only contain the strokeDash, strokeWidth, strokeColor directly.\n  #getStrokeStyle = (styleSettings) => {\n    const { strokeStyle } = styleSettings;\n    // If the settings contain a strokeStyle, we use that one.\n    if (strokeStyle) {\n      return new Stroke({\n        lineDash: strokeStyle.dash,\n        color: strokeStyle.color,\n        width: strokeStyle.width,\n      });\n    }\n    // Otherwise we use the 'old' settings (from Hajk2).\n    const { strokeDash, strokeWidth, strokeColor } = styleSettings;\n    return new Stroke({\n      lineDash: strokeDash,\n      color: strokeColor,\n      width: strokeWidth,\n    });\n  };\n\n  // Returns a text-style based on the supplied values\n  #getTextStyle = (styleSettings) => {\n    const { text } = styleSettings;\n    return new Text({\n      font: \"12pt sans-serif\",\n      fill: new Fill({ color: \"#FFFFF\" }),\n      text: text,\n      overflow: true,\n      stroke: new Stroke({\n        color: \"rgba(0, 0, 0, 0.5)\",\n        width: 3,\n      }),\n      offsetX: 0,\n      offsetY: -15,\n    });\n  };\n\n  // Extracts the coordinates for the\n  #getFeaturePointPosition = (featureGeometry) => {\n    // First we have to get the geometry type, since we only\n    // want to extract the coordinates when we're dealing with a point.\n    const geometryType = featureGeometry.getType();\n    // If we're not dealing with a point, return.\n    if (geometryType !== \"Point\") return null;\n    // Otherwise we get the coordinates\n    const coordinates = featureGeometry.getCoordinates();\n    // And return them formatted...\n    return {\n      n: coordinates[1],\n      e: coordinates[0],\n    };\n  };\n\n  // Prepares the supplied features for injection in the map.\n  // Includes translating and styling of the features.\n  #prepareForMapInjection = (features) => {\n    // If no features are supplied, we abort!\n    if (!features || features?.length === 0) {\n      return null;\n    }\n    // Otherwise we check if the features are to be added via the drawModel. If they are, we set\n    // the USER_DRAWN-prop to true since all features in the draw-source _can_ be altered by the user.\n    // We also have to translate every feature to the map-views coordinate system.\n    features.forEach((feature) => {\n      this.#translateFeatureToViewSrs(feature);\n      this.#setFeatureStyle(feature);\n      this.#drawModel && feature.set(\"USER_DRAWN\", true);\n    });\n  };\n\n  #tagFeaturesAsImported = (features) => {\n    // If no features are supplied, we abort!\n    if (!features || features?.length === 0) {\n      return null;\n    }\n    // Otherwise we set the \"KML_IMPORT\" property to true. We also want\n    // to set the \"SHOW_TEXT\" to true on all features.\n    // Why? Well, kml's created from dgw:s usually contains a lot of text, and\n    // we do not want to provide the user with a possibility to turn text off.\n    features.forEach((feature) => {\n      feature.set(\"KML_IMPORT\", true);\n      feature.set(\"SHOW_TEXT\", true);\n    });\n  };\n\n  // Returns all features from the kml-source that are tagged\n  // as imported.\n  #getAllImportedFeatures = () => {\n    return this.#kmlSource.getFeatures().filter((feature) => {\n      return feature.get(\"KML_IMPORT\") === true;\n    });\n  };\n\n  // Checks wether there are any features in the kml-source or not.\n  #kmlSourceHasFeatures = () => {\n    return this.#kmlSource.getFeatures().length > 0;\n  };\n\n  // Fits the map to the current extent of the kml-source (with some padding).\n  #fitMapToExtent = () => {\n    this.#map.getView().fit(this.#currentExtent, {\n      size: this.#map.getSize(),\n      padding: [20, 20, 20, 20],\n      maxZoom: 7,\n    });\n  };\n\n  // Sets the supplied properties on the supplied features\n  #setFeatureProperties = (features, properties) => {\n    for (const feature of features) {\n      feature.setProperties(properties);\n    }\n  };\n\n  // Accepts an id and checks if the current source still contains features\n  // with the supplied kml-id.\n  importedKmlStillHasFeatures = (id) => {\n    return (\n      this.#kmlSource.getFeatures().filter((f) => f.get(\"KML_ID\") === id)\n        .length > 0\n    );\n  };\n\n  // Tries to parse features from the supplied kml-string.\n  // Accepts a kmlString and an optional second parameter stating if\n  // the features should be translated to the map-views srs or not.\n  // Returns an object on the following form:\n  // {features: <Array of ol-features>, error: <String with potential error message>}\n  // **The returned features are translated to the map-views coordinate system.**\n  parseFeatures = (kmlString, settings = { prepareForMapInjection: true }) => {\n    // The method accepts a setting-object, lets extract the settings we need.\n    // The settings includes a possibility to set prepareForMapInjection to false,\n    // (default to true), allowing for the return-object to contain the pure parsed\n    // features (not styled or translated).\n    const prepareForMapInjection = settings.prepareForMapInjection;\n    // Then we start parsing\n    try {\n      // First we must parse the string to ol-features\n      const features = this.#parser.readFeatures(kmlString) ?? [];\n      // Let's make sure to tag all imported features so that we can\n      // distinguish them from \"ordinary\" features.\n      this.#tagFeaturesAsImported(features);\n      // Then we must make sure to prepare all the features for\n      // map-injection. This includes translating the features to\n      // the current map-views coordinate system, and setting some style.\n      prepareForMapInjection && this.#prepareForMapInjection(features);\n      // Then we can return the features\n      return { features: features, error: null };\n    } catch (error) {\n      // If we happen to hit a mine, we make sure to return the error\n      // message and an empty array.\n      return { features: [], error: error };\n    }\n  };\n\n  // Tries to parse features from a KML-string and then add them to\n  // the kml-source.\n  // Accepts an kmlString and an optional parameter stating if the map should\n  // zoom the the imported features extent or not.\n  import = (kmlString, settings = { zoomToExtent: true }) => {\n    // Start by trying to parse the kml-string\n    const { features, error } = this.parseFeatures(kmlString);\n    // If the parsing led to any kind of error, we make sure to abort\n    // and return the error to the initiator.\n    if (error !== null) {\n      return { status: \"FAILED\", error: error };\n    }\n    // If \"setProperties\" was supplied in the settings, we have to make sure\n    // to set the supplied properties on all features.\n    settings.setProperties &&\n      this.#setFeatureProperties(features, settings.setProperties);\n    // If a draw-model has been supplied, we use that model to add the\n    // features to the map.\n    if (this.#drawModel) {\n      this.#drawModel.addKmlFeatures(features);\n    } else {\n      // Otherwise we add the parsed features directly to the kml-source.\n      this.#kmlSource.addFeatures(features);\n    }\n    // We have to make sure to update the current extent when we've added\n    // features to the kml-source.\n    this.#currentExtent = this.#kmlSource.getExtent();\n    // Then we make sure to zoom to the current extent (unless the initiator\n    // has told us not to!).\n    settings.zoomToExtent && this.zoomToCurrentExtent();\n    // Finally we return a success message to the initiator.\n    return { status: \"SUCCESS\", error: null };\n  };\n\n  // Tries to export all the features in the current kml-layer\n  export = () => {\n    // First we need to get all the features from the current kml-source\n    // (except for hidden features, the users might be confused if hidden features are exported).\n    const features = this.#kmlSource\n      .getFeatures()\n      .filter((f) => f.get(\"HIDDEN\") !== true);\n    // Then we have to make sure that there were some feature there to export.\n    if (!features || features?.length === 0) {\n      return {\n        status: \"FAILED\",\n        error: \"No features exist in the current kml-layer.\",\n      };\n    }\n    // Then we'll do some transformations on the features to make sure\n    // that they are kml-compatible.\n    const compatibleFeatures = this.#getKmlCompatibleFeatures(features);\n    // Let's make sure that we have some compatible features to return,\n    // if we don't, we make sure to abort.\n    if (compatibleFeatures.length === 0) {\n      return {\n        status: \"FAILED\",\n        error: \"Could not transform any features to the .kml standard.\",\n      };\n    }\n    // If we do have compatible features, we can create the kml-xml\n    const postData = this.#parser.writeFeatures(\n      compatibleFeatures,\n      `${this.#layerName}-kml-export`\n    );\n    // Then we'll call the save-as method from file-saver, which will\n    // initiate the download-process for the user.\n    try {\n      saveAs(\n        new Blob([postData], {\n          type: \"application/vnd.google-earth.kml+xml;charset=utf-8\",\n        }),\n        `Ritexport - ${new Date().toLocaleString()}.kml`\n      );\n      return {\n        status: \"SUCCESS\",\n        error: null,\n      };\n    } catch (error) {\n      return {\n        status: \"FAILED\",\n        error: \"Could not save the KML-file. File-saver Error.\",\n      };\n    }\n  };\n\n  // Clones the supplied features and returns new features which are transformed\n  // so that they are compatible with the .kml-format.\n  #getKmlCompatibleFeatures = (features) => {\n    // Declare an array where we can push the transformed features.\n    const transformedFeatures = [];\n    // Looping trough all the features, creating a clone of each, this clone\n    // will be transformed and then pushed to the transformedFeatures-array.\n    features.forEach((feature) => {\n      // Create the feature-clone\n      const clonedFeature = feature.clone();\n      // Let's check if we're dealing with a circle\n      const geomIsCircle = clonedFeature.getGeometry() instanceof Circle;\n      // If a drawModel has been supplied, we have to make sure to get and set\n      // the specific style-information used during drawing. We also have to make sure\n      // to stringify the information, since the kml-format does not handle objects.\n      // We also have to extract and stringify eventual text-settings used. (Used for\n      // the text-features in the sketch-plugin to determine text-size etc.).\n      if (this.#drawModel) {\n        clonedFeature.set(\n          \"EXTRACTED_STYLE\",\n          JSON.stringify(this.#drawModel.extractFeatureStyleInfo(feature))\n        );\n        clonedFeature.set(\n          \"TEXT_SETTINGS\",\n          JSON.stringify(feature.get(\"TEXT_SETTINGS\"))\n        );\n      }\n      // If we're dealing with a circle, we have to make sure to simplify\n      // the geometry since the kml standard does not like circles.\n      if (geomIsCircle) {\n        const circleGeometry = clonedFeature.getGeometry();\n        // Let's store the circle-radius and center if the user wants to load the\n        // kml using the sketch-tool later. (The radius and center is required by the draw-model\n        // so that it is able to create a real circle).\n        clonedFeature.set(\"CIRCLE_RADIUS\", circleGeometry.getRadius());\n        clonedFeature.set(\n          \"CIRCLE_CENTER\",\n          JSON.stringify(circleGeometry.getCenter())\n        );\n        // Create the simplified geometry\n        const simplifiedGeometry = fromCircle(circleGeometry, 96);\n        // And then set the cloned feature's geometry to the simplified one.\n        clonedFeature.setGeometry(simplifiedGeometry);\n      }\n      // Transform the geometry to WGS:84 so the kml-interpreters will be happy.\n      clonedFeature\n        .getGeometry()\n        .transform(this.#map.getView().getProjection(), \"EPSG:4326\");\n      // Finally, we can push the transformed feature to the\n      // transformedFeatures-array.\n      transformedFeatures.push(clonedFeature);\n    });\n    return transformedFeatures;\n  };\n\n  // Fits the map to the extent of the features currently in the kml-layer\n  zoomToCurrentExtent = () => {\n    // First we make sure to check wether the kml-source has any features\n    // or not. If none exist, what would we zoom to?!\n    if (!this.#kmlSourceHasFeatures()) {\n      return;\n    }\n    // Let's also make sure that the current extent is not null.\n    if (this.#currentExtent === null) {\n      return;\n    }\n    // If there are features, and the extent is not null, we'll check\n    // that the current extent is finite\n    if (this.#currentExtent.map(Number.isFinite).includes(false) === false) {\n      // If it is, we can fit the map to that extent!\n      this.#fitMapToExtent(this.#currentExtent);\n    }\n  };\n\n  // We will need a way to remove all imported features from the kml-source.\n  // Why aren't we using a simple \"clear()\" one might ask =>  simply because\n  // the kml-source might be the draw-source, and we don't want to remove\n  // all drawn features, only the imported ones.\n  removeImportedFeatures = () => {\n    // Let's get all the features in the kml-source that have been imported\n    const importedFeatures = this.#getAllImportedFeatures();\n    // Since OL does not supply a \"removeFeatures\" method, we have to map\n    // over the array, and remove every single feature one by one...\n    importedFeatures.forEach((feature) => {\n      this.#kmlSource.removeFeature(feature);\n    });\n    // When the imported features has been removed, we have to make sure\n    // to update the current extent.\n    this.#currentExtent = this.#kmlSource.getExtent();\n  };\n\n  // Set:er allowing us to change which layer the kml-model will interact with\n  setLayer = (layerName) => {\n    // First we must update the private field holding the current layer name\n    this.#layerName = layerName;\n    // Then we must initiate the kml-layer. This will either get the layer\n    // corresponding to the supplied name, or create a new one.\n    this.#initiateKmlLayer();\n    // When the current layer changes, the current extent will obviously\n    // change as well.\n    this.#currentExtent = this.#kmlSource.getExtent();\n  };\n\n  // Get:er returning the name of the KML-layer.\n  getCurrentLayerName = () => {\n    return this.#layerName;\n  };\n\n  // Get:er returning the current extent of the kml-source.\n  getCurrentExtent = () => {\n    return this.#currentExtent;\n  };\n}\nexport default KmlModel;\n"],"names":["KmlModel","settings","Error","mapDiv","document","getElementById","forEach","eventName","addEventListener","e","stopPropagation","preventDefault","dataTransfer","files","file","fileType","type","name","split","pop","console","error","reader","FileReader","id","Math","random","toString","slice","onload","import","result","zoomToExtent","setProperties","KML_ID","publish","readAsText","some","layer","getLayers","getArray","get","VectorLayer","connectedLayer","find","getSource","set","addLayer","VectorSource","wrapX","source","layerType","zIndex","caption","feature","getGeometry","getType","mapViewProjection","getView","getProjection","transform","warn","styleProperty","styleFunc","getStyleFunction","parsedStyle","JSON","parse","text","setStyle","styleFunction","style","getResolution","setFill","Fill","color","getFill","backgroundColor","foregroundColor","size","Style","fill","image","stroke","styleSettings","fillStyle","fillColor","imageStyle","pointColor","CircleStyle","radius","Stroke","strokeColor","width","strokeWidth","lineDash","dash","strokeStyle","strokeDash","Text","font","overflow","offsetX","offsetY","featureGeometry","coordinates","getCoordinates","n","features","length","getFeatures","filter","fit","getSize","padding","maxZoom","properties","importedKmlStillHasFeatures","f","parseFeatures","kmlString","prepareForMapInjection","readFeatures","status","addKmlFeatures","addFeatures","getExtent","zoomToCurrentExtent","export","compatibleFeatures","postData","writeFeatures","saveAs","Blob","Date","toLocaleString","transformedFeatures","clonedFeature","clone","geomIsCircle","Circle","stringify","extractFeatureStyleInfo","circleGeometry","getRadius","getCenter","simplifiedGeometry","fromCircle","setGeometry","push","map","Number","isFinite","includes","removeImportedFeatures","removeFeature","setLayer","layerName","getCurrentLayerName","getCurrentExtent","this","drawModel","observer","enableDragAndDrop","KML"],"sourceRoot":""}