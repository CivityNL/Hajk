{"version":3,"file":"static/js/8702.81249f1c.chunk.js","mappings":"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","sources":["plugins/Buffer/BufferModel.js"],"sourcesContent":["import { Circle, Stroke, Fill, Style } from \"ol/style.js\";\nimport { Vector as VectorSource } from \"ol/source.js\";\nimport { Vector as VectorLayer } from \"ol/layer.js\";\n\nimport GeoJSON from \"ol/format/GeoJSON.js\";\n\nimport HajkTransformer from \"utils/HajkTransformer\";\nimport { hfetch } from \"utils/FetchWrapper\";\n\nclass BufferModel {\n  #HT;\n\n  constructor(settings) {\n    this.map = settings.map;\n    this.#HT = new HajkTransformer({\n      projection: settings.map.getView().getProjection().getCode(),\n    });\n\n    // Will contain new features for clicked objects/features\n    this.highlightSource = new VectorSource();\n    this.highlightLayer = new VectorLayer({\n      source: this.highlightSource,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginBufferSelection\",\n      caption: \"Buffer selection layer\",\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 168, 231, 0.47)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(255, 168, 231, 1)\",\n          width: 4,\n        }),\n        image: new Circle({\n          radius: 6,\n          fill: new Fill({\n            color: \"rgba(255, 168, 231, 0.47)\",\n          }),\n          stroke: new Stroke({\n            color: \"rgba(255, 168, 231, 1)\",\n            width: 1,\n          }),\n        }),\n      }),\n    });\n\n    // Will contain the actual buffer zone features\n    this.bufferSource = new VectorSource();\n    this.bufferLayer = new VectorLayer({\n      source: this.bufferSource,\n      layerType: \"system\",\n      zIndex: 5000,\n      name: \"pluginBuffer\",\n      caption: \"Buffer layer\",\n      style: new Style({\n        fill: new Fill({\n          color: \"rgba(255, 255, 255, 0.5)\",\n        }),\n        stroke: new Stroke({\n          color: \"rgba(75, 100, 115, 1.5)\",\n          width: 4,\n        }),\n        image: new Circle({\n          radius: 6,\n          fill: new Fill({\n            color: \"rgba(255, 255, 255, 0.5)\",\n          }),\n          stroke: new Stroke({\n            color: \"rgba(75, 100, 115, 1.5)\",\n            width: 2,\n          }),\n        }),\n      }),\n    });\n\n    // Add layers to map\n    this.map.addLayer(this.highlightLayer);\n    this.map.addLayer(this.bufferLayer);\n  }\n\n  // Called onWindowShow and onWindowHide\n  setActive(active) {\n    if (active === false) {\n      this.activateSelecting(false);\n    }\n  }\n\n  activateSelecting = (v) => {\n    if (v === true) {\n      this.map.on(\"click\", this.handleClick);\n      this.map.clickLock.add(\"buffer\");\n    } else {\n      this.map.un(\"click\", this.handleClick);\n      this.map.clickLock.delete(\"buffer\");\n    }\n  };\n\n  handleClick = (e) => {\n    // Handle all vector features\n    this.map\n      // Get all features from all vector sources at given pixel…\n      .getFeaturesAtPixel(e.pixel, {\n        layerFilter: function (l) {\n          const name = l.get(\"name\");\n          return name !== \"pluginBuffer\" && name !== \"pluginBufferSelection\"; // …but ignore them if they happen to come from buffer layer.\n        },\n      })\n      // Take each of the returned features from any vector layer…\n      .forEach((f) => {\n        const clonedFeature = f.clone(); // …clone it…\n        clonedFeature.setStyle(); // …and reset it's style (so it uses layer's default)…\n        this.highlightSource.addFeature(clonedFeature); //…and add it to the highlight source (so we collect them there).\n      });\n\n    // We're done with vector sources' features (e.g from WFS layers or the Draw plugin).\n    // Still we must handle visible WMS layers, see if we get any features at given coordinate\n    // and if so, add them to the highlight source too.\n    this.map\n      .getLayers() // Grab layers…\n      .getArray() // …as array…\n      .filter((l) => l.getVisible()) // …only currently visible…\n      .filter((l) => l.layersInfo) // …and only those that contain a \"layersInfo\" property - that means it's a Hajk layer - see ConfigMapper.js.\n      // Each of the remaining layers must now be queried separately. Let's do it:\n      .map(async (layer) => {\n        // Async, as we will await some fetch.\n        try {\n          const subLayers = Object.values(layer.layersInfo); // Transform the object to an array of objects\n          const subLayersToQuery = subLayers\n            .filter((subLayer) => subLayer.queryable === true) // Use only those layers that are specifically queryable\n            .map((queryableSubLayer) => queryableSubLayer.id); // Grab the id property (which is the name that we'll use in our URL)\n\n          if (e.coordinate !== undefined) {\n            const view = this.map.getView();\n\n            const url = layer // Prepare a URL that we'll call to see if there are features at a given coordinate\n              .getSource()\n              // Get the URL to FeatureInfo for given layer\n              .getFeatureInfoUrl(\n                e.coordinate, // Use current click event coordinate - that's what we're interested in!\n                view.getResolution(),\n                view.getProjection().getCode(),\n                {\n                  INFO_FORMAT: \"application/json\",\n                  QUERY_LAYERS: subLayersToQuery.join(\",\"), // Use the layer names we got earlier in the query\n                }\n              );\n\n            const response = await hfetch(url);\n            const json = await response.json();\n            const features = new GeoJSON().readFeatures(json); // Parse OL Features from returned JSON.\n\n            this.highlightSource.addFeatures(features); // Add them to the highlight source.\n          }\n        } catch (error) {} // There might be errors in the fetch/JSON parse stage, keep them quiet.\n      });\n  };\n\n  bufferFeatures = (distance) => {\n    const arr = [];\n\n    // Grab all selected features from highlight source…\n    for (const f of this.highlightSource.getFeatures()) {\n      // …use HajkTransformer utility to create a buffered feature…\n      const bufferedFeature = this.#HT.getBuffered(f, distance);\n      arr.push(bufferedFeature);\n    }\n    // …that finally gets added to the buffer zone features source.\n    this.bufferSource.addFeatures(arr);\n  };\n\n  clear = () => {\n    this.highlightSource.clear();\n    this.bufferSource.clear();\n  };\n}\nexport default BufferModel;\n"],"names":["BufferModel","settings","activateSelecting","v","map","on","handleClick","clickLock","add","un","delete","e","getFeaturesAtPixel","pixel","layerFilter","l","name","get","forEach","f","clonedFeature","clone","setStyle","highlightSource","addFeature","getLayers","getArray","filter","getVisible","layersInfo","layer","subLayers","Object","values","subLayersToQuery","subLayer","queryable","queryableSubLayer","id","undefined","coordinate","view","getView","url","getSource","getFeatureInfoUrl","getResolution","getProjection","getCode","INFO_FORMAT","QUERY_LAYERS","join","hfetch","response","json","features","GeoJSON","readFeatures","addFeatures","this","bufferFeatures","distance","arr","getFeatures","bufferedFeature","getBuffered","push","bufferSource","clear","HajkTransformer","projection","VectorSource","highlightLayer","VectorLayer","source","layerType","zIndex","caption","style","Style","fill","Fill","color","stroke","Stroke","width","image","Circle","radius","bufferLayer","addLayer","active"],"sourceRoot":""}